<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Private.Windows.Core</name>
    </assembly>
    <members>
        <member name="F:System.PublicKeys.MicrosoftPublic">
            <summary>
             The standard Microsoft public library public key. The token is b03f5f7f11d50a3a.
            </summary>
        </member>
        <member name="F:System.PublicKeys.MicrosoftShared">
            <summary>
             The standard Microsoft shared library public key. The token is 31bf3856ad364e35.
            </summary>
        </member>
        <member name="F:System.PublicKeys.Ecma">
            <summary>
             The standard Microsoft ECMA key. The token is b77a5c561934e089.
            </summary>
        </member>
        <member name="F:System.PublicKeys.Open">
            <summary>
             The open key. The token is cc7b13ffcd2ddd51.
            </summary>
        </member>
        <member name="F:System.PublicKeys.Moq">
            <summary>
             The standard Moq (mocking test library) public key.
            </summary>
        </member>
        <member name="F:System.Assemblies.Mscorlib">
            <summary>
             The full name of the mscorlib assembly on .NET Framework 4.x.
            </summary>
        </member>
        <member name="F:System.Assemblies.SystemDrawing">
            <summary>
             The full name of the System.Drawing assembly on .NET Framework 4.x.
            </summary>
        </member>
        <member name="F:System.Assemblies.SystemDrawingDesign">
            <summary>
             The full name of the System.Drawing.Design assembly on .NET Framework 4.x.
            </summary>
        </member>
        <member name="F:System.Assemblies.SystemWindowsForms">
            <summary>
             The full name of the System.Windows.Forms assembly on .NET Framework 4.x.
            </summary>
        </member>
        <member name="F:System.Assemblies.SystemDesign">
            <summary>
             The full name of the System.Design assembly on .NET Framework 4.x.
            </summary>
        </member>
        <member name="T:System.BufferScope`1">
            <summary>
             Allows renting a buffer from <see cref="T:System.Buffers.ArrayPool`1"/> with a using statement. Can be used directly as if it
             were a <see cref="T:System.Span`1"/>.
            </summary>
            <remarks>
             <para>
              Buffers are not cleared and as such their initial contents will be random.
             </para>
            </remarks>
        </member>
        <member name="M:System.BufferScope`1.#ctor(System.Span{`0})">
            <summary>
             Create the <see cref="T:System.BufferScope`1"/> with an initial buffer. Useful for creating with an initial stack
             allocated buffer.
            </summary>
        </member>
        <member name="M:System.BufferScope`1.#ctor(System.Span{`0},System.Int32)">
            <summary>
             Create the <see cref="T:System.BufferScope`1"/> with an initial buffer. Useful for creating with an initial stack
             allocated buffer.
            </summary>
            <remarks>
             <para>
              <example>
               <para>Creating with a stack allocated buffer:</para>
               <code>using BufferScope&lt;char> buffer = new(stackalloc char[64]);</code>
              </example>
             </para>
             <para>
              Stack allocated buffers should be kept small to avoid overflowing the stack.
             </para>
            </remarks>
            <param name="minimumLength">
             The required minimum length. If the <paramref name="initialBuffer"/> is not large enough, this will rent from
             the shared <see cref="T:System.Buffers.ArrayPool`1"/>.
            </param>
        </member>
        <member name="M:System.BufferScope`1.EnsureCapacity(System.Int32,System.Boolean)">
            <summary>
             Ensure that the buffer has enough space for <paramref name="capacity"/> number of elements.
            </summary>
            <remarks>
             <para>
              Consider if creating new <see cref="T:System.BufferScope`1"/> instances is possible and cleaner than using
              this method.
             </para>
            </remarks>
            <param name="copy">True to copy the existing elements when new space is allocated.</param>
        </member>
        <member name="T:System.Collections.Generic.ArrayBuilder`1">
            <summary>
             Array based collection that tries to avoid copying the internal array and caps the maximum capacity.
            </summary>
            <remarks>
             <para>
              To mitigate corrupted length attacks, the backing array has an initial allocation size cap.
             </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.ArrayBuilder`1.#ctor(System.Int32)">
            <param name="expectedCount">
             The <see cref="F:System.Collections.Generic.ArrayBuilder`1._count"/> cannot grow past this value and is expected to be this value
             when the collection is "finished".
            </param>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.CreateTrimmedList``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32)">
            <summary>
             Creates a list trimmed to the given count.
            </summary>
            <remarks>
             <para>
              This is an optimized implementation that avoids iterating over the entire list when possible.
             </para>
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.ListConverter`2">
            <summary>
             Helper class for converting values.
            </summary>
            <remarks>
             <para>
              It is intended to save the allocation of a temporary list when converting values. If there are multiple passes
              through the list this class should usually be avoided.
             </para>
            </remarks>
        </member>
        <member name="T:System.DisposableBase">
            <summary>
             Base class for implementing <see cref="T:System.IDisposable"/> with double disposal protection.
            </summary>
        </member>
        <member name="M:System.DisposableBase.Dispose(System.Boolean)">
            <summary>
             Called when the component is being disposed or finalized.
            </summary>
            <param name="disposing">
             <see langword="false"/> if called via a destructor on the finalizer queue. Do not access object fields
             unless <see langword="true"/>.
            </param>
        </member>
        <member name="M:System.DisposableBase.Dispose">
            <summary>
             Disposes the component.
            </summary>
        </member>
        <member name="T:System.DisposableBase.Finalizable">
            <summary>
             <see cref="T:System.DisposableBase"/> with a finalizer.
            </summary>
        </member>
        <member name="M:System.DisposalTracking.SuppressFinalize(System.Object)">
            <summary>
             Used to suppress finalization in debug builds only.
            </summary>
            <remarks>
             <para>
              Unfortunately this can only be used when there is a single implicit conversion operator when called from
              a ref struct. C# tries to cast to anything that fits in object, which leads to an ambiguous error.
             </para>
             <para>
              You need to add GC.SuppressFinalize under #ifdef when you don't have a single implicit conversion.
             </para>
            </remarks>
        </member>
        <member name="M:System.ExceptionExtensions.IsCriticalException(System.Exception)">
            <summary>
             Returns <see langword="true"/> if the exception is an exception that isn't recoverable and/or a likely
             bug in our implementation.
            </summary>
        </member>
        <member name="M:System.ExceptionExtensions.ConvertToSerializationException(System.Exception)">
            <summary>
             Converts the given exception to a <see cref="T:System.Runtime.Serialization.SerializationException"/> if needed, nesting the original exception
             and assigning the original stack trace.
            </summary>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.ReadDateTime(System.IO.BinaryReader)">
            <summary>
             Reads a binary formatted <see cref="T:System.DateTime"/> from the given <paramref name="reader"/>.
            </summary>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The data was invalid.</exception>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.CreateDateTimeFromData(System.Int64)">
            <summary>
             Creates a <see cref="T:System.DateTime"/> object from raw data with validation.
            </summary>
            <exception cref="T:System.Runtime.Serialization.SerializationException"><paramref name="data"/> was invalid.</exception>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.Remaining(System.IO.BinaryReader)">
            <summary>
             Returns the remaining amount of bytes in the given <paramref name="reader"/>.
            </summary>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.ReadPrimitiveArray``1(System.IO.BinaryReader,System.Int32)">
            <summary>
             Reads an array of primitives.
            </summary>
            <inheritdoc cref="M:System.IO.BinaryReaderExtensions.WritePrimitives``1(System.IO.BinaryWriter,System.Collections.Generic.IReadOnlyList{``0})"/>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.WritePrimitives``1(System.IO.BinaryWriter,System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
             Writes a collection of primitives.
            </summary>
            <remarks>
             <para>
              Only supports <see langword="bool"/>, <see langword="byte"/>, <see langword="sbyte"/>, <see langword="char"/>,
              <see langword="short"/>, <see langword="ushort"/>, <see langword="int"/>, <see langword="uint"/>,
              <see langword="long"/>, <see langword="ulong"/>, <see langword="float"/>, <see langword="double"/>,
              <see langword="decimal"/>, <see cref="T:System.DateTime"/>, and <see cref="T:System.TimeSpan"/>.
             </para>
            </remarks>
        </member>
        <member name="M:System.IO.BinaryWriterExtensions.Write(System.IO.BinaryWriter,System.DateTime)">
            <summary>
             Writes a <see cref="T:System.DateTime"/> object to the given <paramref name="writer"/>.
            </summary>
        </member>
        <member name="M:System.IO.BinaryWriterExtensions.Write(System.IO.BinaryWriter,System.Collections.Generic.IReadOnlyList{System.Private.Windows.BinaryFormat.Serializer.MemberTypeInfo})">
            <summary>
             Writes <see cref="T:System.Private.Windows.BinaryFormat.Serializer.MemberTypeInfo"/>.
            </summary>
        </member>
        <member name="T:System.IO.Compression.RunLengthEncoder">
            <summary>
             Simple run length encoder (RLE) that works on spans.
            </summary>
            <remarks>
             <para>
              Format used is a byte for the count, followed by a byte for the value.
             </para>
            </remarks>
        </member>
        <member name="M:System.IO.Compression.RunLengthEncoder.GetEncodedLength(System.ReadOnlySpan{System.Byte})">
            <summary>
             Get the encoded length, in bytes, of the given data.
            </summary>
        </member>
        <member name="M:System.IO.Compression.RunLengthEncoder.GetDecodedLength(System.ReadOnlySpan{System.Byte})">
            <summary>
             Get the decoded length, in bytes, of the given encoded data.
            </summary>
        </member>
        <member name="M:System.IO.Compression.RunLengthEncoder.TryEncode(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
            <summary>
             Encode the given data into the given <paramref name="encoded"/> span.
            </summary>
            <returns>
             <see langword="false"/> if the <paramref name="encoded"/> span was not large enough to hold the encoded data.
            </returns>
        </member>
        <member name="M:System.IO.StreamExtensions.ToIStream(System.IO.Stream,System.Boolean)">
            <summary>
             Get a <see cref="T:Windows.Win32.System.Com.IStream"/> wrapper around the given <paramref name="stream"/>. Use the return value
             in a <see langword="using"/> scope.
            </summary>
        </member>
        <member name="M:System.IO.StreamExtensions.SaveStreamToHGLOBAL(System.IO.Stream,Windows.Win32.Foundation.HGLOBAL@)">
            <summary>
             Save the contents of the <paramref name="stream"/> to a new <see cref="T:Windows.Win32.Foundation.HGLOBAL"/>.
            </summary>
            <param name="stream">The stream to save to the <see cref="T:Windows.Win32.Foundation.HGLOBAL"/>.</param>
            <param name="hglobal">The memory handle if successful. If a non null value is passed in, it will be freed.</param>
            <returns><see cref="F:Windows.Win32.Foundation.HRESULT.S_OK"/> if successful.</returns>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormattedObjectExtensions.Dereference(System.Private.Windows.BinaryFormat.Serializer.IReadOnlyRecordMap,System.Private.Windows.BinaryFormat.Serializer.IRecord)">
            <summary>
             Dereferences <see cref="T:System.Private.Windows.BinaryFormat.Serializer.MemberReference"/> records.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.BinaryFormatWriter">
            <summary>
             Writer that writes specific types in binary format without using the BinaryFormatter.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteString(System.IO.Stream,System.String)">
            <summary>
             Writes a <see langword="string"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteDecimal(System.IO.Stream,System.Decimal)">
            <summary>
             Writes a <see langword="decimal"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteDateTime(System.IO.Stream,System.DateTime)">
            <summary>
             Writes a <see cref="T:System.DateTime"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteTimeSpan(System.IO.Stream,System.TimeSpan)">
            <summary>
             Writes a <see cref="T:System.TimeSpan"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteNativeInt(System.IO.Stream,System.IntPtr)">
            <summary>
             Writes a nint in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteNativeUInt(System.IO.Stream,System.UIntPtr)">
            <summary>
             Writes a nuint in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WritePoint(System.IO.Stream,System.Drawing.Point)">
            <summary>
             Writes a <see cref="T:System.Drawing.Point"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteRectangle(System.IO.Stream,System.Drawing.Rectangle)">
            <summary>
             Writes a <see cref="T:System.Drawing.Rectangle"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteSize(System.IO.Stream,System.Drawing.Size)">
            <summary>
             Writes a <see cref="T:System.Drawing.Size"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WritePointF(System.IO.Stream,System.Drawing.PointF)">
            <summary>
             Writes a <see cref="T:System.Drawing.PointF"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteRectangleF(System.IO.Stream,System.Drawing.RectangleF)">
            <summary>
             Writes a <see cref="T:System.Drawing.RectangleF"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteSizeF(System.IO.Stream,System.Drawing.SizeF)">
            <summary>
             Writes a <see cref="T:System.Drawing.SizeF"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteColor(System.IO.Stream,System.Drawing.Color)">
            <summary>
             Writes a <see cref="T:System.Drawing.Color"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.TryWritePrimitive(System.IO.Stream,System.Object)">
            <summary>
             Attempts to write a <see cref="T:System.Private.Windows.BinaryFormat.Serializer.PrimitiveType"/> value in binary format.
            </summary>
            <returns><see langword="true"/> if successful.</returns>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WritePrimitive(System.IO.Stream,System.Object)">
            <summary>
             Writes a .NET primitive value in binary format.
            </summary>
            <exception cref="T:System.ArgumentException">
             <paramref name="primitive"/> is not a a primitive value.
            </exception>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteStringList(System.IO.Stream,System.Collections.Generic.List{System.String})">
            <summary>
             Writes a <see cref="T:System.Collections.Generic.List`1"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WritePrimitiveList``1(System.IO.Stream,System.Collections.Generic.List{``0})">
            <summary>
             Writes a primitive list in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.TryWritePrimitiveList(System.IO.Stream,System.Collections.IList)">
            <summary>
             Writes the given <paramref name="list"/> in binary format if supported.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.TryWriteArrayList(System.IO.Stream,System.Collections.ArrayList)">
            <summary>
             Writes the given <paramref name="list"/> in binary format if supported.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.TryWriteArray(System.IO.Stream,System.Array)">
            <summary>
             Writes the given <paramref name="array"/> in binary format if supported.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.TryWriteHashtable(System.IO.Stream,System.Collections.Hashtable)">
            <summary>
             Tries to write the given <paramref name="hashtable"/> if supported.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WritePrimitiveHashtable(System.IO.Stream,System.Collections.Hashtable)">
            <summary>
             Writes a <see cref="T:System.Collections.Hashtable"/> of primitive to primitive values to the given stream in binary format.
            </summary>
            <remarks>
             <para>
              Primitive types are anything in the <see cref="T:System.Private.Windows.BinaryFormat.Serializer.PrimitiveType"/> enum.
             </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
             <paramref name="hashtable"/> contained non-primitive values or a custom comparer or hash code provider.
            </exception>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.WriteNotSupportedException(System.IO.Stream,System.NotSupportedException)">
            <summary>
             Writes a <see cref="T:System.NotSupportedException"/> in binary format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.TryWriteFrameworkObject(System.IO.Stream,System.Object)">
            <summary>
             Writes the given <paramref name="value"/> if supported.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.TryWriteDrawingPrimitivesObject(System.IO.Stream,System.Object)">
            <summary>
             Writes the given <paramref name="value"/> to stream, only types that have TypeConverters are supported.
             This function is needed for the Clipboard serialization as Clipboard is not using TypeConverters.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.TryWrite``1(System.Action{System.IO.Stream,``0},System.IO.Stream,``0)">
            <summary>
             Simple wrapper to ensure the <paramref name="stream"/> is reset to its original position if the
             <paramref name="action"/> throws.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.BinaryFormatWriter.TryWrite``1(System.Func{System.IO.Stream,``0,System.Boolean},System.IO.Stream,``0)">
            <summary>
             Simple wrapper to ensure the <paramref name="stream"/> is reset to its original position if the
             <paramref name="func"/> throws or returns <see langword="false"/>.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.ClassRecordDeserializer">
            <summary>
             Base class for deserializing <see cref="T:System.Formats.Nrbf.ClassRecord"/>s.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.ClassRecordFieldInfoDeserializer">
            <summary>
             Deserializer for <see cref="T:System.Formats.Nrbf.ClassRecord"/>s that directly set fields.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.ClassRecordSerializationInfoDeserializer">
            <summary>
             Deserializer for <see cref="T:System.Formats.Nrbf.ClassRecord"/>s that use <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to initialize class state.
            </summary>
            <remarks>
             <para>
              This is used either because the class implements <see cref="T:System.Runtime.Serialization.ISerializable"/> or because a surrogate was used.
             </para>
            </remarks>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.DeserializationOptions.SimpleAssemblyMatching">
            <summary>
             How exactly assembly names need to match for deserialization.
            </summary>
            <remarks>
             <para>
              Aligned with <see href="https://learn.microsoft.com/dotnet/api/system.runtime.serialization.formatters.formatterassemblystyle">
              FormatterAssemblyStyle</see> behavior.
             </para>
            </remarks>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.DeserializationOptions.TypeResolver">
            <summary>
             Type name binder.
            </summary>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.DeserializationOptions.SurrogateSelector">
            <summary>
             Optional type <see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/> provider.
            </summary>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.DeserializationOptions.StreamingContext">
            <summary>
             Streaming context.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Deserializer">
             <summary>
              General binary format deserializer.
             </summary>
             <remarks>
              <para>
               This has some constraints over the BinaryFormatter. Notably it does not support all <see cref="T:System.Runtime.Serialization.IObjectReference"/>
               usages or surrogates that replace object instances. This greatly simplifies the deserialization. It also does not
               allow offset arrays (arrays that have lower bounds other than zero) or multidimensional arrays that have more
               than <see cref="F:System.Int32.MaxValue"/> elements.
              </para>
              <para>
               This deserializer ensures that all value types are assigned to fields or populated in <see cref="T:System.Runtime.Serialization.SerializationInfo"/>
               callbacks with their final state, throwing if that is impossible to attain due to graph cycles or data corruption.
               The value type instance may contain references to uncompleted reference types when there are cycles in the graph.
               In general it is risky to dereference reference types in <see cref="T:System.Runtime.Serialization.ISerializable"/> constructors or in
               <see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/> call backs if there is any risk of the objects enabling a cycle.
              </para>
              <para>
               If you need to dereference reference types in <see cref="T:System.Runtime.Serialization.SerializationInfo"/> waiting for final state by
               implementing <see cref="T:System.Runtime.Serialization.IDeserializationCallback"/> or <see cref="T:System.Runtime.Serialization.OnDeserializedAttribute"/> is the safer way to
               do so. This deserializer does not fire completed events until the entire graph has been deserialized. If a
               surrogate (<see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/>) needs to dereference with potential cycles it would require
               tracking instances by stashing them in a provided <see cref="T:System.Runtime.Serialization.StreamingContext"/> to handle after invoking the
               deserializer.
              </para>
             </remarks>
             <devdoc>
              <see cref="T:System.Runtime.Serialization.IObjectReference"/> makes deserializing difficult as you don't know the final type until you've finished
              populating the serialized type. If <see cref="T:System.Runtime.Serialization.SerializationInfo"/> is involved and you have a cycle you may never
              be able to complete the deserialization as the reference type values in the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> can't
              get the final object.
            
              <see cref="T:System.Runtime.Serialization.IObjectReference"/> is really the only practical way to represent singletons. A common pattern is to
              nest an <see cref="T:System.Runtime.Serialization.IObjectReference"/> object in an <see cref="T:System.Runtime.Serialization.ISerializable"/> object. Specifying the nested
              type when <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> is called by invoking
              <see cref="M:System.Runtime.Serialization.SerializationInfo.SetType(System.Type)"/> will get that type info serialized into the stream.
             </devdoc>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.Deserializer.Options">
            <inheritdoc cref="P:System.Private.Windows.BinaryFormat.IDeserializer.Options"/>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Deserializer._deserializedObjects">
            <inheritdoc cref="P:System.Private.Windows.BinaryFormat.IDeserializer.DeserializedObjects"/>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Deserializer._incompleteObjects">
            <inheritdoc cref="P:System.Private.Windows.BinaryFormat.IDeserializer.IncompleteObjects"/>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.Deserializer.Deserialize(System.Formats.Nrbf.SerializationRecordId,System.Collections.Generic.IReadOnlyDictionary{System.Formats.Nrbf.SerializationRecordId,System.Formats.Nrbf.SerializationRecord},System.Private.Windows.BinaryFormat.DeserializationOptions)">
            <summary>
             Deserializes the object graph for the given <paramref name="recordMap"/> and <paramref name="rootId"/>.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.IDeserializer">
            <summary>
             Interface for deserialization used to define the coupling between the main <see cref="T:System.Private.Windows.BinaryFormat.Deserializer"/>
             and its <see cref="T:System.Private.Windows.BinaryFormat.ObjectRecordDeserializer"/>s.
            </summary>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.IDeserializer.Options">
            <summary>
             The current deserialization options.
            </summary>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.IDeserializer.IncompleteObjects">
            <summary>
             The set of object record ids that are not considered "complete" yet.
            </summary>
            <remarks>
             <para>
              Objects are considered incomplete if they contain references to value or <see cref="T:System.Runtime.Serialization.IObjectReference"/> types
              that need completed or if they have not yet finished evaluating all of their member data. They are also
              considered incomplete if they implement <see cref="T:System.Runtime.Serialization.ISerializable"/> or have a surrogate and the
              <see cref="T:System.Runtime.Serialization.SerializationInfo"/> has not yet been applied.
             </para>
            </remarks>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.IDeserializer.DeserializedObjects">
            <summary>
             The set of objects that have been deserialized, indexed by record id.
            </summary>
            <remarks>
             <para>
              Objects may not be fully filled out. If they are not in <see cref="P:System.Private.Windows.BinaryFormat.IDeserializer.IncompleteObjects"/>, they are
              guaranteed to have their reference type members created (this is not transitive- their members may not
              be ready if there are cycles in the object graph).
             </para>
            </remarks>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.IDeserializer.TypeResolver">
            <summary>
             Resolver for types.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.IDeserializer.PendValueUpdater(System.Private.Windows.BinaryFormat.ValueUpdater)">
            <summary>
             Pend the given value updater to be run when it's value type dependency is complete.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.IDeserializer.PendSerializationInfo(System.Private.Windows.BinaryFormat.PendingSerializationInfo)">
            <summary>
             Pend a <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to be applied when the graph is fully parsed.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.IDeserializer.CompleteObject(System.Formats.Nrbf.SerializationRecordId)">
            <summary>
             Mark the object id as complete. This will check dependencies and resolve relevant <see cref="T:System.Private.Windows.BinaryFormat.ValueUpdater"/>s.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.IDeserializer.GetSurrogate(System.Type)">
            <summary>
             Check for a surrogate for the given type. If none exists, returns <see langword="null"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.ObjectRecordDeserializer.Continue">
            <summary>
             Continue parsing.
            </summary>
            <returns>The id that is necessary to complete parsing or <see cref="T:System.Formats.Nrbf.SerializationRecordId"/> default value if complete.</returns>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.ObjectRecordDeserializer.UnwrapMemberValue(System.Object)">
            <summary>
             Gets the actual object for a member value primitive or record. Returns <see cref="F:System.Private.Windows.BinaryFormat.ObjectRecordDeserializer.s_missingValueSentinel"/> if
             the object record has not been encountered yet.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.ObjectRecordDeserializer.ValidateNewMemberObjectValue(System.Object)">
            <summary>
             Called for new non-primitive reference types.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.ObjectRecordDeserializer.DoesValueNeedUpdated(System.Object,System.Formats.Nrbf.SerializationRecordId)">
            <summary>
             Returns <see langword="true"/> if the given record's value needs an updater applied.
            </summary>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.ValueUpdater.ValueId">
            <summary>
             The value id that needs to be reapplied.
            </summary>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.ValueUpdater.ObjectId">
            <summary>
             The object id that is dependent on <see cref="P:System.Private.Windows.BinaryFormat.ValueUpdater.ValueId"/>.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.ITypeResolver">
            <summary>
             Resolver for types.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.ITypeResolver.BindToType(System.Reflection.Metadata.TypeName)">
            <summary>
             Resolves the given type name against the specified library. Throws if the type cannot be resolved.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.ITypeResolver.TryBindToType(System.Reflection.Metadata.TypeName,System.Type@)">
            <summary>
             Tries to resolve the given type name against the specified library.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.SerializationEvents.AddOnDelegate(System.Object,System.Collections.Generic.List{System.Reflection.MethodInfo})">
            <summary>Add all methods to a delegate.</summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ArrayInfo">
            <summary>
             Array information structure.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/8fac763f-e46d-43a1-b360-80eb83d2c5fb">
               [MS-NRBF] 2.4.2.1
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ArrayRecord">
            <summary>
             Base class for array records.
            </summary>
            <devdoc>
             <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/f57d41e5-d3c0-4340-add8-fa4449a68d1c">
              [MS-NRBF] 2.4
             </see>
             describes how item records must follow the array record and how multiple null records
             can be coalesced into an <see cref="T:System.Private.Windows.BinaryFormat.Serializer.NullRecord.ObjectNullMultiple"/> or
             <see cref="T:System.Private.Windows.BinaryFormat.Serializer.NullRecord.ObjectNullMultiple256"/> record.
            </devdoc>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.Serializer.ArrayRecord.ObjectId">
            <summary>
             Identifier for the array.
            </summary>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.Serializer.ArrayRecord.Length">
            <summary>
             Length of the array.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ArrayRecord`1">
            <summary>
             Typed class for array records.
            </summary>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.Serializer.ArrayRecord`1.ArrayObjects">
            <summary>
             The array items.
            </summary>
            <remarks>
             <para>
              Multi-null records are always expanded to individual <see cref="T:System.Private.Windows.BinaryFormat.Serializer.ObjectNull"/> entries when reading.
             </para>
            </remarks>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.Serializer.ArrayRecord`1.Item(System.Int32)">
            <summary>
             Returns the item at the given index.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ArraySingleObject">
            <summary>
             Single dimensional array of objects.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/982b2f50-6367-402a-aaf2-44ee96e2a5e0">
               [MS-NRBF] 2.4.3.2
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ArraySinglePrimitive`1">
            <summary>
             Single dimensional array of a primitive type.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/3a50a305-5f32-48a1-a42a-c34054db310b">
               [MS-NRBF] 2.4.3.3
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ArraySingleString">
            <summary>
             Single dimensional array of strings.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/3d98fd60-d2b4-448a-ac0b-3cd8dea41f9d">
               [MS-NRBF] 2.4.3.4
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.BinaryLibrary">
            <summary>
             Library full name information.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/7fcf30e1-4ad4-4410-8f1a-901a4a1ea832">
               [MS-NRBF] 2.6.2
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.BinaryObjectString">
            <summary>
             String record.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/eb503ca5-e1f6-4271-a7ee-c4ca38d07996">
               [MS-NRBF] 2.5.7
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.BinaryType">
            <summary>
             Identifies the remoting type of a class member or array item.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/054e5c58-be21-4c86-b1c3-f6d3ce17ec72">
               [MS-NRBF] 2.1.2.2
              </see>
             </para>
            </remarks>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.BinaryType.Primitive">
            <summary>
             Type is defined by <see cref="T:System.Private.Windows.BinaryFormat.Serializer.PrimitiveType"/> and it is not a string.
            </summary>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.BinaryType.String">
            <summary>
             Type is
             <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/10b218f5-9b2b-4947-b4b7-07725a2c8127">
              length prefixed string.
             </see>
            </summary>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.BinaryType.Object">
            <summary>
             Type is System.Object.
            </summary>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.BinaryType.SystemClass">
            <summary>
             Type is a standard .NET object.
            </summary>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.BinaryType.Class">
            <summary>
             Type is an object.
            </summary>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.BinaryType.ObjectArray">
            <summary>
             Type is a single-dimensional array of objects.
            </summary>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.BinaryType.StringArray">
            <summary>
             Type is a single-dimensional array of strings.
            </summary>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.BinaryType.PrimitiveArray">
            <summary>
             Types is a single-dimensional array of a primitive type.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ClassInfo">
            <summary>
             Class info.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/0a192be0-58a1-41d0-8a54-9c91db0ab7bf">
               [MS-NRBF] 2.3.1.1
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ClassRecord">
            <summary>
             Base class for class records.
            </summary>
            <remarks>
             <para>
              Includes the values for the class (which trail the record)
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/c9bc3af3-5a0c-4b29-b517-1b493b51f7bb">
               [MS-NRBF] 2.3.
              </see>
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.Serializer.ClassRecord.WriteValuesFromMemberTypeInfo(System.IO.BinaryWriter,System.Collections.Generic.IReadOnlyList{System.Private.Windows.BinaryFormat.Serializer.MemberTypeInfo},System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
             Writes <paramref name="memberValues"/> as specified by the <paramref name="memberTypeInfo"/>
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ClassTypeInfo">
            <summary>
             Identifies a class by it's name and library id.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/844b24dd-9f82-426e-9b98-05334307a239">
               [MS-NRBF] 2.1.1.8
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ClassWithId">
            <summary>
             Class information that references another class record's metadata.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/2d168388-37f4-408a-b5e0-e48dbce73e26">
               [MS-NRBF] 2.3.2.5
              </see>
             </para>
            </remarks>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.Serializer.ClassWithId.MetadataId">
            <summary>
             The ObjectId of a prior <see cref="T:System.Private.Windows.BinaryFormat.Serializer.SystemClassWithMembersAndTypes"/>
             or <see cref="T:System.Private.Windows.BinaryFormat.Serializer.ClassWithMembersAndTypes"/>.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ClassWithMembersAndTypes">
            <summary>
             Class information with type info and the source library.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/847b0b6a-86af-4203-8ed0-f84345f845b9">
               [MS-NRBF] 2.3.2.1
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.IBinaryWriteable">
            <summary>
             Expresses that the object can be written with a <see cref="T:System.IO.BinaryWriter"/>
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.Serializer.IBinaryWriteable.Write(System.IO.BinaryWriter)">
            <summary>
             Writes the current object to the given <paramref name="writer"/>.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.IPrimitiveTypeRecord">
            <summary>
             Record that represents a primitive type or an array of primitive types.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.IReadOnlyRecordMap">
            <summary>
             Map of records.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.IRecord">
            <summary>
             Non-generic record base interface.
            </summary>
        </member>
        <member name="P:System.Private.Windows.BinaryFormat.Serializer.IRecord.Id">
            <summary>
             Id for the record, or null if the record has no id.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.IRecord`1">
            <summary>
             Typed record interface.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.IWritableRecord">
            <summary>
             Expresses that the object can be written with a <see cref="T:System.IO.BinaryWriter"/>
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.Serializer.IWritableRecord.Write(System.IO.BinaryWriter)">
            <summary>
             Writes the current object to the given <paramref name="writer"/>.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.MemberPrimitiveTyped">
            <summary>
             Primitive value other than <see langword="string"/>.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/c0a190b2-762c-46b9-89f2-c7dabecfc084">
               [MS-NRBF] 2.5.1
              </see>
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.Serializer.MemberPrimitiveTyped.#ctor(System.Object)">
            <exception cref="T:System.ArgumentException"><paramref name="value"/> is not primitive.</exception>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.MemberReference">
            <summary>
             The <see cref="T:System.Private.Windows.BinaryFormat.Serializer.MemberReference"/> record contains a reference to another record that contains the actual value.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/eef0aa32-ab03-4b6a-a506-bcdfc10583fd">
               [MS-NRBF] 2.5.3
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.MemberTypeInfo">
            <summary>
             Member type info.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/aa509b5a-620a-4592-a5d8-7e9613e0a03e">
               [MS-NRBF] 2.3.1.2
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.MessageEnd">
            <summary>
             Record that marks the end of the binary format stream.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.NullRecord">
            <summary>
             Base class for null records.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.NullRecord.ObjectNullMultiple">
            <summary>
             Multiple null object record.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/f4abb5dd-aab7-4e0a-9d77-1d6c99f5779e">
               [MS-NRBF] 2.5.5
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.NullRecord.ObjectNullMultiple256">
            <summary>
             Multiple null object record (less than 256).
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/f4abb5dd-aab7-4e0a-9d77-1d6c99f5779e">
               [MS-NRBF] 2.5.5
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.ObjectNull">
            <summary>
             Null object record.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/fe51522c-23d1-48dd-9913-c84894abc127">
               [MS-NRBF] 2.5.4
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.PrimitiveType">
            <summary>
             Primitive type.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/4e77849f-89e3-49db-8fb9-e77ee4bc7214">
               [MS-NRBF] 2.1.2.3
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.Record">
            <summary>
             Base record class.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.Serializer.Record.WritePrimitiveType(System.IO.BinaryWriter,System.Private.Windows.BinaryFormat.Serializer.PrimitiveType,System.Object)">
            <summary>
             Writes <paramref name="value"/> as <paramref name="primitiveType"/> to the given <paramref name="writer"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.Serializer.Record.WriteRecords(System.IO.BinaryWriter,System.Collections.Generic.IReadOnlyList{System.Object},System.Boolean)">
            <summary>
             Writes records, coalescing null records into single entries.
            </summary>
            <exception cref="T:System.InvalidOperationException">
             <paramref name="objects"/> contained an object that isn't a record.
            </exception>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.RecordMap">
            <summary>
             Map of records that ensures that IDs are only entered once.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.RecordType">
            <summary>
             Record type.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/954a0657-b901-4813-9398-4ec732fe8b32">
               [MS-NRBF] 2.1.2.1
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.SerializationHeader">
            <summary>
             Binary format header.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/a7e578d3-400a-4249-9424-7529d10d1b3c">
               [MS-NRBF] 2.6.1
              </see>
             </para>
            </remarks>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.SerializationHeader.RootId">
            <summary>
             The id of the root object record.
            </summary>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.SerializationHeader.HeaderId">
            <summary>
             Ignored. BinaryFormatter puts out -1.
            </summary>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.SerializationHeader.MajorVersion">
            <summary>
             Must be 1.
            </summary>
        </member>
        <member name="F:System.Private.Windows.BinaryFormat.Serializer.SerializationHeader.MinorVersion">
            <summary>
             Must be 0.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.Serializer.SystemClassWithMembersAndTypes">
            <summary>
             System class information with type info.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/openspecs/windows_protocols/ms-nrbf/ecb47445-831f-4ef5-9c9b-afd4d06e3657">
               [MS-NRBF] 2.3.2.3
              </see>
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.FormatterConverterStub">
            <summary>
             <see cref="T:System.Runtime.Serialization.IFormatterConverter"/> that only returns default values.
            </summary>
            <remarks>
             <para>
              Allows creating a <see cref="T:System.Runtime.Serialization.SerializationInfo"/> when a <see cref="T:System.Runtime.Serialization.IFormatterConverter"/>
              isn't necessary.
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.SerializationExtensions.GetValue``1(System.Runtime.Serialization.SerializationInfo,System.String)">
            <summary>
             Get a typed value. Hard casts.
            </summary>
        </member>
        <member name="T:System.Private.Windows.BinaryFormat.StringRecordsCollection">
            <summary>
             Helper to create and track records for <see cref="T:System.Private.Windows.BinaryFormat.Serializer.BinaryObjectString"/> and <see cref="T:System.Private.Windows.BinaryFormat.Serializer.MemberReference"/>
             when duplicates are found.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.StringRecordsCollection.GetStringRecord(System.String)">
            <summary>
             Returns the appropriate record for the given string.
            </summary>
        </member>
        <member name="M:System.Private.Windows.BinaryFormat.TypeExtensions.GetPrimitiveType(System.Type)">
            <summary>
             Returns the <see cref="T:System.Private.Windows.BinaryFormat.Serializer.PrimitiveType"/> for the given <paramref name="type"/>.
            </summary>
            <returns><see cref="T:System.Private.Windows.BinaryFormat.Serializer.PrimitiveType"/> or <see langword="default"/> if not a <see cref="T:System.Private.Windows.BinaryFormat.Serializer.PrimitiveType"/>.</returns>
        </member>
        <member name="P:System.Private.Windows.CoreAppContextSwitches.ClipboardDragDropEnableUnsafeBinaryFormatterSerialization">
            <summary>
             If <see langword="true"/>, then Clipboard and DataObject Get and Set methods will attempts to serialize or deserialize
             binary formatted content using either <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> or System.Windows.Forms.BinaryFormat.Deserializer.
             To use <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>, application should also opt in into the
             "System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization" option and reference the out-of-band
             "System.Runtime.Serialization.Formatters" NuGet package and opt out from using the System.Windows.Forms.BinaryFormat.Deserializer
             by setting "Windows.ClipboardDragDrop.EnableNrbfSerialization" to <see langword="true"/>
            </summary>
        </member>
        <member name="P:System.Private.Windows.CoreAppContextSwitches.ClipboardDragDropEnableNrbfSerialization">
            <summary>
             If <see langword="true"/>, then Clipboard Get methods will prefer System.Windows.Forms.BinaryFormat.Deserializer
             to deserialize the payload, if needed. If <see langword="false"/>, then <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> is used
             to get full compatibility with the downlevel versions of .NET.
            </summary>
            <remarks>
             <para>
              This switch has no effect if "Windows.ClipboardDragDrop.EnableUnsafeBinaryFormatterSerialization"
              is set to <see langword="false"/>.
             </para>
            </remarks>
        </member>
        <member name="P:System.Private.Windows.CoreAppContextSwitches.DragDropDisableSyncOverAsync">
            <summary>
             If <see langword="true"/>, then async capable drag/drop operations will not be performed in a synchronous manner.
            </summary>
            <remarks>
             <para>
              Some drag sources only support async operations. Notably, Chromium-based applications with file drop (the
              new Outlook is one example). To enable applications to accept filenames from these sources we use the interface
              when available and just do the operation synchronously. This isn't expected to be a problem, but if it is we'll
              provide a way to opt out of this behavior. The flag may also be useful for testing purposes.
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.Count">
            <summary>
             Positive <see langword="int"/> enforcing count of items.
            </summary>
            <devdoc>
             Idea here is that doing this makes it less likely we'll slip through cases where
             we don't check for negative numbers. And also not confuse counts with ids.
            </devdoc>
        </member>
        <member name="P:System.Private.Windows.FeatureSwitches.EnableUnsafeBinaryFormatterSerialization">
            <summary>
             Feature switch that wraps whether or not <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> is enabled.
            </summary>
            <remarks>
             <para>
              By wrapping in a feature switch, the setting can be used to control trim warnings related to usage of
              the <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>. Code past a feature switch isn't considered for warnings if the
              switch isn't enabled.
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.Graphics.IBitmap">
            <summary>
             Platform agnostic interface for a bitmap.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Graphics.IBitmap.GetHbitmap">
            <summary>
             Gets a Win32 HBITMAP handle for this bitmap.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Graphics.IBitmap.Size">
            <summary>
             Size of the bitmap in pixels.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Id">
            <summary>
             Identifier struct.
            </summary>
        </member>
        <member name="T:System.Private.Windows.JsonData`1">
             <summary>
              Wrapper which contains JSON serialized data along with the JSON data's original type information
              to be deserialized later.
             </summary>
             <remarks>
              <para>
               There may be instances where this type is not available in different versions, e.g. .NET 8, .NET Framework.
               If this type needs to be deserialized from stream in these instances, a workaround would be to create an assembly with the name <see cref="F:System.Private.Windows.IJsonData.CustomAssemblyName"/>
               and replicate this type. Then, manually retrieve the serialized stream and use the <see cref="T:System.Formats.Nrbf.NrbfDecoder"/> to decode the stream and rehydrate the serialized type.
               Alternatively, but not recommended, BinaryFormatter can also be used to deserialize the stream if this type is not available.
              </para>
             </remarks>
             <example>
             <![CDATA[
              // Recommended: deserialize using NrbfDecoder.
              void DeserializeJsonData(DataObject dataObject)
              {
                 // Manually retrieve serialized stream.
                 System.Runtime.InteropServices.ComTypes.FORMATETC formatetc = new()
                 {
                     cfFormat = (short)DataFormats.GetFormat("yourDataFormat").Id,
                     dwAspect = System.Runtime.InteropServices.ComTypes.DVASPECT.DVASPECT_CONTENT,
                     lindex = -1,
                     tymed = System.Runtime.InteropServices.ComTypes.TYMED.TYMED_HGLOBAL
                 };
            
                 System.Runtime.InteropServices.ComTypes.IDataObject castedDataObject = (System.Runtime.InteropServices.ComTypes.IDataObject)dataObject;
                 castedDataObject.GetData(ref formatetc, out System.Runtime.InteropServices.ComTypes.STGMEDIUM medium);
                 IntPtr hglobal = medium.unionmember;
                 Stream stream;
                 try
                 {
                     IntPtr buffer = GlobalLock(hglobal);
                     int size = GlobalSize(hglobal);
                     byte[] bytes = new byte[size];
                     Marshal.Copy(buffer, bytes, 0, size);
                     // this comes from DataObject.Composition.s_serializedObjectID
                     int index = 16;
                     stream = new MemoryStream(bytes, index, bytes.Length - index);
                 }
                 finally
                 {
                     GlobalUnlock(hglobal);
                 }
            
                 // Use Nrbf to decode stream and rehydrate data.
                 System.Formats.Nrbf.SerializationRecord record = System.Formats.Nrbf.NrbfDecoder.Decode(stream);
                 if (record.TypeName.AssemblyName.FullName != "System.Private.Windows.VirtualJson")
                 {
                     // The data was not serialized as JSON.
                     return;
                 }
            
                 if (record is not System.Formats.Nrbf.ClassRecord types
                     || types.GetRawValue("<JsonBytes>k__BackingField") is not System.Formats.Nrbf.SZArrayRecord<byte> byteData
                     || types.GetRawValue("<InnerTypeAssemblyQualifiedName>k__BackingField") is not string innerTypeAssemblyQualifiedName
                     || !System.Reflection.Metadata.TypeName.TryParse(innerTypeAssemblyQualifiedName.ToCharArray(), out System.Reflection.Metadata.TypeName? innerTypeName))
                 {
                     // This is supposed to be JsonData, but somehow the data is corrupt.
                     throw new InvalidOperationException();
                 }
            
                 // TODO: Additional checking on 'innerTypeName' to ensure it is expected type.
            
                 // This should return the original data that was JSON serialized.
                 var result = System.Text.Json.JsonSerializer.Deserialize(byteData.GetArray(), innerType);
                 // TODO: Process the payload as needed.
              }
            
              [DllImport("kernel32.dll")]
              static extern int GlobalSize(IntPtr hMem);
            
              [DllImport("kernel32.dll")]
              static extern IntPtr GlobalLock(IntPtr hMem);
            
              [DllImport("kernel32.dll")]
              static extern int GlobalUnlock(IntPtr hMem);
            
              // OR
              // Not recommended: deserialize using BinaryFormatter.
            
              // This definition must live in an assembly named System.Private.Windows.VirtualJson and referenced in order to work as expected.
              namespace System.Private.Windows;
              [Serializable]
              struct JsonData : IObjectReference
              {
                 public byte[] JsonBytes { get; set; }
            
                 public string InnerTypeAssemblyQualifiedName { get; set; }
            
                 public object GetRealObject(StreamingContext context)
                 {
                     // TODO: Additional checking on InnerTypeAssemblyQualifiedName to ensure it is expected type.
                     return JsonSerializer.Deserialize(JsonBytes, typeof(ExpectedType)) ?? throw new InvalidOperationException();
                 }
              }
              ]]>
             </example>
        </member>
        <member name="T:System.Private.Windows.IJsonData">
            <summary>
             Represents an object that contains JSON serialized data. This interface is used to
             identify a <see cref="T:System.Private.Windows.JsonData`1"/> without needing to have the generic type information.
            </summary>
        </member>
        <member name="P:System.Private.Windows.IJsonData.InnerTypeAssemblyQualifiedName">
            <summary>
             The assembly qualified name of the T in <see cref="T:System.Private.Windows.JsonData`1"/>. This name should
             have any <see cref="T:System.Runtime.CompilerServices.TypeForwardedFromAttribute"/> names taken into account.
            </summary>
        </member>
        <member name="M:System.Private.Windows.IJsonData.Deserialize">
            <summary>
             Deserializes the data stored in the JsonData. This is a convenience method
             to deserialize the data when we are not dealing with a binary formatted record.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Nrbf.CoreNrbfSerializer">
            <summary>
             Core NRBF serializer. Supports common .NET types.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Nrbf.FullyQualifiedTypeName">
            <summary>
             Represents a fully qualified type name split into assembly name and type name.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.INrbfSerializer.TryWriteObject(System.IO.Stream,System.Object)">
            <summary>
             Tries to write supported objects to a stream.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.INrbfSerializer.TryGetObject(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to read supported objects from a <see cref="T:System.Formats.Nrbf.SerializationRecord"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.INrbfSerializer.TryBindToType(System.Reflection.Metadata.TypeName,System.Type@)">
            <summary>
             Tries to bind the given type name to a supported type.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.INrbfSerializer.IsFullySupportedType(System.Type)">
             <summary>
              Returns <see langword="true"/> if the type is fully supported by the serializer.
             </summary>
             <remarks>
              <para>
               This should only return <see langword="true"/> for types that are expected to be safe to deserialize. It is
               used to indicate that we should consider the type "corrupted" and should not make a second attempt through
               the <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>. It is also used as the allowed list of types that we'll auto-bind when
               user type resolvers return <see langword="null"/>.
              </para>
              <para>
               <see cref="M:System.Private.Windows.Nrbf.INrbfSerializer.TryBindToType(System.Reflection.Metadata.TypeName,System.Type@)"/> and <see cref="M:System.Private.Windows.Nrbf.INrbfSerializer.TryGetObject(System.Formats.Nrbf.SerializationRecord,System.Object@)"/>
               can handle some types partially.
              </para>
             </remarks>
             <devdoc>
              All types should be vetted to ensure that they are resilient to corrupted primitive data in the BinaryFormatter
              deserialization process. There can be no possibility of cycles (direct or indirect self-reference) or ways to
              break object state with bad primitive data (invalid enum values, etc.). If the type has a serialization
              constructor, it must be safe to call with any data. If the type does not have a serialization constructor,
              it must be safe to populate all instance fields with any data.
            
              Accepted types should not be abstract and should be sealed.
            
              We make no guarantees here about the safety of using the BinaryFormatter with these types. This is a best
              effort to help avoid corruption exploitation.
            
              Hashtable is one that we return false for, for example. While we handle ones that have nothing beyond
              primitives (such as `string` to `string`), we don't support anything else, including custom comparers.
             </devdoc>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.DecodeNrbf(System.IO.Stream)">
            <inheritdoc cref="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.DecodeNrbf(System.IO.Stream,System.Collections.Generic.IReadOnlyDictionary{System.Formats.Nrbf.SerializationRecordId,System.Formats.Nrbf.SerializationRecord}@)"/>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.DecodeNrbf(System.IO.Stream,System.Collections.Generic.IReadOnlyDictionary{System.Formats.Nrbf.SerializationRecordId,System.Formats.Nrbf.SerializationRecord}@)">
            <summary>
             Decodes a NRBF stream, converting any exceptions to <see cref="T:System.Runtime.Serialization.SerializationException"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.Deserialize(System.Formats.Nrbf.SerializationRecord,System.Collections.Generic.IReadOnlyDictionary{System.Formats.Nrbf.SerializationRecordId,System.Formats.Nrbf.SerializationRecord},System.Private.Windows.BinaryFormat.ITypeResolver)">
            <summary>
             Deserializes the <see cref="T:System.Formats.Nrbf.SerializationRecord"/> to an object.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetPoint(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a <see cref="T:System.Drawing.Point"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetSize(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a <see cref="T:System.Drawing.Size"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetRectangle(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a <see cref="T:System.Drawing.Rectangle"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetPointF(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a <see cref="T:System.Drawing.PointF"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetSizeF(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a <see cref="T:System.Drawing.SizeF"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetRectangleF(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a <see cref="T:System.Drawing.RectangleF"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetColor(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a <see cref="T:System.Drawing.Color"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetPrimitiveType(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a primitive type or string.
            </summary>
            <returns><see langword="true"/> if this represented a primitive type or string.</returns>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetPrimitiveList(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:System.Formats.Nrbf.PrimitiveType"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetPrimitiveArrayList(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a <see cref="T:System.Collections.ArrayList"/> of <see cref="T:System.Formats.Nrbf.PrimitiveType"/> values.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetPrimitiveArray(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as an <see cref="T:System.Array"/> of primitive types.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetPrimitiveHashtable(System.Formats.Nrbf.SerializationRecord,System.Collections.Hashtable@)">
            <summary>
             Tries to get this object as a binary formatted <see cref="T:System.Collections.Hashtable"/> of <see cref="T:System.Formats.Nrbf.PrimitiveType"/> keys and values.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetPrimitiveHashtable(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a binary formatted <see cref="T:System.Collections.Hashtable"/> of <see cref="T:System.Formats.Nrbf.PrimitiveType"/> keys and values.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetNotSupportedException(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Tries to get this object as a binary formatted <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetFrameworkObject(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Try to get a supported .NET type object (not WinForms) that has no <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetDrawingPrimitivesObject(System.Formats.Nrbf.SerializationRecord,System.Object@)">
            <summary>
             Try to get a supported System.Drawing.Primitives object that has a <see cref="T:System.ComponentModel.TypeConverter"/>.
             This method is used for Clipboard payload deserialization. ResX deserialization uses <see cref="T:System.ComponentModel.TypeConverter"/>s for these types.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Nrbf.SerializationRecordExtensions.TryGetObjectFromJson``1(System.Formats.Nrbf.SerializationRecord,System.Private.Windows.BinaryFormat.ITypeResolver,``0@)">
            <summary>
             Tries to deserialize this object if it was serialized as JSON.
            </summary>
            <param name="object">
             When <see langword="true"/> is returned, this will be the deserialized object or <see langword="default"/>
             if is was a JSON serialized type and the type did not match.
            </param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
             If the data was supposed to be our <see cref="T:System.Private.Windows.JsonData`1"/>, but was serialized incorrectly.
            </exception>
            <exception cref="T:System.NotSupportedException">If an exception occurred while JSON deserializing.</exception>
            <devdoc>
             We don't try to resolve all types in the graph of a type when deserializing JSON as the default options
             should not present the same risks as BinaryFormatter deserialization. JSON binding is just for the root
             type.
            </devdoc>
        </member>
        <member name="M:System.Private.Windows.Ole.BinaryFormatUtilities`1.WriteObjectToStream(System.IO.MemoryStream,System.Object,System.String)">
            <summary>
             Writes an object to the provided memory stream.
            </summary>
            <param name="stream">The memory stream to write the object to.</param>
            <param name="data">The object to write to the stream.</param>
            <param name="format">The format of the data being written.</param>
            <exception cref="T:System.NotSupportedException">
             Thrown when <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> is not supported.
            </exception>
        </member>
        <member name="M:System.Private.Windows.Ole.BinaryFormatUtilities`1.TryReadObjectFromStream``1(System.IO.MemoryStream,System.Private.Windows.Ole.DataRequest@,``0@)">
            <summary>
             Reads an object from the provided memory stream.
            </summary>
            <typeparam name="T">The type of the object to read.</typeparam>
            <param name="stream">The memory stream to read the object from.</param>
            <param name="request">The data request containing the format and resolver.</param>
            <returns>The deserialized object, or <see langword="null"/> if the data is not of the given type.</returns>
            <exception cref="T:System.NotSupportedException">Thrown when <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> is not enabled.</exception>
        </member>
        <member name="T:System.Private.Windows.Ole.ClipboardCore`1">
            <summary>
             Contains platform-agnostic clipboard operations.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.ClipboardCore`1.OleRetryCount">
            <summary>
             The number of times to retry OLE clipboard operations.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.ClipboardCore`1.OleRetryDelay">
            <summary>
             The amount of time in milliseconds to sleep between retrying OLE clipboard operations.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.ClipboardCore`1.Clear(System.Int32,System.Int32)">
            <summary>
             Removes all data from the Clipboard.
            </summary>
            <returns>An <see cref="T:Windows.Win32.Foundation.HRESULT"/> indicating the success or failure of the operation.</returns>
        </member>
        <member name="M:System.Private.Windows.Ole.ClipboardCore`1.Flush(System.Int32,System.Int32)">
            <summary>
             Flushes data to the Clipboard.
            </summary>
            <returns>An <see cref="T:Windows.Win32.Foundation.HRESULT"/> indicating the success or failure of the operation.</returns>
        </member>
        <member name="M:System.Private.Windows.Ole.ClipboardCore`1.SetData(System.Private.Windows.Ole.IComVisibleDataObject,System.Boolean,System.Int32,System.Int32)">
            <summary>
             Attempts to set the specified data on the Clipboard.
            </summary>
            <param name="dataObject">The data object to set on the Clipboard.</param>
            <param name="copy">Indicates whether to copy the data to the Clipboard.</param>
            <param name="retryTimes">The number of times to retry the operation if it fails.</param>
            <param name="retryDelay">The amount of time in milliseconds to wait between retries.</param>
            <returns>An <see cref="T:Windows.Win32.Foundation.HRESULT"/> indicating the success or failure of the operation.</returns>
        </member>
        <member name="M:System.Private.Windows.Ole.ClipboardCore`1.TryGetData(Windows.Win32.Foundation.ComScope{Windows.Win32.System.Com.IDataObject}@,System.Object@,System.Int32,System.Int32)">
            <summary>
             Attempts to retrieve data from the Clipboard.
            </summary>
            <param name="proxyDataObject">The proxy data object retrieved from the Clipboard.</param>
            <param name="originalObject">The original object retrieved from the Clipboard, if available.</param>
            <returns>An <see cref="T:Windows.Win32.Foundation.HRESULT"/> indicating the success or failure of the operation.</returns>
            <inheritdoc cref="M:System.Private.Windows.Ole.ClipboardCore`1.SetData(System.Private.Windows.Ole.IComVisibleDataObject,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:System.Private.Windows.Ole.ClipboardCore`1.IsObjectOnClipboard(System.Object,System.Int32,System.Int32)">
            <summary>
             Returns true if the given <paramref name="object"/> is currently on the Clipboard.
            </summary>
            <remarks>
             <para>This is meant to emulate the OleIsCurrentClipboard API.</para>
            </remarks>
            <param name="object">The object to check.</param>
            <returns>'true' if <paramref name="object"/> is currently on the Clipboard.</returns>
            <inheritdoc cref="M:System.Private.Windows.Ole.ClipboardCore`1.SetData(System.Private.Windows.Ole.IComVisibleDataObject,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:System.Private.Windows.Ole.ClipboardCore`1.GetDataObject``2(``1@,System.Int32,System.Int32)">
            <summary>
             Returns the data that is currently on the clipboard as the platform specified <typeparamref name="TIDataObject"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.ClipboardCore`1.IsValidTypeForFormat(System.Type,System.String)">
            <summary>
             Checks if the specified <paramref name="format"/> is valid and compatible with the specified <paramref name="type"/>.
            </summary>
            <remarks>
             <para>
              This is intended to be used as a pre-validation step to give a more useful error to callers.
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.Ole.Composition`3">
            <summary>
             Contains the logic to move between <see cref="T:System.Private.Windows.Ole.IDataObjectInternal"/>, <see cref="T:Windows.Win32.System.Com.IDataObject.Interface"/>,
             and <see cref="T:System.Runtime.InteropServices.ComTypes.IDataObject"/> calls.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.Composition`3.SetDataAsJson``2(``0,System.String)">
            <summary>
             Stores the data in the specified format using the <see cref="T:System.Text.Json.JsonSerializer"/>.
            </summary>
            <param name="format">The format associated with the data. See DataFormats for predefined formats.</param>
            <param name="data">The data to store.</param>
            <remarks>
             <para>
              The default behavior of <see cref="T:System.Text.Json.JsonSerializer"/> is used to serialize the data.
             </para>
             <para>
              See
              <see href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/how-to#serialization-behavior"/>
              and <see href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/reflection-vs-source-generation#metadata-collection"/>
              for more details on default <see cref="T:System.Text.Json.JsonSerializer"/> behavior.
             </para>
             <para>
              If custom JSON serialization behavior is needed, manually JSON serialize the data and then use SetData,
              or create a custom <see cref="T:System.Text.Json.Serialization.JsonConverter"/>, attach the
              <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute"/>, and then recall this method.
              See <see href="https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/converters-how-to"/> for more details
              on custom converters for JSON serialization.
             </para>
            </remarks>
            <inheritdoc cref="M:System.Private.Windows.Ole.DataObjectCore`1.TryJsonSerialize``1(System.String,``0)"/>
        </member>
        <member name="T:System.Private.Windows.Ole.Composition`3.ManagedToNativeAdapter">
            <summary>
             Maps <see cref="T:Windows.Win32.System.Com.IDataObject"/> to <see cref="T:Windows.Win32.System.Com.IDataObject.Interface"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.Composition`3.ManagedToNativeAdapter.GetTymedUsable(Windows.Win32.System.Com.TYMED)">
            <summary>
             Returns true if the tymed is usable.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Ole.Composition`3.NativeToManagedAdapter">
            <summary>
             Maps native pointer <see cref="T:Windows.Win32.System.Com.IDataObject"/> to <see cref="T:System.Runtime.InteropServices.ComTypes.IDataObject"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.Composition`3.NativeToManagedAdapter.TryGetDataFromHGLOBAL``1(Windows.Win32.Foundation.HGLOBAL,System.Private.Windows.Ole.DataRequest@,``0@)">
            <summary>
             Retrieves the specified format from the specified <paramref name="hglobal"/>.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.Composition`3.NativeToManagedAdapter.TryGetObjectFromDataObject``1(Windows.Win32.System.Com.IDataObject*,System.Private.Windows.Ole.DataRequest@,System.Boolean@,``0@)">
            <summary>
             Extracts a managed object from <see cref="T:Windows.Win32.System.Com.IDataObject"/> of the specified format.
            </summary>
            <param name="doNotContinue">
             A restricted type was encountered, do not continue trying to deserialize.
            </param>
            <returns>
             <para>
              <see langword="true"/> if the managed object of <see cref="T:System.Type"/> <typeparamref name="T"/> was successfully
              created, <see langword="false"/> if the payload does not contain the specified format or the specified type.
             </para>
             <para>
              If <paramref name="dataObject"/> contains <see cref="T:System.IO.MemoryStream"/> that contains a serialized object,
              we return that object cast to <typeparamref name="T"/> or null. If that <see cref="T:System.IO.MemoryStream"/> is
              not a serialized object, and a stream was requested, i.e. can be assigned to <typeparamref name="T"/>
              we return that <see cref="T:System.IO.MemoryStream"/>.
             </para>
            </returns>
            <exception cref="T:System.NotSupportedException"> is deserialization failed.</exception>
        </member>
        <member name="T:System.Private.Windows.Ole.Composition`3.NativeToRuntimeAdapter">
            <summary>
             Maps native pointer <see cref="T:Windows.Win32.System.Com.IDataObject"/> to the .NET Runtime <see cref="T:System.Runtime.InteropServices.ComTypes.IDataObject"/>.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Ole.Composition`3.RuntimeToNativeAdapter">
            <summary>
             Maps the runtime <see cref="T:System.Runtime.InteropServices.ComTypes.IDataObject"/> to the native <see cref="T:Windows.Win32.System.Com.IDataObject.Interface"/>.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.DataFormatNames.DragContext">
            <summary>
             A format used internally by the drag image manager.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.DataFormatNames.DragImageBits">
            <summary>
             A format that contains the drag image bottom-up device-independent bitmap bits.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.DataFormatNames.DragSourceHelperFlags">
            <summary>
             A format that contains the value passed to <see cref="M:Windows.Win32.UI.Shell.IDragSourceHelper2.Interface.SetFlags(System.UInt32)"/>
             and controls whether to allow text specified in <see cref="T:Windows.Win32.UI.Shell.DROPDESCRIPTION"/> to be displayed on the drag image.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.DataFormatNames.DragWindow">
            <summary>
             A format used to identify an object's drag image window so that it's visual information can be updated dynamically.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.DataFormatNames.IsShowingLayered">
            <summary>
             A format that is non-zero if the drop target supports drag images.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.DataFormatNames.IsShowingText">
            <summary>
             A format that is non-zero if the drop target supports drop description text.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.DataFormatNames.UsingDefaultDragImage">
            <summary>
             A format that is non-zero if the drag image is a layered window with a size of 96x96.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DataFormatNames.AddMappedFormats``1(System.String,``0)">
            <summary>
             Adds all the "synonyms" for the specified format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DataFormatNames.IsPredefinedFormat(System.String)">
            <summary>
             Check if the <paramref name="format"/> is one of the predefined formats, which formats that
             correspond to primitives or are pre-defined in the OS such as strings, bitmaps, and OLE types.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DataFormatsCore`1.EnsurePredefined">
            <summary>
             Ensures that the Win32 predefined formats are setup in our format list.
             This is called anytime we need to search the list
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DataObjectCore`1.TryJsonSerialize``1(System.String,``0)">
            <summary>
             JSON serialize the data only if the format is not a restricted deserialization format and the data is not an intrinsic type.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> or <paramref name="format"/> is null.</exception>
            <exception cref="T:System.ArgumentException">
             <paramref name="format"/> is empty, whitespace, or a predefined format -or- <paramref name="data"/> isa a DataObject.
            </exception>
        </member>
        <member name="T:System.Private.Windows.Ole.DataRequest">
            <summary>
             Encapsulates state of a data request.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.DataRequest.Resolver">
            <summary>
             Provides the list of custom allowed types that user considers safe to deserialize from the payload.
             Resolver should recognize the closure of all non-primitive and not known types in the payload,
             such as field types and types in the inheritance hierarchy and the code to match these types to the
             <see cref="T:System.Reflection.Metadata.TypeName"/>s read from the deserialized stream.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.DataRequest.TypedRequest">
            <summary>
             <see langword="false"/> if the user had not requested any specific type, i.e. the call originates from
             <see cref="M:System.Private.Windows.Ole.IDataObjectInternal.GetData(System.String)"/> API family, that returns an <see cref="T:System.Object"/>. <see langword="true"/>
             if the user had requested a specific type by calling <see cref="M:System.Private.Windows.Ole.IDataObjectInternal.TryGetData``1(``0@)"/> API family.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DataStore`1.SetData(System.Object)">
            <inheritdoc cref="M:System.Private.Windows.Ole.IDataObjectInternal.SetData(System.Object)"/>
            <remarks>
             <para>
              This is the only method that has special behavior for <see cref="T:System.Runtime.Serialization.ISerializable"/> objects.
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.Ole.DragDropFormat">
            <summary>
             Represents a private format used for data transfer by the drag-and-drop helpers.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropFormat.#ctor(System.UInt16,Windows.Win32.System.Com.STGMEDIUM,System.Boolean)">
            <summary>
             Initializes a new instance of the <see cref="T:System.Private.Windows.Ole.DragDropFormat"/> class using the specified format, storage medium, and owner.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropFormat.GetData">
            <summary>
             Returns a copy of the storage medium in this instance.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropFormat.RefreshData(System.UInt16,Windows.Win32.System.Com.STGMEDIUM,System.Boolean)">
            <summary>
             Refreshes the storage medium in this instance.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropFormat.CopyData(System.UInt16,Windows.Win32.System.Com.STGMEDIUM)">
            <summary>
             Copies a given storage medium.
            </summary>
            <returns>
             A copy of <paramref name="mediumSource"/>.
            </returns>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropFormat.ReleaseData">
            <summary>
             Frees the storage medium in this instance.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Ole.DragDropHelper`2">
            <summary>
             Helper class for drop targets to display the drag image while the cursor is over the target window and allows the
             application to specify the drag image bitmap that will be displayed during a drag-and-drop operation.
            </summary>
            <devdoc>
             This class effectively requires the data object on events to be an instance of DataObject
             (via <see cref="T:System.Private.Windows.Ole.IComVisibleDataObject"/>) currently.
            </devdoc>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.ClearDropDescription(System.Private.Windows.Ole.IComVisibleDataObject)">
            <summary>
             Sets the drop object image and accompanying text back to the default.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.DragEnter(Windows.Win32.Foundation.HWND,System.Private.Windows.Ole.IDragEvent)">
            <summary>
             Notifies the drag-image manager that the drop target has been entered, and provides it with the information
             needed to display the drag image.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.DragEnter(Windows.Win32.Foundation.HWND,System.Private.Windows.Ole.IComVisibleDataObject,System.Drawing.Point@,Windows.Win32.System.Ole.DROPEFFECT)">
            <summary>
             Notifies the drag-image manager that the drop target has been entered, and provides it with the information
             needed to display the drag image.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.DragLeave">
            <summary>
             Notifies the drag-image manager that the cursor has left the drop target.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.DragOver(System.Private.Windows.Ole.IDragEvent)">
            <summary>
             Notifies the drag-image manager that the cursor position has changed
             and provides it with the information needed to display the drag image.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.Drop(System.Private.Windows.Ole.IDragEvent)">
            <summary>
             Notifies the drag-image manager that the object has been dropped, and provides it with the information needed
             to display the drag image.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.IsInDragLoop(System.Private.Windows.Ole.IDataObjectInternal)">
            <summary>
             Determines whether the data object is in a drag loop.
            </summary>
            <returns>
             <see langword="true"/> if <paramref name="dataObject"/> is in a drag-and-drop loop; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.IsInDragLoopFormat(Windows.Win32.System.Com.FORMATETC)">
            <summary>
             Determines whether the specified format is a drag loop format.
            </summary>
            <returns>
             <see langword="true"/> if <paramref name="format"/> is a drag loop format; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.ReleaseDragDropFormats(System.Private.Windows.Ole.IComVisibleDataObject)">
            <summary>
             Releases formats used by the drag-and-drop helper.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.SetBooleanFormat(System.Private.Windows.Ole.IComVisibleDataObject,System.String,System.Boolean)">
            <summary>
             Sets boolean formats into a data object used to set and display drag images and drop descriptions.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.SetDragImage(System.Private.Windows.Ole.IComVisibleDataObject,System.Private.Windows.Ole.IGiveFeedbackEvent)">
            <summary>
             Initializes the drag-image manager and sets the drag image bitmap into a data object.
            </summary>
            <remarks>
             <para>
              Because InitializeFromBitmap always performs the RGB multiplication step in calculating the alpha value, you should
              always pass a bitmap without pre-multiplied alpha blending. Note that no error will result from passing a bitmap
              with pre-multiplied alpha blending, but this method will multiply it again, doubling the resulting alpha value.
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.SetDragImage(System.Private.Windows.Ole.IComVisibleDataObject,System.Private.Windows.Graphics.IBitmap,System.Drawing.Point,System.Boolean)">
            <summary>
             Initializes the drag-image manager and sets the drag image bitmap into a data object.
            </summary>
            <remarks>
             <para>
              Because InitializeFromBitmap always performs the RGB multiplication step in calculating the alpha value, you should
              always pass a bitmap without pre-multiplied alpha blending. Note that no error will result from passing a bitmap
              with pre-multiplied alpha blending, but this method will multiply it again, doubling the resulting alpha value.
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.SetDropDescription(System.Private.Windows.Ole.IDragEvent)">
            <summary>
             Sets the drop description into a data object. Describes the image and accompanying text for a drop object.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.SetDropDescription(System.Private.Windows.Ole.IComVisibleDataObject,Windows.Win32.UI.Shell.DROPIMAGETYPE,System.String,System.String)">
            <summary>
             Sets the drop description into a data object. Describes the image and accompanying text for a drop object.
            </summary>
            <remarks>
             <para>
              Some UI coloring is applied to the text in <paramref name="message"/> if used by specifying %1 in
              <paramref name="messageReplacementToken"/>. The characters %% and %1 are the subset of FormatMessage
              markers that are processed here.
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.SetInDragLoop(System.Private.Windows.Ole.IComVisibleDataObject,System.Boolean)">
            <summary>
             Sets the InDragLoop format into a data object.
            </summary>
            <remarks>
             <para>
              Used to determine whether the data object is in a drag loop.
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.SetIsShowingText(System.Private.Windows.Ole.IComVisibleDataObject,System.Boolean)">
            <summary>
             Sets the IsShowingText format into a data object.
            </summary>
            <remarks>
             <para>
              To effectively display the drop description after changing the drag image bitmap, set <paramref name="isShowingText"/>
              to true; otherwise the drop description text will not be displayed.
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.SetUsingDefaultDragImage(System.Private.Windows.Ole.IComVisibleDataObject,System.Boolean)">
            <summary>
             Sets the UsingDefaultDragImage format into a data object.
            </summary>
            <remarks>
             <para>
              Specify <see langword="true"/> for <paramref name="usingDefaultDragImage"/> to use a layered window
              drag image with a size of 96x96.
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.Ole.DragDropHelper`2.TryGetDragDropHelper``1(``0**)">
            <summary>
             Creates an in-process server drag-image manager object and returns the specified interface pointer.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Ole.FormatEnumerator">
            <summary>
             Part of IComDataObject, used to interop with OLE.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Ole.IComVisibleDataObject">
            <summary>
             Used to filter to fully COM visible data objects. Notably the platform specific DataObject class.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Ole.IDataFormat">
            <summary>
             Internal interface for a data format.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.IDataFormat.Name">
            <summary>
             Specifies the name of this format.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.IDataFormat.Id">
            <summary>
             Specifies the ID number for this format.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Ole.IDataFormat`1">
            <summary>
             Typed interface for a data format that allows for creation.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataFormat`1.Create(System.String,System.Int32)">
            <summary>
             Creates a new instance of the data format.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Ole.IDataObjectInternal">
            <summary>
             Internal interface for a data object class.
            </summary>
            <remarks>
             <para>
              The methods here abstract the platform specific IDataObject and ITypedDataObject interfaces
              in both WPF and WinForms. It composes the two interfaces.
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.GetData(System.String,System.Boolean)">
            <summary>
             Retrieves the data associated with the specified data format, using
             <paramref name="autoConvert"/> to determine whether to convert the data to the format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.GetData(System.String)">
            <summary>
             Retrieves the data associated with the specified data format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.GetData(System.Type)">
            <summary>
             Retrieves the data associated with the specified class type format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.GetDataPresent(System.String,System.Boolean)">
            <summary>
             Determines whether data stored in this instance is associated with the
             specified format, using <paramref name="autoConvert"/> to determine whether
             to convert the data to the format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.GetDataPresent(System.String)">
            <summary>
             Determines whether data stored in this instance is associated with, or
             can be converted to, the specified format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.GetDataPresent(System.Type)">
            <summary>
             Determines whether data stored in this instance is associated with, or
             can be converted to, the specified format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.GetFormats(System.Boolean)">
            <summary>
             Gets a list of all formats that data stored in this instance is associated
             with or can be converted to, using <paramref name="autoConvert"/> to determine
             whether to retrieve all formats that the data can be converted to, or
             only native data formats.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.GetFormats">
            <summary>
             Gets a list of all formats that data stored in this instance is
             associated with or can be converted to.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.SetData(System.String,System.Boolean,System.Object)">
            <summary>
             Stores the specified data and its associated format in this instance,
             using autoConvert to specify whether the data can be converted to
             another format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.SetData(System.String,System.Object)">
            <summary>
             Stores the specified data and its associated format in this instance.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.SetData(System.Type,System.Object)">
            <summary>
             Stores the specified data and its associated class type in this instance.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.SetData(System.Object)">
            <summary>
             Stores the specified data in this instance, using the class of the
             data for the format.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.TryGetData``1(``0@)">
            <summary>
             Retrieves data associated with data format named after <typeparamref name="T"/>,
             if that data is of type <typeparamref name="T"/>.
            </summary>
            <inheritdoc cref="M:System.Private.Windows.Ole.IDataObjectInternal.TryGetData``1(System.String,System.Func{System.Reflection.Metadata.TypeName,System.Type},System.Boolean,``0@)"/>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.TryGetData``1(System.String,``0@)">
            <summary>
             Retrieves data associated with the specified format if that data is of type <typeparamref name="T"/>.
            </summary>
            <inheritdoc cref="M:System.Private.Windows.Ole.IDataObjectInternal.TryGetData``1(System.String,System.Func{System.Reflection.Metadata.TypeName,System.Type},System.Boolean,``0@)"/>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.TryGetData``1(System.String,System.Boolean,``0@)">
            <summary>
             Retrieves data in a specified format if that data is of type <typeparamref name="T"/>,
             optionally converting the data to the specified format.
            </summary>
            <inheritdoc cref="M:System.Private.Windows.Ole.IDataObjectInternal.TryGetData``1(System.String,System.Func{System.Reflection.Metadata.TypeName,System.Type},System.Boolean,``0@)"/>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal.TryGetData``1(System.String,System.Func{System.Reflection.Metadata.TypeName,System.Type},System.Boolean,``0@)">
            <summary>
             Retrieves typed data associated with the specified data format.
            </summary>
            <param name="resolver">
             A user-provided function that maps <see cref="T:System.Reflection.Metadata.TypeName"/> to <see cref="T:System.Type"/>.
            </param>
            <param name="format">
             A string that specifies what format to retrieve the data as. See the DataFormats class for
             a set of predefined data formats.
            </param>
            <param name="autoConvert">
             <see langword="true"/> to attempt to automatically convert the data to the specified format;
             <see langword="false"/> for no data format conversion.
            </param>
            <param name="data">
             A data object with the data in the specified format, or <see langword="default"/> if the data is not available
             in the specified format or is of a wrong type.
            </param>
            <returns>
             <see langword="true"/> if the data of this format is present and the value is of a matching type and that
             value can be successfully retrieved.
            </returns>
            <remarks>
             <para>
              The <paramref name="resolver"/> should throw <see cref="T:System.NotSupportedException"/> for types it does not
              want loaded. The consuming method should honor this and not load the requested type. The resolver can also
              return <see langword="null"/> to indicate that it wants default handling, which may also result in a
              resolution failure.
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.Ole.IDataObjectInternal`2">
            <summary>
             Platform typed data object interface. Provides methods to construct and unwrap platform specific data objects.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IDataObjectInternal`2.TryUnwrapUserDataObject(`1@)">
            <summary>
             Unwraps the user IDataObject instance when applicable.
            </summary>
            <param name="dataObject">
             <para>
              This is used to return the "original" IDataObject instance when getting data back from OLE. Providing the
              original instance back allows casting to the original type, which historically happened through "magic"
              casting support for built-in COM interop.
             </para>
             <para>
              Now that we use ComWrappers, we can't rely on the "magic" casting support. Instead, we provide the original
              object back when we're able to unwrap it. The unfortunate caveat is that the behavior of calling through
              the OLE IDataObject proxy results in different behavior than calling through the original object. This
              primarily happens through `autoConvert` scenarios, where no such concept exists in the COM interfaces. As
              such, when calling through the COM interface, "autoConvert" is always considered to be <see langword="true"/>.
              To mitigate the COM caveat, we do not give back the original DataObject if we created it implicitly via
              Clipboard.SetData. This allows the calls to go through the proxy, which gets the expected "autoConvert"
              behavior.
             </para>
             <para>
              One potential alternative would be to wrap the created IDataObject in an adapter that mimics the
              "autoConvert" behavior. This would avoid BinaryFormat serialization when in process and not copying.
             </para>
            </param>
            <returns>true when a data object was returned.</returns>
        </member>
        <member name="P:System.Private.Windows.Ole.IDragEvent.X">
            <summary>
             Gets the x-coordinate of the mouse pointer.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.IDragEvent.Y">
            <summary>
             Gets the y-coordinate of the mouse pointer.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.IDragEvent.Effect">
            <summary>
             Gets which drag-and-drop operations are allowed by the target of the drag event.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.IDragEvent.DropImageType">
            <summary>
             Gets the drop description image type.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.IDragEvent.DataObject">
            <summary>
             Data object, if any, associated with the drag event.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.IDragEvent.Message">
            <summary>
             Gets or sets the drop description text such as "Move to %1".
            </summary>
            <remarks>
             <para>
              UI coloring is applied to the text in <see cref="P:System.Private.Windows.Ole.IDragEvent.MessageReplacementToken"/>
              if used by specifying %1 in <see cref="P:System.Private.Windows.Ole.IDragEvent.Message"/>.
             </para>
            </remarks>
        </member>
        <member name="P:System.Private.Windows.Ole.IDragEvent.MessageReplacementToken">
            <summary>
             Gets or sets the drop description text such as "Documents" when %1 is specified in <see cref="P:System.Private.Windows.Ole.IDragEvent.Message"/>.
            </summary>
            <remarks>
             <para>
              UI coloring is applied to the text in <see cref="P:System.Private.Windows.Ole.IDragEvent.MessageReplacementToken"/>
              if used by specifying %1 in <see cref="P:System.Private.Windows.Ole.IDragEvent.Message"/>.
             </para>
            </remarks>
        </member>
        <member name="T:System.Private.Windows.Ole.IGiveFeedbackEvent">
            <summary>
             Runtime agnostic interface for the GiveFeedback event.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.IGiveFeedbackEvent.DragImage">
            <summary>
             Gets the drag image bitmap.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.IGiveFeedbackEvent.CursorOffset">
            <summary>
             Gets the drag image cursor offset.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Ole.IGiveFeedbackEvent.UseDefaultDragImage">
            <summary>
             Gets a value indicating whether a layered window drag image is used.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Ole.IOleServices">
            <summary>
             Platform specific OLE services.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IOleServices.EnsureThreadState">
            <summary>
             This method is called to validate that OLE is initialized and
             that the current thread is a single-threaded apartment (STA).
            </summary>
            <exception cref="T:System.Threading.ThreadStateException">Current thread is not in the right state for OLE.</exception>
        </member>
        <member name="M:System.Private.Windows.Ole.IOleServices.GetDataHere(System.String,System.Object,Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)">
            <summary>
             Called after unsuccessfully performing clipboard <see cref="F:Windows.Win32.System.Com.TYMED.TYMED_HGLOBAL"/> serialization.
            </summary>
            <remarks>
             <para>
              <paramref name="pformatetc"/> and <paramref name="pmedium"/> are checked for validity before this call.
             </para>
            </remarks>
            <param name="format">The data format that is being serialized.</param>
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.GetDataHere(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)"/>
        </member>
        <member name="M:System.Private.Windows.Ole.IOleServices.TryGetObjectFromDataObject``1(Windows.Win32.System.Com.IDataObject*,System.String,``0@)">
            <summary>
             If the <typeparamref name="T"/> is a the requested format this method will attempt to extract it
             from the <paramref name="dataObject"/>.
            </summary>
            <param name="format">The data format that is being requested.</param>
            <remarks>
             <para>
              This is intended for platform specific logic, notably for bitmaps and metafiles.
             </para>
            </remarks>
            <returns><see langword="true"/> if a bitmap was extracted.</returns>
        </member>
        <member name="M:System.Private.Windows.Ole.IOleServices.IsValidTypeForFormat(System.Type,System.String)">
            <summary>
             Returns true if the given <paramref name="type"/> is a valid type for the given <paramref name="format"/>.
            </summary>
            <remarks>
             <para>
              Basic predefined formats that map to <see langword="string"/> are checked before this call.
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.Ole.IOleServices.AllowTypeWithoutResolver``1">
            <summary>
             Allows the given <typeparamref name="T"/> to pass pre-validation without a resolver.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IOleServices.ValidateDataStoreData(System.String@,System.Boolean,System.Object)">
            <summary>
             Allows custom validation or adapting of <see cref="T:System.Private.Windows.Ole.DataStore`1"/> data and formats.
            </summary>
            <param name="format">
             The format to be checked against <paramref name="data"/>, can be modified to another format name if
             <paramref name="autoConvert"/> is true.
            </param>
            <param name="data">The data to be checked against <paramref name="data"/>.</param>
        </member>
        <member name="M:System.Private.Windows.Ole.IOleServices.CreateDataObject">
            <summary>
             Creates an <see cref="T:System.Private.Windows.Ole.IComVisibleDataObject"/> instance.
            </summary>
        </member>
        <member name="M:System.Private.Windows.Ole.IOleServices.OleGetClipboard(Windows.Win32.System.Com.IDataObject**)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.OleGetClipboard(Windows.Win32.System.Com.IDataObject**)"/>/>
        </member>
        <member name="M:System.Private.Windows.Ole.IOleServices.OleSetClipboard(Windows.Win32.System.Com.IDataObject*)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.OleSetClipboard(Windows.Win32.System.Com.IDataObject*)"/>
        </member>
        <member name="M:System.Private.Windows.Ole.IOleServices.OleFlushClipboard">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.OleFlushClipboard"/>
        </member>
        <member name="T:System.Private.Windows.Ole.RestrictedTypeDeserializationException">
            <summary>
             This exception is used to indicate that clipboard contains a serialized
             managed object that contains unexpected types and that we should stop processing this data.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.TextDataFormat.Text">
            <summary>
             Specifies the standard ANSI text format.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.TextDataFormat.UnicodeText">
            <summary>
             Specifies the standard Windows Unicode text format.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.TextDataFormat.Rtf">
            <summary>
             Specifies text consisting of Rich Text Format (RTF) data.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.TextDataFormat.Html">
            <summary>
             Specifies text consisting of HTML data.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.TextDataFormat.CommaSeparatedValue">
            <summary>
             Specifies a comma-separated value (CSV) format, which is a
             common interchange format used by spreadsheets.
            </summary>
        </member>
        <member name="F:System.Private.Windows.Ole.TextDataFormat.Xaml">
            <summary>
             Specifies a data format as Xaml.
            </summary>
        </member>
        <member name="T:System.Private.Windows.Ole.TypeBinder`1">
            <summary>
             A type resolver for use when processing binary formatted streams.
            </summary>
            <remarks>
             <para>
              If the resolver function is not provided, a resolver is created that handles the specified root <see cref="T:System.Type"/>.
             </para>
             <para>
              If the resolver returns <see langword="null"/>, the <typeparamref name="TNrbfSerializer"/> is used to attempt to
              bind the type. If the type is not fully supported, the type is not bound. If users want to override this behavior,
              they should throw in their resolver.
             </para>
             <para>
              Unbound types will throw a <see cref="T:System.NotSupportedException"/> when attempting to bind.
             </para>
             <para>
              This class is used in <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> and NRBF deserialization.
             </para>
            </remarks>
        </member>
        <member name="M:System.Private.Windows.Ole.TypeBinder`1.#ctor(System.Type,System.Private.Windows.Ole.DataRequest@)">
            <summary>
             Type resolver for use with <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> and NRBF deserializers to restrict types
             that can be instantiated.
            </summary>
            <param name="rootType"><see cref="T:System.Type"/> that the user expects to read from the binary formatted stream.</param>
        </member>
        <member name="T:System.Private.Windows.Ole.GlobalBuffer">
            <summary>
             Simple scope for writing to HGLOBAL memory.
            </summary>
        </member>
        <member name="M:System.Private.Windows.OsVersion.IsWindows10_1507OrGreater">
            <summary>
             Is Windows 10 first release or later. (Threshold 1, build 10240, version 1507)
            </summary>
        </member>
        <member name="M:System.Private.Windows.OsVersion.IsWindows10_1607OrGreater">
            <summary>
             Is Windows 10 Anniversary Update or later. (Redstone 1, build 14393, version 1607)
            </summary>
        </member>
        <member name="M:System.Private.Windows.OsVersion.IsWindows10_1703OrGreater">
            <summary>
             Is Windows 10 Creators Update or later. (Redstone 2, build 15063, version 1703)
            </summary>
        </member>
        <member name="M:System.Private.Windows.OsVersion.IsWindows10_1709OrGreater">
            <summary>
             Is Windows 10 Creators Update or later. (Redstone 3, build 16299, version 1709)
            </summary>
        </member>
        <member name="M:System.Private.Windows.OsVersion.IsWindows10_18030rGreater">
            <summary>
             Is Windows 10 Creators Update or later. (Redstone 4, build 17134, version 1803)
            </summary>
        </member>
        <member name="M:System.Private.Windows.OsVersion.IsWindows11_OrGreater">
            <summary>
             Is this Windows 11 public preview or later?
             The underlying API does not read supportedOs from the manifest, it returns the actual version.
            </summary>
        </member>
        <member name="M:System.Private.Windows.OsVersion.IsWindows11_22H2OrGreater">
            <summary>
             Is this Windows 11 version 22H2 or greater?
             The underlying API does not read supportedOs from the manifest, it returns the actual version.
            </summary>
        </member>
        <member name="M:System.Private.Windows.OsVersion.IsWindows8_1OrGreater">
            <summary>
             Is Windows 8.1 or later.
            </summary>
        </member>
        <member name="M:System.Private.Windows.OsVersion.IsWindows8OrGreater">
            <summary>
             Is Windows 8 or later.
            </summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.COM2UnhandledVT">
            <summary>Unhandled VT: {0}.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.Serialization_MissingCtor">
            <summary>The constructor to deserialize an object of type '{0}' was not found.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.Serialization_Surrogates">
            <summary>Surrogate must return the same object that was provided in the 'obj' parameter.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.Serialization_IObjectReferenceOnlyPrimivite">
            <summary>IObjectReference type '{0}' can only have primitive member data.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.Serialization_Incomplete">
            <summary>Objects could not be deserialized completely.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.Serialization_Cycle">
            <summary>Unexpected parser cycle.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.Serialization_MissingField">
            <summary>Could not find field '{0}' data for type '{1}'.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.Serialization_TypeNotSerializable">
            <summary>Type '{0}' is not marked as serializable.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.Serialization_MissingType">
            <summary>Could not find type '{0}'.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.RegisterCFFailed">
            <summary>Clipboard format registration did not succeed.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.ClipboardOrDragDrop_JsonDeserializationFailed">
            <summary>Failed to deserialize JSON data.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.ExternalException">
            <summary>External exception</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.BinaryFormatterNotSupported">
            <summary>BinaryFormatter serialization and deserialization are disabled within this application. See https://aka.ms/binaryformatter for more information.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.BinaryFormatter_NotSupported_InClipboardOrDragDrop">
            <summary>BinaryFormatter is not supported in clipboard or drag-and-drop operations.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.BinaryFormatter_NotSupported_InClipboardOrDragDrop_UseTypedAPI">
            <summary>BinaryFormatter is not supported in clipboard or drag-and-drop operations. Please enable it and use 'TryGetData&lt;T&gt;' APIs with a 'resolver' function that defines a set of allowed types to deserialize '{0}'.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.ClipboardOrDragDrop_UseTypedAPI">
            <summary>Please use 'TryGetData&lt;T&gt;' APIs with a 'resolver' function that defines a set of allowed types to deserialize '{0}'.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.ClipboardOrDragDrop_TypedAPI_InvalidResolver">
            <summary>Type {0} is not found. If this type is allowed, please ensure that the 'resolver' function provided in 'TryGetData&lt;T&gt;' APIs supports it.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.ClipboardOrDragDrop_InvalidType">
            <summary>'{0}' is not a concrete type, and could result in an unbounded deserialization attempt. Please use a concrete type or alternatively define a 'resolver' function that supports types that you are expecting to retrieve from the clipboard or use in drag-and-dr ...</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.ClipboardOrDragDrop_InvalidFormatTypeCombination">
            <summary>The specified type '{0}' is not compatible with the specified format '{1}'.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.ClipboardOrDragDrop_CannotJsonSerializeDataObject">
            <summary>'DataObject' can not be serialized as JSON directly. Use 'DataObject.SetDataAsJson' APIs to add JSON serialized data to an existing DataObject.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.ClipboardOrDragDrop_CannotJsonSerializePredefinedFormat">
            <summary>Predefined formats should not be serialized as JSON.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.NotSupportedExceptionOnClipboard">
            <summary>Clipboard contains a 'NotSupportedException' that indicates that write operation failed. '{0}'.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.UnexpectedClipboardType">
            <summary>Clipboard contains an unexpected type.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.UnexpectedTypeForClipboardFormat">
            <summary>The specified Clipboard format is not compatible with '{0}' type.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.CollectionEmptyException">
            <summary>Cannot operate with an empty collection.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.Clipboard_InvalidPath">
            <summary>Path "{0}" in the argument "{1}" is not valid.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusAborted">
            <summary>Function was ended.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusAccessDenied">
            <summary>File access is denied.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusFileNotFound">
            <summary>File not found.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusGenericError">
            <summary>A generic error occurred in GDI+.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusInsufficientBuffer">
            <summary>Buffer is too small (internal GDI+ error).</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusInvalidParameter">
            <summary>Parameter is not valid.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusInvalidOperation">
            <summary>An object could not be created, possibly due to a lack of memory, but most likely due to invalid input.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusNotImplemented">
            <summary>Not implemented.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusOverflow">
            <summary>Overflow error.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusPropertyNotFoundError">
            <summary>Property cannot be found.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusPropertyNotSupportedError">
            <summary>Property is not supported.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusUnknown">
            <summary>Unknown GDI+ error occurred.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusWrongState">
            <summary>Bitmap region is already locked.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusUnknownImageFormat">
            <summary>Image format is unknown.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusUnsupportedGdiplusVersion">
            <summary>Current version of GDI+ does not support this feature.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusFontFamilyNotFound">
            <summary>Font '{0}' cannot be found.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusFontStyleNotFound">
            <summary>Font '{0}' does not support style '{1}'.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusNotInitialized">
            <summary>GDI+ is not properly initialized (internal GDI+ error).</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusObjectBusy">
            <summary>Object is currently in use elsewhere.</summary>
        </member>
        <member name="P:System.Private.Windows.Core.Resources.SR.GdiplusNotTrueTypeFont_NoName">
            <summary>Only TrueType fonts are supported. This is not a TrueType font.</summary>
        </member>
        <member name="T:System.Reflection.Metadata.TypeNameComparer">
            <summary>
             Compares <see cref="T:System.Reflection.Metadata.TypeName"/>s.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeNameComparer.FullyQualifiedMatch">
            <summary>
             Creates a comparer that does a fully qualified type name match.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeNameComparer.FullNameMatch">
            <summary>
             Creates a comparer that does a full type name match. Ignores the assembly.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeNameComparer.FullNameAndAssemblyNameMatch">
            <summary>
             Creates a comparer that does a full type name and assembly name match.
             Ignores assembly version, culture, and public key token.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.TypeNameComparison.TypeFullName">
            <summary>
             Use the full name of the type (default). (Namespace + Name)
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.TypeNameComparison.AssemblyName">
            <summary>
             Use the assembly name of the type.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.TypeNameComparison.AssemblyCultureName">
            <summary>
             Use the assembly culture of the type.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.TypeNameComparison.AssemblyVersion">
            <summary>
             Use the assembly version of the type.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.TypeNameComparison.AssemblyPublicKeyToken">
            <summary>
             Use the assembly public key token of the type.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.TypeNameComparison.All">
            <summary>
             Use all parts of the fully qualified type name.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.TypeNameComparison.AllButAssemblyVersion">
            <summary>
             Match all parts of the fully qualified type name except the assembly version.
            </summary>
        </member>
        <member name="M:System.SpanHelpers.CopyAndTerminate(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
            <summary>
             Copies the <paramref name="source"/> to the <paramref name="destination"/>,
             terminating with null and truncating <paramref name="source"/> to fit if
             necessary.
            </summary>
        </member>
        <member name="M:System.SpanHelpers.SliceAtFirstNull(System.ReadOnlySpan{System.Char})">
            <summary>
             Slices the given <paramref name="span"/> at the first null found (if any).
            </summary>
        </member>
        <member name="M:System.SpanHelpers.SliceAtFirstNull(System.Span{System.Char})">
            <summary>
             Slices the given <paramref name="span"/> at the first null found (if any).
            </summary>
        </member>
        <member name="T:System.SpanReader`1">
            <summary>
             Fast stack based <see cref="T:System.ReadOnlySpan`1"/> reader.
            </summary>
            <remarks>
             <para>
              Care must be used when reading struct values that depend on a specific field state for members to work
              correctly. For example, <see cref="T:System.DateTime"/> has a very specific set of valid values for its packed
              <see langword="ulong"/> field.
             </para>
             <para>
              Inspired by <see cref="T:System.Buffers.SequenceReader`1"/> patterns.
             </para>
            </remarks>
        </member>
        <member name="M:System.SpanReader`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
             Fast stack based <see cref="T:System.ReadOnlySpan`1"/> reader.
            </summary>
            <remarks>
             <para>
              Care must be used when reading struct values that depend on a specific field state for members to work
              correctly. For example, <see cref="T:System.DateTime"/> has a very specific set of valid values for its packed
              <see langword="ulong"/> field.
             </para>
             <para>
              Inspired by <see cref="T:System.Buffers.SequenceReader`1"/> patterns.
             </para>
            </remarks>
        </member>
        <member name="M:System.SpanReader`1.TryReadTo(`0,System.ReadOnlySpan{`0}@)">
            <summary>
             Try to read everything up to the given <paramref name="delimiter"/>. Advances the reader past the
             <paramref name="delimiter"/> if found.
            </summary>
            <inheritdoc cref="M:System.SpanReader`1.TryReadTo(`0,System.Boolean,System.ReadOnlySpan{`0}@)"/>
        </member>
        <member name="M:System.SpanReader`1.TryReadTo(`0,System.Boolean,System.ReadOnlySpan{`0}@)">
            <summary>
             Try to read everything up to the given <paramref name="delimiter"/>.
            </summary>
            <param name="span">The read data, if any.</param>
            <param name="delimiter">The delimiter to look for.</param>
            <param name="advancePastDelimiter"><see langword="true"/> to move past the <paramref name="delimiter"/> if found.</param>
            <returns><see langword="true"/> if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:System.SpanReader`1.TryRead(`0@)">
            <summary>
             Try to read the next value.
            </summary>
        </member>
        <member name="M:System.SpanReader`1.TryRead(System.Int32,System.ReadOnlySpan{`0}@)">
            <summary>
             Try to read a span of the given <paramref name="count"/>.
            </summary>
        </member>
        <member name="M:System.SpanReader`1.TryRead``1(``0@)">
            <summary>
             Try to read a value of the given type. The size of the value must be evenly divisible by the size of
             <typeparamref name="T"/>.
            </summary>
            <remarks>
             <para>
              This is just a straight copy of bits. If <typeparamref name="TValue"/> has methods that depend on
              specific field value constraints this could be unsafe.
             </para>
             <para>
              The compiler will often optimize away the struct copy if you only read from the value.
             </para>
            </remarks>
        </member>
        <member name="M:System.SpanReader`1.TryRead``1(System.Int32,System.ReadOnlySpan{``0}@)">
            <summary>
             Try to read a span of values of the given type. The size of the value must be evenly divisible by the size of
             <typeparamref name="T"/>.
            </summary>
            <remarks>
             <para>
              This effectively does a <see cref="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})"/> and the same
              caveats apply about safety.
             </para>
            </remarks>
        </member>
        <member name="M:System.SpanReader`1.IsNext(System.ReadOnlySpan{`0})">
            <summary>
             Check to see if the given <paramref name="next"/> values are next.
            </summary>
            <param name="next">The span to compare the next items to.</param>
        </member>
        <member name="M:System.SpanReader`1.TryAdvancePast(System.ReadOnlySpan{`0})">
            <summary>
             Advance the reader if the given <paramref name="next"/> values are next.
            </summary>
            <param name="next">The span to compare the next items to.</param>
            <returns><see langword="true"/> if the values were found and the reader advanced.</returns>
        </member>
        <member name="M:System.SpanReader`1.AdvancePast(`0)">
            <summary>
             Advance the reader past consecutive instances of the given <paramref name="value"/>.
            </summary>
            <returns>How many positions the reader has been advanced</returns>
        </member>
        <member name="M:System.SpanReader`1.Advance(System.Int32)">
            <summary>
             Advance the reader by the given <paramref name="count"/>.
            </summary>
        </member>
        <member name="M:System.SpanReader`1.Rewind(System.Int32)">
            <summary>
             Rewind the reader by the given <paramref name="count"/>.
            </summary>
        </member>
        <member name="M:System.SpanReader`1.Reset">
            <summary>
             Reset the reader to the beginning of the span.
            </summary>
        </member>
        <member name="M:System.SpanReader`1.UnsafeAdvance(System.Int32)">
            <summary>
             Advance the reader without bounds checking.
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:System.SpanReader`1.UncheckedSliceTo(System.ReadOnlySpan{`0}@,System.Int32)">
            <summary>
             Slicing without bounds checking.
            </summary>
        </member>
        <member name="M:System.SpanReader`1.UncheckedSlice(System.ReadOnlySpan{`0}@,System.Int32,System.Int32)">
            <summary>
             Slicing without bounds checking.
            </summary>
        </member>
        <member name="T:System.SpanWriter`1">
            <summary>
             Fast stack based <see cref="T:System.Span`1"/> writer.
            </summary>
        </member>
        <member name="M:System.SpanWriter`1.#ctor(System.Span{`0})">
            <summary>
             Fast stack based <see cref="T:System.Span`1"/> writer.
            </summary>
        </member>
        <member name="M:System.SpanWriter`1.TryWrite(`0)">
            <summary>
             Try to write the given value.
            </summary>
        </member>
        <member name="M:System.SpanWriter`1.TryWrite(System.ReadOnlySpan{`0})">
            <summary>
             Try to write the given value.
            </summary>
        </member>
        <member name="M:System.SpanWriter`1.TryWriteCount(System.Int32,`0)">
            <summary>
             Try to write the given value <paramref name="count"/> times.
            </summary>
        </member>
        <member name="M:System.SpanWriter`1.Advance(System.Int32)">
            <summary>
             Advance the writer by the given <paramref name="count"/>.
            </summary>
        </member>
        <member name="M:System.SpanWriter`1.Rewind(System.Int32)">
            <summary>
             Rewind the writer by the given <paramref name="count"/>.
            </summary>
        </member>
        <member name="M:System.SpanWriter`1.Reset">
            <summary>
             Reset the reader to the beginning of the span.
            </summary>
        </member>
        <member name="T:System.Text.ValueStringBuilder">
            <summary>
             String builder struct that allows using stack space for small strings.
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetPinnableReference">
            <summary>
             Get a pinnable reference to the builder. Does not ensure there is a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/>
            </summary>
            <remarks>
             <para>
              This overload is pattern matched in the C# 7.3+ compiler so you can omit
              the explicit method call, and write eg "fixed (char* c = builder)"
             </para>
            </remarks>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetPinnableReference(System.Boolean)">
            <summary>
             Get a pinnable reference to the builder.
            </summary>
            <param name="terminate">Ensures that the builder has a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/></param>
        </member>
        <member name="P:System.Text.ValueStringBuilder.RawChars">
            <summary>
             Returns the underlying storage of the builder.
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AsSpan(System.Boolean)">
            <summary>
             Returns a span around the contents of the builder.
            </summary>
            <param name="terminate">Ensures that the builder has a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/></param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendLiteral(System.String)">
            <summary>
             Append a string to the builder. If the string is <see langword="null"/>, this method does nothing.
            </summary>
            <devdoc>
             Name must be AppendLiteral to work with interpolated strings.
            </devdoc>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Grow(System.Int32)">
            <summary>
             Resize the internal buffer either by doubling current buffer size or
             by adding <paramref name="additionalCapacityBeyondPos"/> to
             <see cref="F:System.Text.ValueStringBuilder._pos"/> whichever is greater.
            </summary>
            <param name="additionalCapacityBeyondPos">
             Number of chars requested beyond current position.
            </param>
        </member>
        <member name="T:System.TypeExtensions">
            <summary>
             Helper methods for comparing <see cref="T:System.Type"/>s and <see cref="T:System.Reflection.Metadata.TypeName"/>s.
            </summary>
        </member>
        <member name="M:System.TypeExtensions.Matches(System.Type,System.Reflection.Metadata.TypeName,System.Reflection.Metadata.TypeNameComparison)">
            <summary>
             Match type <paramref name="type"/> against <paramref name="typeName"/>.
            </summary>
            <param name="type">The type to match.</param>
            <param name="typeName">The type name to match against.</param>
            <param name="comparison">Comparison options.</param>
        </member>
        <member name="M:System.TypeExtensions.Matches(System.Reflection.Metadata.TypeName,System.Reflection.Metadata.TypeName,System.Reflection.Metadata.TypeNameComparison)">
            <summary>
             Matches type name <paramref name="x"/> against <paramref name="y"/>.
            </summary>
            <inheritdoc cref="M:System.TypeExtensions.Matches(System.Type,System.Reflection.Metadata.TypeName,System.Reflection.Metadata.TypeNameComparison)"/>
        </member>
        <member name="M:System.TypeExtensions.AssemblyNamesMatch(System.Type,System.Reflection.Metadata.AssemblyNameInfo,System.Reflection.Metadata.TypeNameComparison)">
            <summary>
             Matches the given type's assembly name against the given <paramref name="assemblyNameInfo"/>.
            </summary>
            <param name="type">A type to match assembly info against.</param>
            <param name="assemblyNameInfo">Assembly name info to match against.</param>
            <param name="comparison">Comparison options.</param>
            <returns><see langword="true"/> if the assembly names meet the specified criteria.</returns>
        </member>
        <member name="M:System.TypeExtensions.AssemblyNamesMatch(System.Reflection.Metadata.AssemblyNameInfo,System.Reflection.Metadata.AssemblyNameInfo,System.Reflection.Metadata.TypeNameComparison)">
            <summary>
             Matches the given assembly names against each other.
            </summary>
            <param name="name1">The first assembly name to match.</param>
            <param name="name2">The second assembly name to match.</param>
            <inheritdoc cref="M:System.TypeExtensions.AssemblyNamesMatch(System.Type,System.Reflection.Metadata.AssemblyNameInfo,System.Reflection.Metadata.TypeNameComparison)"/>
        </member>
        <member name="M:System.TypeExtensions.ToTypeName(System.Type)">
            <summary>
             Convert <paramref name="type"/> to <see cref="T:System.Reflection.Metadata.TypeName"/>. Take into account type forwarding in order
             to create <see cref="T:System.Reflection.Metadata.TypeName"/> compatible with the type names serialized to the binary format.This
             method removes nullability wrapper from the top level type only because <see cref="T:System.Reflection.Metadata.TypeName"/> in the
             serialization root record is not nullable, but the generic types could be nullable.
            </summary>
        </member>
        <member name="M:System.TypeExtensions.UnwrapIfNullable(System.Type)">
            <summary>
             If <paramref name="type"/> is a nullable type, return the underlying type; otherwise, return <paramref name="type"/>.
            </summary>
        </member>
        <member name="M:System.TypeExtensions.ToTypeName(System.Text.ValueStringBuilder@)">
            <summary>
             Helper method that allows non-allocating conversion of a interpolated string to a <see cref="T:System.Reflection.Metadata.TypeName"/>.
            </summary>
        </member>
        <member name="M:System.TypeExtensions.ComparePublicKeys(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
             Compares two public keys by their token value. Handles comparing public key tokens to full public keys.
            </summary>
        </member>
        <member name="M:System.Types.ToTypeName(System.Text.ValueStringBuilder@)">
            <inheritdoc cref="M:System.Reflection.Metadata.TypeName.Parse(System.ReadOnlySpan{System.Char},System.Reflection.Metadata.TypeNameParseOptions)"/>
            <remarks>
             <para>
              This method allows efficient use of interpolated strings with
              <see cref="M:System.Reflection.Metadata.TypeName.Parse(System.ReadOnlySpan{System.Char},System.Reflection.Metadata.TypeNameParseOptions)"/>
             </para>
            </remarks>
        </member>
        <member name="T:System.Value">
            <summary>
             A struct that can hold any value type or reference type without boxing primitive types or enums. Behavior matches
             casting to/from <see langword="object"/>.
            </summary>
            <devdoc>
             Everything in this struct is designed to be as fast as possible. Changing logic should not be done without
             detailed performance measurements.
            </devdoc>
        </member>
        <member name="M:System.Value.#ctor(System.Object)">
            <summary>
             Creates a new <see cref="T:System.Value"/> with the given <see langword="object"/>. To avoid boxing enums, use the
             <see cref="M:System.Value.Create``1(``0)"/> method instead.
            </summary>
        </member>
        <member name="P:System.Value.Type">
            <summary>
             The <see cref="T:System.Type"/> of the value stored in this <see cref="T:System.Value"/>.
            </summary>
        </member>
        <member name="M:System.Value.Create``1(``0)">
            <summary>
             Creates a new <see cref="T:System.Value"/> with the given value. This method can always be used and avoids boxing enums.
            </summary>
        </member>
        <member name="M:System.Value.TryGetValue``1(``0@)">
            <summary>
             Tries to get the value stored in this <see cref="T:System.Value"/> as the given type. Returns <see langword="true"/> if
             the type matches.
            </summary>
            <remarks>
             <para>
              All types can be requested as <see langword="object"/>. Primitive types can be requested as their own type or
              as a nullable of that type. Enums can be requested as their own type or a nullable of that type.
             </para>
            </remarks>
        </member>
        <member name="M:System.Value.GetValue``1">
            <summary>
             Gets the value as the specified <typeparamref name="T"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">
             The value is not of type <typeparamref name="T"/>.
            </exception>
        </member>
        <member name="T:System.Value.PackedDateTimeOffset">
            <summary>
             Allows packing some <see cref="T:System.DateTimeOffset"/> values into a single <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="T:System.Value.StraightCastFlag`1">
            <summary>
             <see cref="T:System.Value.TypeFlag"/> that handles types that are a simple cast from a <see cref="T:System.Value.Union"/>
             to a <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:System.Value.TypeFlag">
            <summary>
             A flag that represents the <see cref="T:System.Type"/> of a <see cref="T:System.Value.Union"/> in a <see cref="T:System.Value"/>.
             Also provides the functionality to convert any <see cref="T:System.Value"/> to an <see langword="object"/> that
             already isn't an <see langword="object"/>.
            </summary>
        </member>
        <member name="M:System.Value.TypeFlag.ToObject(System.Value@)">
            <summary>
             Converts the given <see cref="T:System.Value"/> to an <see langword="object"/>.
            </summary>
        </member>
        <member name="T:System.Value.TypeFlag`1">
            <summary>
             Strongly typed <see cref="T:System.Value.TypeFlag"/>.
            </summary>
        </member>
        <member name="T:System.Value.Union">
            <summary>
             Data union for the <see cref="T:System.Value"/> type.
            </summary>
            <remarks>
             <para>
              Data can be any blittable type, but should be 8 bytes or less to avoid growing the size of the
              <see cref="T:System.Value"/> type.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Foundation.BSTR.ToStringAndFree">
            <summary>
             Converts the <see cref="T:Windows.Win32.Foundation.BSTR"/> to string and frees it.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.BSTR.ToNullableStringAndFree">
            <summary>
             Converts the <see cref="T:Windows.Win32.Foundation.BSTR"/> to a nullable string and frees it.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.BSTR.Length">
            <summary>
            Gets the length of the BSTR in characters.
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.COLORREF">
            <remarks>
             <para>
              Never convert native constants (such as <see cref="F:Windows.Win32.PInvokeCore.CLR_NONE"/> to <see cref="T:System.Drawing.Color"/> or pass them through
              any conversion in <see cref="T:System.Drawing.Color"/>, <see cref="T:System.Drawing.ColorTranslator"/>, etc. as they can change the value.
              <see cref="T:Windows.Win32.Foundation.COLORREF"/> is a DWORD- passing constants in native code would just pass the value as is.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/gdi/colorref#">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </remarks>
            <summary>The COLORREF value is used to specify an RGB color.</summary>
            <remarks>
            <para>When specifying an explicit [RGB](/windows/desktop/api/Wingdi/nf-wingdi-rgb) color, the **COLORREF** value has the following hexadecimal form: `0x00bbggrr` The low-order byte contains a value for the relative intensity of red; the second byte contains a value for green; and the third byte contains a value for blue. The high-order byte must be zero. The maximum value for a single byte is 0xFF. To create a **COLORREF** color value, use the [RGB](/windows/desktop/api/Wingdi/nf-wingdi-rgb) macro. To extract the individual values for the red, green, and blue components of a color value, use the [**GetRValue**](/windows/desktop/api/Wingdi/nf-wingdi-getrvalue), [GetGValue](/windows/desktop/api/Wingdi/nf-wingdi-getgvalue), and [GetBValue](/windows/desktop/api/Wingdi/nf-wingdi-getbvalue) macros, respectively.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/colorref#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Foundation.DECIMAL">
            <summary>The DECIMAL structure represents a decimal data type that provides a sign and scale for a number.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.DECIMAL.wReserved">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.DECIMAL.Hi32">
            <summary>The high 32 bits of the number.</summary>
        </member>
        <member name="T:Windows.Win32.Foundation.FILETIME">
            <summary>Describes FILETIME and provides syntax, members, and additional remarks.</summary>
            <remarks>
            <para>A property of type PT_SYSTIME has a **FILETIME** structure for its value. Such a property has a **FILETIME** data type for the **Value** member in its definition in an [SPropValue](spropvalue.md) structure. The definition of the **FILETIME** structure is in the _Win32 Programmer's Reference_ and in the MAPI header file Mapidefs.h. MAPI defines the structure conditionally to make sure that it is defined when the Win32 definition is unavailable.</para>
            <para><see href="https://learn.microsoft.com/office/client-developer/outlook/mapi/filetime#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.FILETIME.dwLowDateTime">
            <summary>> Low-order 32 bits of the file time value.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.FILETIME.dwHighDateTime">
            <summary>> High-order 32 bits of the file time value.</summary>
        </member>
        <member name="T:Windows.Win32.Foundation.HandleRef`1">
            <summary>
             Adapter to use when owning classes cannot directly implement <see cref="T:Windows.Win32.Foundation.IHandle`1"/>.
            </summary>
            <remarks>
             <para>
              Whenever you need to keep the owning object from being finalized during interop calls, use
              <see cref="M:System.GC.KeepAlive(System.Object)"/> on the <see cref="P:Windows.Win32.Foundation.HandleRef`1.Wrapper"/> <see langword="object"/>.
             </para>
             <para>
              This is the typed equivalent of <see cref="T:System.Runtime.InteropServices.HandleRef"/>. Marshalling doesn't know this, and while one
              could write a custom marshaler, we want our imports to do no marshalling for performance and trimming reasons.
             </para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Foundation.HRESULT">
            <remarks>
            <para>The **HRESULT** data type is the same as the [SCODE](scode.md) data type. An **HRESULT** value consists of the following fields: - A 1-bit code indicating severity, where zero represents success and 1 represents failure. - A 4-bit reserved value. - An 11-bit code indicating responsibility for the error or warning, also known as a facility code. - A 16-bit code describing the error or warning. Most MAPI interface methods and functions return **HRESULT** values to provide detailed cause formation. **HRESULT** values are also used widely in OLE interface methods. OLE provides several macros for converting between **HRESULT** values and **SCODE** values, another common data type for error handling. > [!NOTE] > In 64-bit MAPI, **HRESULT** is still a 32-bit value. For information about the OLE use of **HRESULT** values, see the  *OLE Programmer's Reference*. For more information about the use of these values in MAPI, see [Error Handling](error-handling-in-mapi.md) and any of the following interface methods: [IABLogon::GetLastError](iablogon-getlasterror.md) [IMAPISupport::GetLastError](imapisupport-getlasterror.md) [IMAPIControl::GetLastError](imapicontrol-getlasterror.md) [IMAPITable::GetLastError](imapitable-getlasterror.md) [IMAPIProp::GetLastError](imapiprop-getlasterror.md) [IMAPIViewAdviseSink::OnPrint](imapiviewadvisesink-onprint.md)</para>
            <para><see href="https://learn.microsoft.com/office/client-developer/outlook/mapi/hresult#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="P:Windows.Win32.Foundation.HRESULT.Facility">
            <summary>
             Extracts the facility code of the HRESULT. [HRESULT_FACILITY]
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.HRESULT.Code">
            <summary>
             Extracts the code portion of the HRESULT. [HRESULT_CODE]
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.HRESULT.IsNtStatus">
            <summary>
             <see langword="true"/> if the HRESULT represents an NTSTATUS code.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.HRESULT.ToNtStatus">
            <summary>
             Extracts the <see cref="T:Windows.Win32.Foundation.NTSTATUS"/> code. Check <see cref="P:Windows.Win32.Foundation.HRESULT.IsNtStatus"/> before calling this method.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.HRESULT.FromWin32(Windows.Win32.Foundation.WIN32_ERROR)">
            <summary>
             Converts a Win32 error code into an HRESULT. [HRESULT_FROM_WIN32]
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.HRESULT.DESTS_E_NO_MATCHING_ASSOC_HANDLER">
            <summary>
             There is no associated handler for the given item registered by the specified application.
             (Windows Jump List)
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.HRESULT.VB_E_NOTOBJECT">
            <summary>
             Object required.
            </summary>
            <remarks>
             <para>
              Visual Basic 6 and VBA raise this when objects have been collected or <see cref="T:Windows.Win32.System.Variant.VARIANT"/> values
              aren't actually <see cref="T:Windows.Win32.System.Com.IUnknown"/> or <see cref="T:Windows.Win32.System.Com.IDispatch"/> object pointers.
             </para>
             <para>
              Seen in various places as E_UNKNOWNWORDERROR, VBA_E_NOTOBJECT, or the VB native EBERR_NotObject.
              <see cref="F:Windows.Win32.System.Diagnostics.Debug.FACILITY_CODE.FACILITY_CONTROL"/> is used for all VB errors raised as <see cref="T:Windows.Win32.Foundation.HRESULT"/>s.
             </para>
             <para>
              <see href="https://learn.microsoft.com/office/vba/language/reference/user-interface-help/object-required-error-424">
               Object required (Error 424)
              </see>
             </para>
            </remarks>
            <devdoc>
             Closing Word when a search is running was a way this could be generated per legacy comments.
            </devdoc>
        </member>
        <member name="M:Windows.Win32.Foundation.HRESULT.ThrowOnFailure(System.IntPtr)">
            <inheritdoc cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" />
            <param name="errorInfo">
            A pointer to the IErrorInfo interface that provides more information about the
            error. You can specify <see cref="F:System.IntPtr.Zero"/> to use the current IErrorInfo interface, or
            <c>new IntPtr(-1)</c> to ignore the current IErrorInfo interface and construct the exception
            just from the error code.
            </param>
            <returns><see langword="this"/> <see cref="T:Windows.Win32.Foundation.HRESULT"/>, if it does not reflect an error.</returns>
            <seealso cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)"/>
        </member>
        <member name="F:Windows.Win32.Foundation.HRESULT.E_FAIL">
            <summary>The operation could not be completed.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-ondisablecomplete">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.HRESULT.E_INVALIDARG">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnconnectioncontextevents-onsetprovisionedcontextcomplete">IMbnConnectionContextEvents.OnSetProvisionedContextComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnserviceactivationevents-onactivationcomplete">IMbnServiceActivationEvents.OnActivationComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnsmsevents-onsmssendcomplete">IMbnSmsEvents.OnSmsSendComplete</see>.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.HRESULT.S_OK">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnconnectioncontextevents-onsetprovisionedcontextcomplete">IMbnConnectionContextEvents.OnSetProvisionedContextComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnconnectionevents-onconnectcomplete">IMbnConnectionEvents.OnConnectComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-onchangecomplete">IMbnPinEvents.OnChangeComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-ondisablecomplete">IMbnPinEvents.OnDisableComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-onenablecomplete">IMbnPinEvents.OnEnableComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-onentercomplete">IMbnPinEvents.OnEnterComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-onunblockcomplete">IMbnPinEvents.OnUnblockComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinmanagerevents-ongetpinstatecomplete">IMbnPinManagerEvents.OnGetPinStateComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnradioevents-onsetsoftwareradiostatecomplete">IMbnRadioEvents.OnSetSoftwareRadioStateComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnserviceactivationevents-onactivationcomplete">IMbnServiceActivationEvents.OnActivationComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnsmsevents-onsetsmsconfigurationcomplete">IMbnSmsEvents.OnSetSmsConfigurationComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnsmsevents-onsmsdeletecomplete">IMbnSmsEvents.OnSmsDeleteComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnsmsevents-onsmsreadcomplete">IMbnSmsEvents.OnSmsReadComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnsmsevents-onsmssendcomplete">IMbnSmsEvents.OnSmsSendComplete</see>.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.HWND.HWND_TOP">
            <summary>Places the window at the top of the Z order.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-deferwindowpos">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.HWND.HWND_BOTTOM">
            <summary>Places the window at the bottom of the Z order. If the <i>hWnd</i> parameter identifies a topmost window, the window loses its topmost status and is placed at the bottom of all other windows.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-deferwindowpos">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.HWND.HWND_TOPMOST">
            <summary>Places the window above all non-topmost windows. The window maintains its topmost position even when it is deactivated.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-deferwindowpos">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.HWND.HWND_NOTOPMOST">
            <summary>Places the window above all non-topmost windows (that is, behind all topmost windows). This flag has no effect if the window is already a non-topmost window.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-deferwindowpos">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Foundation.IHandle`1">
            <summary>
             Used to abstract access to classes that contain a potentially owned handle.
            </summary>
            <remarks>
             <para>
              The key benefit of this is that we can keep the owning class from being collected during interop calls.
              <see cref="T:System.Runtime.InteropServices.HandleRef"/> wraps arbitrary owners with target handles. Having this interface allows implicit use
              of the classes (such as System.Windows.Forms.Control) that meet this common pattern in interop and encourages
              correct alignment with the proper owner.
             </para>
             <para>
              Note that keeping objects alive is necessary ONLY when the object has a finalizer that will explicitly
              close the handle.
             </para>
             <para>
              When implementing P/Invoke wrappers that take this interface they should not directly take
              <see cref="T:Windows.Win32.Foundation.IHandle`1"/>, but should take a generic "T" that is constrained to IHandle{T}. Doing
              it this way prevents boxing of structs. The "T" parameters should also be marked as <see langword="in"/>
              to allow structs to be passed by reference instead of by value.
             </para>
             <para>
              When implementing this on a struct it is important that either the struct itself is marked as readonly
              or these properties are to avoid extra struct copies.
             </para>
            </remarks>
        </member>
        <member name="P:Windows.Win32.Foundation.IHandle`1.Wrapper">
            <summary>
             Owner of the <see cref="P:Windows.Win32.Foundation.IHandle`1.Handle"/> that might close it when finalized. Default is the
             <see cref="T:Windows.Win32.Foundation.IHandle`1"/> implementer.
            </summary>
            <remarks>
             <para>
              This allows decoupling the owner from the <typeparamref name="THandle"/> provider and avoids boxing when
              <see cref="T:Windows.Win32.Foundation.IHandle`1"/> is on a struct. See <see cref="T:Windows.Win32.Foundation.HandleRef`1"/> for a concrete usage.
             </para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Foundation.IPointer`1">
            <summary>
             Used to indicate ownership of a native resource pointer.
            </summary>
            <remarks>
             <para>
              This should never be put on a struct.
             </para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Foundation.PCWSTR">
            <summary>
            A pointer to a null-terminated, constant character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCWSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCWSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array, up to the first null character (exclusive).
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCWSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.POINTS">
            <summary>The POINTS structure defines the x- and y-coordinates of a point.</summary>
            <remarks>The POINTS structure is similar to the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-point">POINT</a> and <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-pointl">POINTL</a> structures. The difference is that the members of the POINTS structure are of type SHORT, while those of the other two structures are of type LONG.</remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.POINTS.x">
            <summary>Specifies the <i>x</i>-coordinate of the point.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.POINTS.y">
            <summary>Specifies the <i>y</i>-coordinate of the point.</summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PWSTR.StringListLength">
            <summary>
             The length of the string when it is a null separated list of values that is terminated by
             a double null. Does not include the final double null.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PWSTR.ToString">
            <inheritdoc cref="M:Windows.Win32.Foundation.PCWSTR.ToString"/>
        </member>
        <member name="P:Windows.Win32.Foundation.PWSTR.Length">
            <inheritdoc cref="P:Windows.Win32.Foundation.PCWSTR.Length"/>
        </member>
        <member name="M:Windows.Win32.Foundation.PWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.RECT">
            <summary>The RECT structure defines a rectangle by the coordinates of its upper-left and lower-right corners.</summary>
            <remarks>The RECT structure is identical to the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rectl">RECTL</a> structure.</remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.left">
            <summary>Specifies the <i>x</i>-coordinate of the upper-left corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.top">
            <summary>Specifies the <i>y</i>-coordinate of the upper-left corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.right">
            <summary>Specifies the <i>x</i>-coordinate of the lower-right corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.bottom">
            <summary>Specifies the <i>y</i>-coordinate of the lower-right corner of the rectangle.</summary>
        </member>
        <member name="T:Windows.Win32.Foundation.AgileComPointer`1">
            <summary>
             Finalizable wrapper for COM pointers that gives agile access to the specified interface.
            </summary>
            <remarks>
             <para>
              This class should be used to hold all COM pointers that are stored as fields to ensure that they are
              safely finalized when needed. Finalization should be avoided whenever possible for performance and timely
              resource release (that is, this class should be disposed).
             </para>
             <para>
              Fields should be nulled out before calling <see cref="M:Windows.Win32.Foundation.AgileComPointer`1.Dispose"/>. Releasing the COM pointer during disposal
              can result in callbacks to containing classes. Rather than evaluate the risk of this for every class, always
              follow this pattern. <see cref="M:System.DisposeHelper.NullAndDispose``1(``0@)"/> facilitates doing this safely.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Foundation.AgileComPointer`1.#ctor(`0*,System.Boolean,System.UInt32)">
            <summary>
             Creates an <see cref="T:Windows.Win32.Foundation.AgileComPointer`1"/> for the given <paramref name="interface"/>.
            </summary>
            <param name="interface">The COM interface pointer.</param>
            <param name="takeOwnership">
             Indicates whether to take ownership of the interface. If `<see langword="true"/>` this object will own the ref count.
            </param>
            <param name="memoryPressure">The amount of memory pressure to add.</param>
            <remarks>
             <para>
              <paramref name="memoryPressure"/> is used to help the GC know that this object is holding onto native memory.
              This is most useful for objects that can be created in large quantities, particularly if they are not disposable.
             </para>
             <para>
              Setting <paramref name="takeOwnership"/> to `<see langword="true"/>` will ensure that this object takes
              responsibility for releasing the COM interface when it is no longer needed. This is done by calling
              <see cref="M:Windows.Win32.System.Com.IUnknown.Release"/> after the GIT adds a ref to the interface.
             </para>
            </remarks>
            <devdoc>
             Other options were explored for ensuring that pending finalizers are not out of control besides
             <paramref name="memoryPressure"/>. Caching the interface pointers in a static collection was considered,
             but this had no impact on the HtmlElement scenario, which would create a new COM object for every element
             access. Tracking creation counts and forcing the Finalizer to run was also considered, but that takes too
             much responsibility away from the GC- better to let it make the decision based on our additional pressure.
            </devdoc>
        </member>
        <member name="M:Windows.Win32.Foundation.AgileComPointer`1.IsSameNativeObject(Windows.Win32.Foundation.AgileComPointer{`0})">
            <summary>
             Returns <see langword="true"/> if <paramref name="other"/> has the same pointer this
             <see cref="T:Windows.Win32.Foundation.AgileComPointer`1"/> was created from.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.AgileComPointer`1.IsSameNativeObject(`0*)">
            <inheritdoc cref="M:Windows.Win32.Foundation.AgileComPointer`1.IsSameNativeObject(Windows.Win32.Foundation.AgileComPointer{`0})"/>
        </member>
        <member name="M:Windows.Win32.Foundation.AgileComPointer`1.GetInterface">
            <summary>
             Gets the default interface. Throws if failed.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.AgileComPointer`1.GetInterface``1">
            <summary>
             Gets the specified interface. Throws if failed.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.AgileComPointer`1.TryGetInterface(Windows.Win32.Foundation.HRESULT@)">
            <summary>
             Tries to get the default interface.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.AgileComPointer`1.TryGetInterface``1(Windows.Win32.Foundation.HRESULT@)">
            <summary>
             Tries to get the specified interface.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.AgileComPointer`1.GetManagedObject">
            <summary>
             Gets the managed object using the pointer
             this <see cref="T:Windows.Win32.Foundation.AgileComPointer`1"/> was created from.
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.ComPointerList`1">
            <summary>
             Simple list for "typed" COM struct pointer storage. Prevents nulls.
            </summary>
            <remarks>
             <para>
              Doesn't implement generic interfaces as pointer types can't be used as generic arguments.
             </para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Foundation.ComScope`1">
            <summary>
             Lifetime management struct for a native COM pointer. Meant to be utilized in a <see langword="using"/> statement
             to ensure <see cref="M:Windows.Win32.System.Com.IUnknown.Release"/> is called when going out of scope with the using.
            </summary>
            <remarks>
             <para>
              This struct has implicit conversions to T** and void** so it can be passed directly to out methods.
              For example:
             </para>
             <code>
              using ComScope&lt;IUnknown&gt; unknown = new(null);
              comObject-&gt;QueryInterface(&amp;iid, unknown);
             </code>
             <para>
              Take care to NOT make copies of the struct to avoid accidental over-release.
             </para>
            </remarks>
            <typeparam name="T">
             This should be one of the struct COM definitions as generated by CsWin32. Ideally we'd constrain to
             <see cref="T:Windows.Win32.System.Com.IUnknown.Interface"/> or some other interface tag to enforce that this is being used around
             a struct that is actually a COM wrapper.
            </typeparam>
        </member>
        <member name="M:Windows.Win32.Foundation.ComScope`1.TryQuery``1(Windows.Win32.Foundation.HRESULT@)">
            <summary>
             Tries querying the requested interface into a new <see cref="T:Windows.Win32.Foundation.ComScope`1"/>.
            </summary>
            <param name="hr">The result of the query.</param>
        </member>
        <member name="M:Windows.Win32.Foundation.ComScope`1.Query``1">
            <summary>
             Queries the requested interface into a new <see cref="T:Windows.Win32.Foundation.ComScope`1"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.ComScope`1.TryQueryFrom``1(``0*,Windows.Win32.Foundation.HRESULT@)">
            <summary>
             Attempt to create a <see cref="T:Windows.Win32.Foundation.ComScope`1"/> from the given COM interface.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.ComScope`1.QueryFrom``1(``0*)">
            <summary>
             Create a <see cref="T:Windows.Win32.Foundation.ComScope`1"/> from the given COM interface. Throws on failure.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.ComScope`1.SupportsInterface``1">
            <summary>
             Simple helper for checking if a given interface is supported. Only use this if you don't intend to
             use the interface, otherwise use <see cref="M:Windows.Win32.Foundation.ComScope`1.TryQuery``1(Windows.Win32.Foundation.HRESULT@)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.GlobalInterfaceTable">
            <summary>
             Wrapper for the COM global interface table.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.GlobalInterfaceTable.RegisterInterface``1(``0*)">
            <summary>
             Registers the given <paramref name="interface"/> in the global interface table. This decrements the
             ref count so that the entry in the table will "own" the interface (as it increments the ref count).
            </summary>
            <returns>The cookie used to refer to the interface in the table.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.GlobalInterfaceTable.GetInterface``1(System.UInt32,Windows.Win32.Foundation.HRESULT@)">
            <summary>
             Gets an agile interface for the <paramref name="cookie"/> that was given back by
             <see cref="M:Windows.Win32.Foundation.GlobalInterfaceTable.RegisterInterface``1(``0*)"/>
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.GlobalInterfaceTable.RevokeInterface(System.UInt32)">
            <summary>
             Revokes the interface registered with <see cref="M:Windows.Win32.Foundation.GlobalInterfaceTable.RegisterInterface``1(``0*)"/>.
             This will decrement the ref count for the interface.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.GlobalInterfaceTable.CreateUnknownStrategy">
            <summary>
             Creates a new instance of an <see cref="T:System.Runtime.InteropServices.Marshalling.IIUnknownStrategy"/> for <see cref="T:System.Runtime.InteropServices.Marshalling.StrategyBasedComWrappers"/>
             that uses the Global Interface Table.
            </summary>
            <remarks>
             <para>
              The returned instance should not be cached.
             </para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Foundation.GlobalInterfaceTable.UnknownStrategy">
            <summary>
             Strategy for <see cref="T:System.Runtime.InteropServices.Marshalling.StrategyBasedComWrappers"/> that uses the <see cref="T:Windows.Win32.Foundation.GlobalInterfaceTable"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.IID.Get``1">
            <summary>
             Gets a pointer to the IID <see cref="T:System.Guid"/> for the given <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.IID.GetRef``1">
            <summary>
             Gets a reference to the IID <see cref="T:System.Guid"/> for the given <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.IID.NULL">
            <summary>
             Empty <see cref="T:System.Guid"/> (GUID_NULL in docs).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.PCSTR">
            <summary>
            A pointer to a null-terminated, constant, ANSI character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array, decoding as UTF-8.
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.POINTL">
            <summary>The POINTL structure defines the x- and y-coordinates of a point.</summary>
            <remarks>The POINTL structure is identical to the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-point">POINT</a> structure.</remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.POINTL.x">
            <summary>Specifies the <i>x</i>-coordinate of the point.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.POINTL.y">
            <summary>Specifies the <i>y</i>-coordinate of the point.</summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PSTR.ToString">
            <inheritdoc cref="M:Windows.Win32.Foundation.PCSTR.ToString"/>
        </member>
        <member name="P:Windows.Win32.Foundation.PSTR.Length">
            <inheritdoc cref="P:Windows.Win32.Foundation.PCSTR.Length"/>
        </member>
        <member name="M:Windows.Win32.Foundation.PSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.SIZE">
            <summary>The SIZE structure defines the width and height of a rectangle.</summary>
            <remarks>The rectangle dimensions stored in this structure can correspond to viewport extents, window extents, text extents, bitmap dimensions, or the aspect-ratio filter for some extended functions.</remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.SIZE.cx">
            <summary>Specifies the rectangle's width. The units depend on which function uses this structure.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.SIZE.cy">
            <summary>Specifies the rectangle's height. The units depend on which function uses this structure.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.GdiPlus.GdiPlusInitialization">
            <summary>
             Helper to ensure GDI+ is initialized before making calls.
            </summary>
        </member>
        <member name="M:Windows.Win32.Graphics.GdiPlus.GdiPlusInitialization.EnsureInitialized">
            <summary>
             Attempts to ensure that GGI+ is initialized. Returns <see langword="true"/> if GDI+ has been started.
            </summary>
            <remarks>
             <para>
              This should be called anywhere you make <see cref="T:Windows.Win32.PInvokeCore"/> calls to GDI+ where you don't
              already have a GDI+ handle. In System.Drawing.Common, this is done in the PInvoke static constructor
              so it is not necessary for methods defined there.
             </para>
             <para>
              https://github.com/microsoft/CsWin32/issues/1308 tracks a proposal to make this more automatic.
             </para>
            </remarks>
        </member>
        <member name="P:Windows.Win32.Graphics.GdiPlus.GdiPlusInitialization.IsInitialized">
            <summary>
             Returns <see langword="true"/> if GDI+ has been started.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.GdiPlus.Status">
            <summary>This section lists the styles, in addition to standard window styles, supported by status bar controls.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/status-bar-styles">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.ArgbBuffer">
            <summary>
             Buffer for <see cref="T:Windows.Win32.Graphics.Gdi.ARGB"/> values. Uses the stack for buffer sizes up to 16. Use in a <see langword="using"/>
             statement.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.BeginPaintScope">
            <summary>
             Helper to scope lifetime of an HDC retrieved via <see cref="M:Windows.Win32.PInvokeCore.BeginPaint(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.PAINTSTRUCT@)"/>
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass
              by <see langword="ref" /> to avoid duplicating the handle and risking a double EndPaint.
             </para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.CreateBitmapScope">
            <summary>
             Helper to scope lifetime of a <see cref="T:Windows.Win32.Graphics.Gdi.HBITMAP"/> created via <see cref="M:Windows.Win32.PInvokeCore.CreateBitmap(System.Int32,System.Int32,System.UInt32,System.UInt32,System.Void*)"/>
             Deletes the <see cref="T:Windows.Win32.Graphics.Gdi.HBITMAP"/> (if any) when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass
              by <see langword="ref" /> to avoid duplicating the handle and risking a double delete.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.CreateBitmapScope.#ctor(System.Int32,System.Int32,System.UInt32,System.UInt32,System.Void*)">
            <summary>
             Creates a bitmap using <see cref="M:Windows.Win32.PInvokeCore.CreateBitmap(System.Int32,System.Int32,System.UInt32,System.UInt32,System.Void*)"/>
            </summary>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.CreateBitmapScope.#ctor(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32)">
            <summary>
             Creates a bitmap compatible with the given <see cref="T:Windows.Win32.Graphics.Gdi.HDC"/> via
             <see cref="M:Windows.Win32.PInvokeCore.CreateCompatibleBitmap(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.CreateBrushScope">
            <summary>
             Helper to scope the lifetime of a <see cref="P:Windows.Win32.Graphics.Gdi.CreateBrushScope.HBRUSH"/>.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass
              by <see langword="ref" /> to avoid duplicating the handle and risking a double delete.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.CreateBrushScope.#ctor(System.Drawing.Color)">
            <summary>
             Creates a solid brush based on the <paramref name="color"/> using <see cref="M:Windows.Win32.PInvokeCore.CreateSolidBrush(Windows.Win32.Foundation.COLORREF)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.CreateDcScope">
            <summary>
             Helper to scope lifetime of an HDC retrieved via CreateDC/CreateCompatibleDC.
             Deletes the HDC (if any) when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass
              by <see langword="ref" /> to avoid duplicating the handle and risking a double delete.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.CreateDcScope.#ctor(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>
             Creates a compatible HDC for <paramref name="hdc"/> using <see cref="M:Windows.Win32.PInvokeCore.CreateCompatibleDC(Windows.Win32.Graphics.Gdi.HDC)"/>.
            </summary>
            <remarks>
             <para>
              Passing a <see langword="null"/> HDC will use the current screen.
             </para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.CreatePenScope">
            <summary>
             Helper to scope the lifetime of a <see cref="T:Windows.Win32.Graphics.Gdi.HPEN"/>.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass
              by <see langword="ref" /> to avoid duplicating the handle and risking a double delete.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.CreatePenScope.#ctor(System.Drawing.Color,System.Int32)">
            <summary>
             Creates a solid pen based on the <paramref name="color"/> and <paramref name="width"/> using
             <see cref="M:Windows.Win32.PInvokeCore.CreatePen(Windows.Win32.Graphics.Gdi.PEN_STYLE,System.Int32,Windows.Win32.Foundation.COLORREF)" />.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.DEVMODEW">
            <summary>The DEVMODEW structure is used for specifying characteristics of display and print devices in the Unicode (wide) character set.</summary>
            <remarks>
            <para>The <a href="https://docs.microsoft.com/windows-hardware/drivers/display/the-devmodew-structure">DEVMODEW structure</a> is the Unicode version of the <a href="https://docs.microsoft.com/previous-versions//ms535771(v=vs.85)">DEVMODE </a> structure (described in the Microsoft Windows SDK documentation). While applications can use either the ANSI or Unicode version of the structure, drivers are required to use the Unicode version. For printer drivers, the DEVMODEW structure is used for specifying printer characteristics required by a print document. It is also used for specifying a printer's default characteristics. Immediately following a DEVMODEW structure's defined members (often referred to as its public members), there can be a set of driver-defined members (often referred to as private DEVMODEW members). The driver supplies the size, in bytes, of this private area in <b>dmDriverExtra</b>. Driver-defined private members are for exclusive use by the driver. The starting address for the private members can be referenced using the <b>dmSize</b> member as follows:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmDeviceName">
            <summary>
            <para>For a display, specifies the name of the display driver's DLL; for example, "perm3dd" for the 3Dlabs Permedia3 display driver. For a printer, specifies the "friendly name"; for example, "PCL/HP LaserJet" in the case of PCL/HP LaserJet. If the name is greater than CCHDEVICENAME characters in length, the spooler truncates it to fit in the array.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmSpecVersion">
            <summary>Specifies the version number of this DEVMODEW structure. The current version number is identified by the DM_SPECVERSION constant in <i>wingdi.h</i>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmDriverVersion">
            <summary>
            <para>For a printer, specifies the printer driver version number assigned by the printer driver developer. Display drivers can set this member to DM_SPECVERSION.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmSize">
            <summary>Specifies the size in bytes of the public DEVMODEW structure, not including any private, driver-specified members identified by the <b>dmDriverExtra</b> member.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmDriverExtra">
            <summary>Specifies the number of bytes of private driver data that follow the public structure members. If a device driver does not provide private DEVMODEW members, this member should be set to zero.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmFields">
            <summary>Specifies bit flags identifying which of the following DEVMODEW members are in use. For example, the DM_ORIENTATION flag is set when the <b>dmOrientation</b> member contains valid data. The DM_XXX flags are defined in <i>wingdi.h</i>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmColor">
            <summary>
            <para>For printers, specifies whether a color printer should print color or monochrome. This member can be one of DMCOLOR_COLOR or DMCOLOR_MONOCHROME. This member is not used for displays.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmDuplex">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmYResolution">
            <summary>
            <para>For printers, specifies the <i>y</i> resolution of the printer, in DPI. If this member is used, the <b>dmPrintQuality</b> member specifies the <i>x</i> resolution. This member is not used for displays.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmTTOption">
            <summary>
            <para>For printers, specifies how TrueType fonts should be printed. This member must be one of the DMTT-prefixed constants defined in <i>wingdi.h</i>. This member is not used for displays.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmCollate">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmFormName">
            <summary>
            <para>For printers, specifies the name of the form to use; such as "Letter" or "Legal". This must be a name that can be obtain by calling the Win32 <b>EnumForms</b> function (described in the Microsoft Window SDK documentation). This member is not used for displays.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmLogPixels">
            <summary>
            <para>For displays, specifies the number of logical pixels per inch of a display device and should be equal to the <b>ulLogPixels</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winddi/ns-winddi-gdiinfo">GDIINFO</a> structure. This member is not used for printers.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmBitsPerPel">
            <summary>
            <para>For displays, specifies the color resolution, in bits per pixel, of a display device. This member is not used for printers.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmPelsWidth">
            <summary>
            <para>For displays, specifies the width, in pixels, of the visible device surface. This member is not used for printers.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmPelsHeight">
            <summary>
            <para>For displays, specifies the height, in pixels, of the visible device surface. This member is not used for printers.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmDisplayFrequency">
            <summary>
            <para>For displays, specifies the frequency, in hertz, of a display device in its current mode. This member is not used for printers.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmICMMethod">
            <summary>Specifies one of the DMICMMETHOD-prefixed constants defined in <i>wingdi.h</i>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmICMIntent">
            <summary>Specifies one of the DMICM-prefixed constants defined in <i>wingdi.h</i>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmMediaType">
            <summary>Specifies one of the DMMEDIA-prefixed constants defined in <i>wingdi.h</i>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmDitherType">
            <summary>Specifies one of the DMDITHER-prefixed constants defined in <i>wingdi.h</i>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmReserved1">
            <summary>Is reserved for system use and should be ignored by the driver.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmReserved2">
            <summary>Is reserved for system use and should be ignored by the driver.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmPanningWidth">
            <summary>Is reserved for system use and should be ignored by the driver.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.DEVMODEW.dmPanningHeight">
            <summary>Is reserved for system use and should be ignored by the driver.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.GetDcScope">
            <summary>
             Helper to scope lifetime of an <see cref="T:Windows.Win32.Graphics.Gdi.HDC"/> retrieved via <see cref="M:Windows.Win32.PInvokeCore.GetDC(Windows.Win32.Foundation.HWND)"/> and
             <see cref="M:Windows.Win32.PInvokeCore.GetDCEx(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.HRGN,Windows.Win32.Graphics.Gdi.GET_DCX_FLAGS)"/>. Releases the <see cref="T:Windows.Win32.Graphics.Gdi.HDC"/> (if any)
             when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass by <see langword="ref" />
              to avoid duplicating the handle and risking a double release.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.GetDcScope.#ctor(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.HRGN,Windows.Win32.Graphics.Gdi.GET_DCX_FLAGS)">
            <summary>
             Creates a <see cref="T:Windows.Win32.Graphics.Gdi.HDC"/> using <see cref="M:Windows.Win32.PInvokeCore.GetDCEx(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.HRGN,Windows.Win32.Graphics.Gdi.GET_DCX_FLAGS)"/>.
            </summary>
            <remarks>
             <para>
              GetWindowDC calls GetDCEx(hwnd, null, DCX_WINDOW | DCX_USESTYLE).
             </para>
             <para>
              GetDC calls GetDCEx(hwnd, null, DCX_USESTYLE) when given a handle. (When given null it has additional
              logic, and can't be replaced directly by GetDCEx.
             </para>
            </remarks>
        </member>
        <member name="P:Windows.Win32.Graphics.Gdi.GetDcScope.ScreenDC">
            <summary>
             Creates a DC scope for the primary monitor (not the entire desktop).
            </summary>
            <remarks>
             <para>
              <see cref="M:Windows.Win32.PInvokeCore.CreateDCW(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Graphics.Gdi.DEVMODEW*)" /> is the
              API to get the DC for the entire desktop.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.HBITMAP.CreateCompatibleBitmap(System.Int32,System.Int32)">
            <summary>
             Creates a compatible bitmap copying the content of the current bitmap.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.HdcHandle">
            <summary>
             Used when you must keep a handle to an <see cref="T:Windows.Win32.Graphics.Gdi.HDC"/> in a field. Avoid keeping HDC handles in fields
             when possible.
            </summary>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.HdcHandle.#ctor(Windows.Win32.Graphics.Gdi.CreateDcScope)">
            <summary>
             Take ownership from a <see cref="T:Windows.Win32.Graphics.Gdi.CreateDcScope"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.LOGFONTW">
            <summary>Defines the attributes of a font. (LOGFONTW)</summary>
            <remarks>
            <para>The following situations do not support ClearType antialiasing: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfHeight">
            <summary>
            <para>Type: <b>LONG</b> Specifies the height, in logical units, of the font's character cell or character. The character height value (also known as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets the value specified in <b>lfHeight</b> in the following manner. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfWidth">
            <summary>
            <para>Type: <b>LONG</b> Specifies the average width, in logical units, of characters in the font. If <b>lfWidth</b> is not zero, the aspect ratio of the device is matched against the digitization aspect ratio of the available fonts to find the closest match, determined by the absolute value of the difference.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfEscapement">
            <summary>
            <para>Type: <b>LONG</b> Specifies the angle, in tenths of degrees, between the escapement vector and the x-axis of the device. The escapement vector is parallel to the base line of a row of text. The <b>lfEscapement</b> member specifies both the escapement and orientation. You should set <b>lfEscapement</b> and <b>lfOrientation</b> to the same value.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfOrientation">
            <summary>
            <para>Type: <b>LONG</b> Specifies the angle, in tenths of degrees, between each character's base line and the x-axis of the device.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfWeight">
            <summary>
            <para>Type: <b>LONG</b> Specifies the weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is zero, a default weight is used. The following values are defined in Wingdi.h for convenience. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfItalic">
            <summary>
            <para>Type: <b>BYTE</b> <b>TRUE</b> to specify an italic font.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfUnderline">
            <summary>
            <para>Type: <b>BYTE</b> <b>TRUE</b> to specify an underlined font.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfStrikeOut">
            <summary>
            <para>Type: <b>BYTE</b> <b>TRUE</b> to specify a strikeout font.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfCharSet">
            <summary>
            <para>Type: <b>BYTE</b> Specifies the character set. The following values are predefined: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfOutPrecision">
            <summary>Type: <b>BYTE</b></summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfClipPrecision">
            <summary>Type: <b>BYTE</b></summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfQuality">
            <summary>Type: <b>BYTE</b></summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfPitchAndFamily">
            <summary>Type: <b>BYTE</b></summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.LOGFONTW.lfFaceName">
            <summary>
            <para>Type: <b>TCHAR[LF_FACESIZE]</b> Specifies a null-terminated string that specifies the typeface name of the font. The length of this string must not exceed 32 characters, including the terminating null character. The <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesa">EnumFontFamilies</a> function can be used to enumerate the typeface names of all currently available fonts. If <b>lfFaceName</b> is an empty string, GDI uses the first font that matches the other specified attributes.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-logfontw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.RegionScope">
            <summary>
             Helper to scope creating regions. Deletes the region when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass
              by <see langword="ref" /> to avoid duplicating the handle and risking a double deletion.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.RegionScope.#ctor(System.Drawing.Rectangle)">
            <summary>
             Creates a region with the given rectangle via <see cref="M:Windows.Win32.PInvokeCore.CreateRectRgn(System.Int32,System.Int32,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.RegionScope.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
             Creates a region with the given rectangle via <see cref="M:Windows.Win32.PInvokeCore.CreateRectRgn(System.Int32,System.Int32,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.RegionScope.#ctor(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>
             Creates a clipping region copy via <see cref="M:Windows.Win32.PInvokeCore.GetClipRgn(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HRGN)"/> for the given device context.
            </summary>
            <param name="hdc">Handle to a device context to copy the clipping region from.</param>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.RegionScope.#ctor(Windows.Win32.Graphics.Gdi.HRGN)">
            <summary>
             Creates a region scope with the given <see cref="T:Windows.Win32.Graphics.Gdi.HRGN"/>.
            </summary>
        </member>
        <member name="P:Windows.Win32.Graphics.Gdi.RegionScope.IsNull">
            <summary>
             Returns true if this represents a null HRGN.
            </summary>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.RegionScope.RelinquishOwnership">
            <summary>
             Clears the handle. Use this to hand over ownership to another entity.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.RGNDATAHEADER">
            <summary>The RGNDATAHEADER structure describes the data returned by the GetRegionData function.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-rgndataheader">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGNDATAHEADER.dwSize">
            <summary>The size, in bytes, of the header.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGNDATAHEADER.iType">
            <summary>The type of region. This value must be RDH_RECTANGLES.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGNDATAHEADER.nCount">
            <summary>The number of rectangles that make up the region.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGNDATAHEADER.nRgnSize">
            <summary>The size of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-rgndata">RGNDATA</a> buffer required to receive the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structures that make up the region. If the size is not known, this member can be zero.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGNDATAHEADER.rcBound">
            <summary>A bounding rectangle for the region in logical units.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.SaveDcScope">
            <summary>
             Helper to scope lifetime of a saved device context state.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass by <see langword="ref" />
              to avoid duplicating the handle and risking a double restore.
             </para>
             <para>
              The state that is saved includes ICM (color management), palette, path drawing state, and other objects
              that are selected into the DC (bitmap, brush, pen, clipping region, font).
             </para>
             <para>
              Ideally saving the entire DC state can be avoided for simple drawing operations and relying on restoring
              individual state pieces can be done instead (putting back the original pen, etc.).
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.SaveDcScope.#ctor(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>
             Saves the device context state using <see cref="M:Windows.Win32.PInvokeCore.SaveDC(Windows.Win32.Graphics.Gdi.HDC)"/>.
            </summary>
            <param name="hdc"></param>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.SelectObjectScope">
            <summary>
             Helper to scope selecting a GDI object into an <see cref="T:Windows.Win32.Graphics.Gdi.HDC"/>. Restores the original
             object into the <see cref="T:Windows.Win32.Graphics.Gdi.HDC"/> when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass
              by <see langword="ref" /> to avoid duplicating the handle and risking a double selection.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.SelectObjectScope.#ctor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HGDIOBJ)">
            <summary>
             Selects <paramref name="object"/> into the given <paramref name="hdc"/> using
             <see cref="M:Windows.Win32.PInvokeCore.SelectObject(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HGDIOBJ)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.SelectPaletteScope">
            <summary>
             Helper to scope palette selection.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass
              by <see langword="ref" /> to avoid duplicating the handle and risking a double palette reset.
             </para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.SetBackgroundColorScope">
            <summary>
             Helper to scope selecting a given background color into a HDC. Restores the original background color into
             the HDC when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass by
              <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.SetBackgroundColorScope.#ctor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.COLORREF)">
            <summary>
             Sets text color <paramref name="color"/> in the given <paramref name="hdc"/> using
             <see cref="M:Windows.Win32.PInvokeCore.SetBkColor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.COLORREF)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.SetBkModeScope">
            <summary>
             Helper to scope selecting a given background mix mode into a HDC. Restores the original
             mix mode into the HDC when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass by
              <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.SetBkModeScope.#ctor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.BACKGROUND_MODE)">
            <summary>
             Selects <paramref name="bkmode"/> into the given <paramref name="hdc"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.SetMapModeScope">
            <summary>
             Helper to scope selecting a given mapping mode into a HDC. Restores the original mapping mode into the HDC
             when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass by
              <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.SetMapModeScope.#ctor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HDC_MAP_MODE)">
            <summary>
             Sets the <paramref name="mapMode"/> in the given <paramref name="hdc"/> using
             <see cref="M:Windows.Win32.PInvokeCore.SetMapMode(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HDC_MAP_MODE)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.SetRop2Scope">
            <summary>
             Helper to scope selecting a given foreground mix mode into a HDC. Restores the original mix mode into the
             HDC when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass by
              <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.SetRop2Scope.#ctor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.R2_MODE)">
            <summary>
             Selects <paramref name="rop2"/> into the given <paramref name="hdc"/> using <see cref="M:Windows.Win32.PInvokeCore.SetROP2(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.R2_MODE)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.SetTextAlignmentScope">
            <summary>
             Helper to scope selecting a given text alignment mode into a HDC. Restores the original text alignment
             mode into the HDC when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass by
              <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.SetTextAlignmentScope.#ctor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.TEXT_ALIGN_OPTIONS)">
            <summary>
             Sets <paramref name="ta"/> in the given <paramref name="hdc"/>
             using <see cref="M:Windows.Win32.PInvokeCore.SetTextAlign(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.TEXT_ALIGN_OPTIONS)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.SetTextColorScope">
            <summary>
             Helper to scope selecting a given foreground text color into a HDC. Restores the original text color into
             into the HDC when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass by
              <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.SetTextColorScope.#ctor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.COLORREF)">
            <summary>
             Sets text color <paramref name="color"/> in the given <paramref name="hdc"/> using
             <see cref="M:Windows.Win32.PInvokeCore.SetTextColor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.COLORREF)"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Windows.Win32.Graphics.Gdi.BITMAPINFO" -->
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFO.bmiHeader">
            <summary>
            <para>A <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader">BITMAPINFOHEADER</a> structure that contains information about the dimensions of color format. .</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-bitmapinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFO.bmiColors">
            <summary>
            <para>The <b>bmiColors</b> member contains one of the following: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-bitmapinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.BITMAPINFO.SizeOf(System.Int32)">
            <summary>Computes the amount of memory that must be allocated to store this struct, including the specified number of elements in the variable length inline array at the end.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER">
            <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a device-independent bitmap (DIB).</summary>
            <remarks>
            <para><h3><a id="Color_Tables"></a><a id="color_tables"></a><a id="COLOR_TABLES"></a>Color Tables</h3> The <b>BITMAPINFOHEADER</b> structure may be followed by an array of palette entries or color masks. The rules depend on the value of <b>biCompression</b>. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biSize">
            <summary>Specifies the number of bytes required by the structure. This value does not include the size of the color table or the size of the color masks, if they are appended to the end of structure. See Remarks.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biWidth">
            <summary>Specifies the width of the bitmap, in pixels. For information about calculating the stride of the bitmap, see Remarks.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biHeight">
            <summary>
            <para>Specifies the height of the bitmap, in pixels. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biPlanes">
            <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biBitCount">
            <summary>Specifies the number of bits per pixel (bpp). For uncompressed formats, this value is the average number of bits per pixel. For compressed formats, this value is the implied bit depth of the uncompressed image, after the image has been decoded.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biCompression">
            <summary>
            <para>For compressed video and YUV formats, this member is a FOURCC code, specified as a <b>DWORD</b> in little-endian order. For example, YUYV video has the FOURCC 'VYUY' or 0x56595559. For more information, see <a href="https://docs.microsoft.com/windows/desktop/DirectShow/fourcc-codes">FOURCC Codes</a>. For uncompressed RGB formats, the following values are possible: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biSizeImage">
            <summary>Specifies the size, in bytes, of the image. This can be set to 0 for uncompressed RGB bitmaps.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biXPelsPerMeter">
            <summary>Specifies the horizontal resolution, in pixels per meter, of the target device for the bitmap.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biYPelsPerMeter">
            <summary>Specifies the vertical resolution, in pixels per meter, of the target device for the bitmap.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biClrUsed">
            <summary>Specifies the number of color indices in the color table that are actually used by the bitmap. See Remarks for more information.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.BITMAPINFOHEADER.biClrImportant">
            <summary>Specifies the number of color indices that are considered important for displaying the bitmap. If this value is zero, all colors are important.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.ENHMETARECORD">
            <summary>The ENHMETARECORD structure contains data that describes a graphics device interface (GDI) function used to create part of a picture in an enhanced-format metafile.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-enhmetarecord">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.ENHMETARECORD.iType">
            <summary>The record type.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.ENHMETARECORD.nSize">
            <summary>The size of the record, in bytes.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.ENHMETARECORD.dParm">
            <summary>An array of parameters passed to the GDI function identified by the record.</summary>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.ENHMETARECORD.SizeOf(System.Int32)">
            <summary>Computes the amount of memory that must be allocated to store this struct, including the specified number of elements in the variable length inline array at the end.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.HANDLETABLE">
            <summary>The HANDLETABLE structure is an array of handles, each of which identifies a graphics device interface (GDI) object.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-handletable">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.HANDLETABLE.objectHandle">
            <summary>An array of handles.</summary>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.HANDLETABLE.SizeOf(System.Int32)">
            <summary>Computes the amount of memory that must be allocated to store this struct, including the specified number of elements in the variable length inline array at the end.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.MONITORINFO">
            <summary>The MONITORINFO structure contains information about a display monitor.The GetMonitorInfo function stores information in a MONITORINFO structure or a MONITORINFOEX structure.The MONITORINFO structure is a subset of the MONITORINFOEX structure.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-monitorinfo">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.MONITORINFO.cbSize">
            <summary>
            <para>The size of the structure, in bytes. Set this member to <c>sizeof ( MONITORINFO )</c> before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmonitorinfoa">GetMonitorInfo</a> function. Doing so lets the function determine the type of structure you are passing to it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-monitorinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.MONITORINFO.rcMonitor">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the display monitor rectangle, expressed in virtual-screen coordinates. Note that if the monitor is not the primary display monitor, some of the rectangle's coordinates may be negative values.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.MONITORINFO.rcWork">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the work area rectangle of the display monitor, expressed in virtual-screen coordinates. Note that if the monitor is not the primary display monitor, some of the rectangle's coordinates may be negative values.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.MONITORINFO.dwFlags">
            <summary>
            <para>A set of flags that represent attributes of the display monitor. The following flag is defined. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-monitorinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.MONITORINFOEXW">
            <summary>The MONITORINFOEX structure contains information about a display monitor.The GetMonitorInfo function stores information into a MONITORINFOEX structure or a MONITORINFO structure.The MONITORINFOEX structure is a superset of the MONITORINFO structure. (Unicode)</summary>
            <remarks>
            <para>> [!NOTE] > The winuser.h header defines MONITORINFOEX as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-monitorinfoexw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.MONITORINFOEXW.szDevice">
            <summary>A string that specifies the device name of the monitor being used.  Most applications have no use for a display monitor name, and so can save some bytes by using a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfo">MONITORINFO</a> structure.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.PAINTSTRUCT">
            <summary>The PAINTSTRUCT structure contains information for an application. This information can be used to paint the client area of a window owned by that application.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-paintstruct">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.PAINTSTRUCT.hdc">
            <summary>A handle to the display DC to be used for painting.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.PAINTSTRUCT.fErase">
            <summary>Indicates whether the background must be erased. This value is nonzero if the application should erase the background. The application is responsible for erasing the background if a window class is created without a background brush. For more information, see the description of the <b>hbrBackground</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.PAINTSTRUCT.rcPaint">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the upper left and lower right corners of the rectangle in which the painting is requested, in device units relative to the upper-left corner of the client area.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.PAINTSTRUCT.fRestore">
            <summary>Reserved; used internally by the system.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.PAINTSTRUCT.fIncUpdate">
            <summary>Reserved; used internally by the system.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.PAINTSTRUCT.rgbReserved">
            <summary>Reserved; used internally by the system.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.PALETTEENTRY">
            <summary>Specifies the color and usage of an entry in a logical palette.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-paletteentry">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.PALETTEENTRY.peRed">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BYTE</a></b> The red intensity value for the palette entry.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-paletteentry#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.PALETTEENTRY.peGreen">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BYTE</a></b> The green intensity value for the palette entry.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-paletteentry#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.PALETTEENTRY.peBlue">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BYTE</a></b> The blue intensity value for the palette entry.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-paletteentry#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.PALETTEENTRY.peFlags">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BYTE</a></b> The alpha intensity value for the palette entry. Note that as of DirectX 8, this member is treated differently than documented for Windows.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-paletteentry#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.RGBQUAD">
            <summary>The RGBQUAD structure describes a color consisting of relative intensities of red, green, and blue.</summary>
            <remarks>The <b>bmiColors</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-bitmapinfo">BITMAPINFO</a> structure consists of an array of <b>RGBQUAD</b> structures.</remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGBQUAD.rgbBlue">
            <summary>The intensity of blue in the color.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGBQUAD.rgbGreen">
            <summary>The intensity of green in the color.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGBQUAD.rgbRed">
            <summary>The intensity of red in the color.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGBQUAD.rgbReserved">
            <summary>This member is reserved and must be zero.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.RGNDATA">
            <summary>The RGNDATA structure contains a header and an array of rectangles that compose a region. The rectangles are sorted top to bottom, left to right. They do not overlap.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-rgndata">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGNDATA.rdh">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-rgndataheader">RGNDATAHEADER</a> structure. The members of this structure specify the type of region (whether it is rectangular or trapezoidal), the number of rectangles that make up the region, the size of the buffer that contains the rectangle structures, and so on.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.RGNDATA.Buffer">
            <summary>Specifies an arbitrary-size buffer that contains the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structures that make up the region.</summary>
        </member>
        <member name="M:Windows.Win32.Graphics.Gdi.RGNDATA.SizeOf(System.Int32)">
            <summary>Computes the amount of memory that must be allocated to store this struct, including the specified number of elements in the variable length inline array at the end.</summary>
        </member>
        <member name="T:Windows.Win32.ObjectScope">
            <summary>
             Helper to scope lifetime of a GDI object. Deletes the given object (if any) when disposed.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass
              by <see langword="ref" /> to avoid duplicating the handle and risking a double deletion.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.ObjectScope.#ctor(Windows.Win32.Graphics.Gdi.HGDIOBJ)">
            <param name="object">The object to be deleted when the scope closes.</param>
        </member>
        <member name="T:Windows.Win32.MessageId">
            <summary>
             Simple internal wrapper that enables showing the message identifier string in the debugger.
            </summary>
        </member>
        <member name="M:Windows.Win32.MessageId.MessageIdToString">
            <summary>
             Returns the symbolic name of the message value, or null if it isn't one of the existing constants.
            </summary>
        </member>
        <member name="T:Windows.Win32.PInvokeCore">
            <content>
            Contains extern methods from "COMCTL32.dll".
            </content>
            <content>
            Contains extern methods from "GDI32.dll".
            </content>
            <content>
            Contains extern methods from "gdiplus.dll".
            </content>
            <content>
            Contains extern methods from "KERNEL32.dll".
            </content>
            <content>
            Contains extern methods from "OLE32.dll".
            </content>
            <content>
            Contains extern methods from "OLEAUT32.dll".
            </content>
            <content>
            Contains extern methods from "SHELL32.dll".
            </content>
            <content>
            Contains extern methods from "USER32.dll".
            </content>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.BitBlt``1(``0,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,Windows.Win32.Graphics.Gdi.ROP_CODE)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.BitBlt(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,Windows.Win32.Graphics.Gdi.ROP_CODE)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.BitBlt``1(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32,``0,System.Int32,System.Int32,Windows.Win32.Graphics.Gdi.ROP_CODE)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.BitBlt(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,Windows.Win32.Graphics.Gdi.ROP_CODE)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CopyIcon``1(``0,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.IMAGE_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.CopyImage(Windows.Win32.Foundation.HANDLE,Windows.Win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.IMAGE_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CopyCursor``1(``0,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.IMAGE_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.CopyImage(Windows.Win32.Foundation.HANDLE,Windows.Win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.IMAGE_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DragAcceptFiles``1(``0,Windows.Win32.Foundation.BOOL)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.DragAcceptFiles(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.BOOL)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DrawIconEx``1(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,``0,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.DI_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.DrawIconEx(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.HICON,System.Int32,System.Int32,System.UInt32,Windows.Win32.Graphics.Gdi.HBRUSH,Windows.Win32.UI.WindowsAndMessaging.DI_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.EnumCurrentThreadWindows(Windows.Win32.PInvokeCore.EnumThreadWindowsCallback)">
            <summary>
             Enumerates all nonchild windows in the current thread.
            </summary>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetClientRect``1(``0,Windows.Win32.Foundation.RECT@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetClientRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT@)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetIconInfo``1(``0)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetIconInfo(Windows.Win32.UI.WindowsAndMessaging.HICON,Windows.Win32.UI.WindowsAndMessaging.ICONINFO*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetObject``1(Windows.Win32.Graphics.Gdi.HGDIOBJ,``0@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetObject(Windows.Win32.Graphics.Gdi.HGDIOBJ,System.Int32,System.Void*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetPaletteEntries(Windows.Win32.Graphics.Gdi.HPALETTE,System.Span{Windows.Win32.Graphics.Gdi.PALETTEENTRY})">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetPaletteEntries(Windows.Win32.Graphics.Gdi.HPALETTE,System.UInt32,System.UInt32,Windows.Win32.Graphics.Gdi.PALETTEENTRY*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetSysColorBrush(System.Drawing.Color)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetSysColorBrush(Windows.Win32.Graphics.Gdi.SYS_COLOR_INDEX)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetWindowLong``1(``0,Windows.Win32.UI.WindowsAndMessaging.WINDOW_LONG_PTR_INDEX)">
            <summary>
             Dynamic wrapper for GetWindowLong that works on both 32 and 64 bit.
            </summary>
            <remarks>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowlongptrw">
               GetWindowLong documentation.
              </see>
             </para>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetWindowRect``1(``0,Windows.Win32.Foundation.RECT@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetWindowRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT@)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetWindowTextLength``1(``0)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetWindowTextLength(Windows.Win32.Foundation.HWND)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetWindowThreadProcessId``1(``0,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetWindowThreadProcessId(Windows.Win32.Foundation.HWND,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.MapWindowPoints``2(``0,``1,Windows.Win32.Foundation.RECT@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.MapWindowPoints(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.HWND,System.Drawing.Point*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.MapWindowPoints``2(``0,``1,System.Drawing.Point@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.MapWindowPoints(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.HWND,System.Drawing.Point*,System.UInt32)"/>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.MaxClassName">
            <summary>
             <para>
              The maximum length for lpszClassName is 256. If lpszClassName is greater than the maximum length,
              the RegisterClassEx function will fail.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
            <remarks>
             <para>
              The maximum name for an ATOM is 255 characters, which is where this limitation comes from. There is no
              public define, internally it is RTL_ATOM_MAXIMUM_NAME_LENGTH.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.PeekMessage``1(Windows.Win32.UI.WindowsAndMessaging.MSG*,``0,System.UInt32,System.UInt32,Windows.Win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.PeekMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*,Windows.Win32.Foundation.HWND,System.UInt32,System.UInt32,Windows.Win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.PostMessage``1(``0,Windows.Win32.MessageId,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.PostMessage(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.RegisterDragDrop``1(``0,Windows.Win32.System.Ole.IDropTarget.Interface)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.RegisterDragDrop(Windows.Win32.Foundation.HWND,Windows.Win32.System.Ole.IDropTarget*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.RevokeDragDrop``1(``0)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.RevokeDragDrop(Windows.Win32.Foundation.HWND)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SendMessage``1(``0,Windows.Win32.MessageId,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SendMessage(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SendMessage``2(``0,Windows.Win32.MessageId,``1,Windows.Win32.Foundation.LPARAM)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SendMessage(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SendMessage``1(``0,Windows.Win32.MessageId,Windows.Win32.Foundation.WPARAM,System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SendMessage(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SendMessage``2(``0,Windows.Win32.MessageId,Windows.Win32.Foundation.WPARAM,``1@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SendMessage(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SendMessage``3(``0,Windows.Win32.MessageId,``1@,``2@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SendMessage(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SystemParametersInfo``1(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION,``0@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SystemParametersInfo(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION,System.UInt32,System.Void*,Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_UPDATE_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SystemParametersInfoInt(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SystemParametersInfo(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION,System.UInt32,System.Void*,Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_UPDATE_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SystemParametersInfo(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION,System.Boolean@,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SystemParametersInfo(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION,System.UInt32,System.Void*,Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_UPDATE_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SystemParametersInfoBool(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SystemParametersInfo(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION,System.UInt32,System.Void*,Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_UPDATE_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SystemParametersInfo(Windows.Win32.UI.Accessibility.HIGHCONTRASTW@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SystemParametersInfo(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION,System.UInt32,System.Void*,Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_UPDATE_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SystemParametersInfo(Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SystemParametersInfo(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION,System.UInt32,System.Void*,Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_UPDATE_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.TrySystemParametersInfoForDpi(Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW@,System.UInt32)">
            <summary>
             Tries to get system parameter info for the dpi. dpi is ignored if "SystemParametersInfoForDpi()" API
             is not available on the OS that this application is running.
            </summary>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DestroyPropertySheetPage(Windows.Win32.UI.Controls.HPROPSHEETPAGE)">
            <summary>Destroys a property sheet page. An application must call this function for pages that have not been passed to the PropertySheet function.</summary>
            <returns>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b> Returns nonzero if successful, or zero otherwise.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/prsht/nf-prsht-destroypropertysheetpage">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.CLR_NONE">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/commctrl/nf-commctrl-imagelist_drawex">ImageList_DrawEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/commctrl/nf-commctrl-imagelist_drawex">ImageList_DrawEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/commctrl/ns-commctrl-imagelistdrawparams">IMAGELISTDRAWPARAMS</see>, <see href="https://learn.microsoft.com/windows/win32/api/commctrl/ns-commctrl-imagelistdrawparams">IMAGELISTDRAWPARAMS</see>, <see href="https://learn.microsoft.com/windows/win32/api/commoncontrols/ns-commoncontrols-imagelistdrawparams">IMAGELISTDRAWPARAMS</see>, <see href="https://learn.microsoft.com/windows/win32/api/commoncontrols/ns-commoncontrols-imagelistdrawparams">IMAGELISTDRAWPARAMS</see>.</summary>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.CLR_DEFAULT">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/commctrl/nf-commctrl-imagelist_drawex">ImageList_DrawEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/commctrl/nf-commctrl-imagelist_drawex">ImageList_DrawEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/commctrl/ns-commctrl-imagelistdrawparams">IMAGELISTDRAWPARAMS</see>, <see href="https://learn.microsoft.com/windows/win32/api/commctrl/ns-commctrl-imagelistdrawparams">IMAGELISTDRAWPARAMS</see>, <see href="https://learn.microsoft.com/windows/win32/api/commoncontrols/ns-commoncontrols-imagelistdrawparams">IMAGELISTDRAWPARAMS</see>, <see href="https://learn.microsoft.com/windows/win32/api/commoncontrols/ns-commoncontrols-imagelistdrawparams">IMAGELISTDRAWPARAMS</see>.</summary>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SCROLLCARET">
            <summary>Scrolls the caret into view in an edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>The return value is not meaningful.</returns>
            <remarks>**Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETLIMITTEXT">
            <summary>EM_SETLIMITTEXT message - Sets the text limit of an edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The **EM\_SETLIMITTEXT** message limits only the text the user can enter. It does not affect any text already in the edit control when the message is sent, nor does it affect the length of the text copied to the edit control by the [**WM\_SETTEXT**](/windows/desktop/winmsg/wm-settext) message. If an application uses the **WM\_SETTEXT** message to place more text into an edit control than is specified in the **EM\_SETLIMITTEXT** message, the user can edit the entire contents of the edit control. Before **EM\_SETLIMITTEXT** is called, the default limit for the amount of text a user can enter in an edit control is 32,767 characters. For single-line edit controls, the text limit is either 0x7FFFFFFE bytes or the value of the *wParam* parameter, whichever is smaller. For multiline edit controls, this value is either  1 bytes or the value of the *wParam* parameter, whichever is smaller. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. Use the message [**EM\_EXLIMITTEXT**](em-exlimittext.md) for text length values greater than 64,000. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setlimittext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETLIMITTEXT">
            <summary>Gets the current text limit for an edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>The return value is the text limit.</returns>
            <remarks>
            <para>**Edit controls, Rich Edit 2.0 and later:** The text limit is the maximum amount of text, in **TCHAR**s, that the control can contain. For ANSI text, this is the number of bytes; for Unicode text, this is the number of characters. Two documents with the same character limit will yield the same text limit, even if one is ANSI and the other is Unicode. **Rich Edit 1.0:** The text limit is the maximum amount of text, in bytes, that the rich edit control can contain. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getlimittext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_POSFROMCHAR">
            <summary>Retrieves the client area coordinates of a specified character in an edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>
            <para>**Rich Edit 1.0 and 3.0:** The return value is not used. **Edit controls and Rich Edit 2.0:** The return value contains the client area coordinates of the character. The [**LOWORD**](/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)) contains the horizontal coordinate and the [**HIWORD**](/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)) contains the vertical coordinate.</para>
            </returns>
            <remarks>
            <para>A returned coordinate can be a negative value if the specified character is not displayed in the edit control's client area. The coordinates are truncated to integer values. If the character is a line delimiter, the returned coordinates indicate a point just beyond the last visible character in the line. If the specified index is greater than the index of the last character in the control, the control returns -1. **Rich Edit 3.0 and later:** For backward compatibility, Microsoft Rich Edit 3.0 supports the syntax used by Microsoft Rich Edit 2.0. If Microsoft Rich Edit 3.0 detects that *wParam* is not a valid [**POINTL**](/windows/win32/api/windef/ns-windef-pointl) pointer, it assumes the message was sent using the Microsoft Rich Edit 2.0 syntax. In this case, it uses the return value to return the coordinates. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-posfromchar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_CHARFROMPOS">
            <summary>Gets information about the character closest to a specified point in the client area of an edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>
            <para>**Rich edit controls:** The return value specifies the zero-based character index of the character nearest the specified point. The return value indicates the last character in the edit control if the specified point is beyond the last character in the control. **Edit controls:** The [**LOWORD**](/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)) specifies the zero-based index of the character nearest the specified point. This index is relative to the beginning of the control, not the beginning of the line. If the specified point is beyond the last character in the edit control, the return value indicates the last character in the control. The [**HIWORD**](/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)) specifies the zero-based index of the line that contains the character. For single-line edit controls, this value is zero. The index indicates the line delimiter if the specified point is beyond the last visible character in a line.</para>
            </returns>
            <remarks>
            <para>**Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md). If a point is passed to **EM\_CHARFROMPOS** as the *lParam* and the point is outside the bounds of the edit control, then the *lResult* is (65535, 65535).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-charfrompos#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETCUEBANNER">
            <summary>Sets the textual cue, or tip, that is displayed by the edit control to prompt the user for information.</summary>
            <returns>If the message succeeds, it returns **TRUE**. Otherwise it returns **FALSE**.</returns>
            <remarks>
            <para>An edit control that is used to begin a search may display "Enter search here" in gray text as a textual cue. When the user clicks the text, the text goes away and the user can type. You cannot set a cue banner on a multiline edit control or on a rich edit control. > [!Note] > To use this API, you must provide a manifest specifying Comclt32.dll version 6.0. For more information on manifests, see [Enabling Visual Styles](cookbook-overview.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setcuebanner#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETCUEBANNER">
            <summary>Gets the text that is displayed as the textual cue, or tip, in an edit control.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>> [!Note] > To use this message, you must provide a manifest specifying Comclt32.dll version 6.0. For more information on manifests, see [Enabling Visual Styles](cookbook-overview.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getcuebanner#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SHOWBALLOONTIP">
            <summary>The EM\_SHOWBALLOONTIP message displays a balloon tip associated with an edit control.</summary>
            <returns>If the message succeeds, it returns **TRUE**. Otherwise it returns **FALSE**.</returns>
            <remarks>
            <para>> [!Note] > To use this message, you must provide a manifest specifying Comclt32.dll version 6.0. For more information on manifests, see [Enabling Visual Styles](cookbook-overview.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-showballoontip#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_HIDEBALLOONTIP">
            <summary>Hides any balloon tip associated with an edit control.</summary>
            <returns>If the message succeeds, it returns **TRUE**. Otherwise it returns **FALSE**.</returns>
            <remarks>
            <para>> [!Note] > To use this message, you must provide a manifest specifying Comclt32.dll version 6.0. For more information on manifests, see [Enabling Visual Styles](cookbook-overview.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-hideballoontip#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETHILITE">
            <summary>EM_SETHILITE message - Not implemented.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-sethilite">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETHILITE">
            <summary>EM\_GETHILITE message</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-gethilite">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_NOSETFOCUS">
            <summary>Prevents a single-line edit control from receiving keyboard focus. You can send this message explicitly or by using the Edit\_NoSetFocus macro.</summary>
            <returns>The return value is not used.</returns>
            <remarks>
            <para>This message is ignored if the edit control is not a single-line edit control. After this message is sent, the effect is permanent.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-nosetfocus#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_TAKEFOCUS">
            <summary>Forces a single-line edit control to receive keyboard focus. You can send this message explicitly or by using the Edit\_TakeFocus macro.</summary>
            <returns>The return value is not used.</returns>
            <remarks>
            <para>This message is ignored if the edit control is not a single-line edit control. If the edit control previously received an [**EM\_NOSETFOCUS**](em-nosetfocus.md) message, the edit control will appear to have the focus without actually having it; otherwise, the edit control will receive focus.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-takefocus#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETEXTENDEDSTYLE">
            <summary>Informs the edit control to set extended styles. Send this message or use the macro Edit\_SetExtendedStyle.</summary>
            <returns>If this message succeeds, it returns **S\_OK**. Otherwise, it returns an **HRESULT** error code.</returns>
            <remarks>The extended styles for an edit control have nothing to do with the extended styles used with function [**CreateWindowEx**](/windows/desktop/api/winuser/nf-winuser-createwindowexa) or function [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETEXTENDEDSTYLE">
            <summary>Retrieves the extended style for an edit control. Send this message explicitly or by using the Edit\_GetExtendedStyle macro.</summary>
            <returns>Returns the value of extended style.For more information on styles, see [Edit Control Extended Styles](edit-control-window-extended-styles.md).</returns>
            <remarks>The extended styles for an edit control have nothing to do with the extended styles used with function [**CreateWindowEx**](/windows/desktop/api/winuser/nf-winuser-createwindowexa) or function [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETENDOFLINE">
            <summary>Sets the end-of-line character used when a linebreak is inserted.</summary>
            <returns>
            <para>If the operation succeeds, the return value is nonzero. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>When the end-of-line character set is **EC\_ENDOFLINE\_DETECTFROMCONTENT**, the edit control will only detect end-of-line characters supported according to its extended window style, see [Edit Control Extended Styles](edit-control-window-extended-styles.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETENDOFLINE">
            <summary>Retrieves the end-of-line character used when a linebreak is inserted. Send this message explicitly or by using the Edit\_GetEndOfLine macro.</summary>
            <returns>
            <para>Returns the end-of-line character used by the edit control. This can be one of the following values. | Value                                                                                                                                                   | Meaning                                                                                        | |---------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------| | <span id="EC_ENDOFLINE_CRLF"></span><span id="ec_endofline_crlf"></span><dl> <dt>**EC\_ENDOFLINE\_CRLF**</dt> </dl> | The end-of-line character used for new linebreaks is carriage return followed by linefeed (CRLF).<br/> | | <span id="EC_ENDOFLINE_CR"></span><span id="ec_endofline_cr"></span><dl> <dt>**EC\_ENDOFLINE\_CR**</dt> </dl>       | The end-of-line character used for new linebreaks is carriage return (CR).<br/>                        | | <span id="EC_ENDOFLINE_LF"></span><span id="ec_endofline_lf"></span><dl> <dt>**EC\_ENDOFLINE\_LF**</dt> </dl>       | The end-of-line character used for new linebreaks is linefeed (LF).<br/>                               |</para>
            </returns>
            <remarks>When the end-of-line character used is set to **EC\_ENDOFLINE\_DETECTFROMCONTENT** using [**Edit\_SetEndOfLine**](/windows/desktop/api/Commctrl/nf-commctrl-edit_setendofline), this message will return the detected end-of-line character.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_ENABLESEARCHWEB">
            <summary>Enables or disables the "Search the web" feature and context menu entry.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>If you disable "Search the web" using this message, the [**EM\_SEARCHWEB**](em-searchweb.md) message has no effect.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SEARCHWEB">
            <summary>Opens the browser and performs a web search with the selected text as the search term.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>If the "Search the web" feature is disabled using the [**EM\_ENABLESEARCHWEB**](em-enablesearchweb.md) message, this message has no effect.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETCARETINDEX">
            <summary>Sets the zero-based index value of the position of the caret in an edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>If the index is out of the range of the text in an edit control, the index will be adjusted to fit inside the range of the text.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETCARETINDEX">
            <summary>Gets the zero-based index of the position of the caret in an edit control.</summary>
            <returns>The return value is a zero-based index value of the position of the caret.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getcaretindex">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_FILELINEFROMCHAR">
            <summary>Gets the index of the line that contains the specified character index in a multiline edit control, independently of how lines are displayed on the screen.</summary>
            <returns>The return value is the zero-based line number of the line containing the character index specified by *wParam*, independently of how lines are displayed on the screen.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-filelinefromchar">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_FILELINEINDEX">
            <summary>Gets the character index of the first character of a specified line in a multiline edit control, independently of how lines are displayed on the screen.</summary>
            <returns>The return value is the character index of the line specified in the *wParam* parameter, independently of how lines are displayed on the screen, or it is -1 if the specified line number is greater than the number of lines in the edit control.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-filelineindex">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_FILELINELENGTH">
            <summary>Retrieves the length, in characters, of a line in an edit control, independently of how lines are displayed on the screen.</summary>
            <returns>
            <para>For multiline edit controls, the return value is the length, in **TCHAR**s, of the line specified by the *wParam* parameter, independently of how lines are displayed on the screen. It does not include the carriage-return or linefeed character at the end of the line. For single-line edit controls, the return value is the length, in **TCHAR**s, of the text in the edit control. If *wParam* is greater than the number of characters in the control, the return value is zero.</para>
            </returns>
            <remarks>Use the [**EM\_FILELINEINDEX**](em-lineindex.md) message to retrieve a character index for a given line number within a multiline edit control, independently of how lines are displayed on the screen.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETFILELINE">
            <summary>Copies a line of text from an edit control, independently of how lines are displayed on the screen, and places it in a specified buffer.</summary>
            <returns>The return value is the number of **TCHAR**s copied. The return value is zero if the line number specified by the *wParam* parameter is greater than the number of lines in the edit control.</returns>
            <remarks>The copied line does not contain a terminating null character.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETFILELINECOUNT">
            <summary>Gets the number of lines in a multiline edit control, independently of how lines are displayed on the screen.</summary>
            <returns>The return value is an integer specifying the total number of text lines in the multiline edit control, independently of how lines are displayed on the screen. If the control has no text, the return value is 1. The return value will never be less than 1.</returns>
            <remarks>
            <para>The **EM\_GETFILELINECOUNT** message retrieves the total number of text lines, independently of how lines are displayed on the screen, not just the number of lines that are currently visible. Word-wrap does not change the number of lines this message returns, as this message works independently of how lines are displayed on the screen.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getfilelinecount#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETSEL">
            <summary>Gets the starting and ending character positions (in TCHARs) of the current selection in an edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>
            <para>The return value is a zero-based value with the starting position of the selection in the [**LOWORD**](/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)) and the position of the first **TCHAR** after the last selected **TCHAR** in the [**HIWORD**](/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)). If either of these values exceeds 65,535, the return value is -1. It is better to use the values returned in *wParam* and *lParam* because they are full 32-bit values.</para>
            </returns>
            <remarks>
            <para>If there is no selection, the starting and ending values are both the position of the caret. **Rich edit controls:** You can also use the [**EM\_EXGETSEL**](em-exgetsel.md) message to retrieve the same information. **EM\_EXGETSEL** also returns starting and ending character positions as 32-bit values. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getsel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETSEL">
            <summary>Selects a range of characters in an edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The start value can be greater than the end value. The lower of the two values specifies the character position of the first character in the selection. The higher value specifies the position of the first character beyond the selection. The start value is the anchor point of the selection, and the end value is the active end. If the user uses the SHIFT key to adjust the size of the selection, the active end can move but the anchor point remains the same. If the start is 0 and the end is -1, all the text in the edit control is selected. If the start is -1, any current selection is deselected. **Edit controls:** The control displays a flashing caret at the end position regardless of the relative values of start and end. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md). If the edit control has the [**ES\_NOHIDESEL**](edit-control-styles.md) style, the selected text is highlighted regardless of whether the control has focus. Without the **ES\_NOHIDESEL** style, the selected text is highlighted only when the edit control has the focus.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setsel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETRECT">
            <summary>Gets the formatting rectangle of an edit control.</summary>
            <returns>The return value is not meaningful.</returns>
            <remarks>
            <para>You can modify the formatting rectangle of a multiline edit control by using the [**EM\_SETRECT**](em-setrect.md) and [**EM\_SETRECTNP**](em-setrectnp.md) messages. Under certain conditions, **EM\_GETRECT** might not return the exact values that [**EM\_SETRECT**](em-setrect.md) or [**EM\_SETRECTNP**](em-setrectnp.md) set it will be approximately correct, but it can be off by a few pixels. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. The formatting rectangle does not include the selection bar, which is an unmarked area to the left of each paragraph. When clicked, the selection bar selects the line. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getrect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETRECT">
            <summary>EM_SETRECT message - Sets the formatting rectangle of a multiline edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>Setting *lParam* to **NULL** has no effect if a touch device is installed, or if **EM\_SETRECT** is sent from a thread that has a hook installed (see [**SetWindowsHookEx**](/windows/desktop/api/winuser/nf-winuser-setwindowshookexa)). In these cases, *lParam* should contain a valid pointer to a [**RECT**](/windows/win32/api/windef/ns-windef-rect) structure. The **EM\_SETRECT** message causes the text of the edit control to be redrawn. To change the size of the formatting rectangle without redrawing the text, use the [**EM\_SETRECTNP**](em-setrectnp.md) message. When an edit control is first created, the formatting rectangle is set to a default size. You can use the **EM\_SETRECT** message to make the formatting rectangle larger or smaller than the edit control window. If the edit control does not have a horizontal scroll bar, and the formatting rectangle is set to be larger than the edit control window, lines of text exceeding the width of the edit control window (but smaller than the width of the formatting rectangle) are clipped instead of wrapped. If the edit control contains a border, the formatting rectangle is reduced by the size of the border. If you are adjusting the rectangle returned by an [**EM\_GETRECT**](em-getrect.md) message, you must remove the size of the border before using the rectangle with the **EM\_SETRECT** message. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. The formatting rectangle does not include the selection bar, which is an unmarked area to the left of each paragraph. When the user clicks in the selection bar, the corresponding line is selected. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setrect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETRECTNP">
            <summary>EM_SETRECTNP message - Sets the formatting rectangle of a multiline edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>**Rich Edit:** Supported in Microsoft Rich Edit 3.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SCROLL">
            <summary>Scrolls the text vertically in a multiline edit control. This message is equivalent to sending a WM\_VSCROLL message to the edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>If the message is successful, the [**HIWORD**](/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)) of the return value is **TRUE**, and the [**LOWORD**](/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)) is the number of lines that the command scrolls. The number returned may not be the same as the actual number of lines scrolled if the scrolling moves to the beginning or the end of the text. If the *wParam* parameter specifies an invalid value, the return value is **FALSE**.</returns>
            <remarks>
            <para>To scroll to a specific line or character position, use the [**EM\_LINESCROLL**](em-linescroll.md) message. To scroll the caret into view, use the [**EM\_SCROLLCARET**](em-scrollcaret.md) message. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-scroll#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_LINESCROLL">
            <summary>Scrolls the text in a multiline edit control.</summary>
            <returns>
            <para>If the message is sent to a multiline edit control, the return value is **TRUE**. If the message is sent to a single-line edit control, the return value is **FALSE**.</para>
            </returns>
            <remarks>
            <para>The control does not scroll vertically past the last line of text in the edit control. If the current line plus the number of lines specified by the *lParam* parameter exceeds the total number of lines in the edit control, the value is adjusted so that the last line of the edit control is scrolled to the top of the edit-control window. **Edit controls:** The **EM\_LINESCROLL** message scrolls the text vertically or horizontally in a multiline edit control. The **EM\_LINESCROLL** message can be used to scroll horizontally past the last character of any line. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. The **EM\_LINESCROLL** message scrolls the text vertically in a multiline edit control. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-linescroll#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETMODIFY">
            <summary>Gets the state of an edit control's modification flag. The flag indicates whether the contents of the edit control have been modified. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>If the contents of edit control have been modified, the return value is nonzero; otherwise, it is zero.</returns>
            <remarks>
            <para>The system automatically clears the modification flag to zero when the control is created. If the user changes the control's text, the system sets the flag to nonzero. You can send the [**EM\_SETMODIFY**](em-setmodify.md) message to the edit control to set or clear the flag. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getmodify#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETMODIFY">
            <summary>Sets or clears the modification flag for an edit control. The modification flag indicates whether the text within the edit control has been modified. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The system automatically clears the modification flag to zero when the control is created. If the user changes the control's text, the system sets the flag to nonzero. You can send the [**EM\_GETMODIFY**](em-getmodify.md) message to the edit control to retrieve the current state of the flag. **Rich Edit 1.0:** Objects created without the **REO\_DYNAMICSIZE** flag will lock in their extents when the modify flag is set to **FALSE**. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setmodify#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETLINECOUNT">
            <summary>Gets the number of lines in a multiline edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>The return value is an integer specifying the total number of text lines in the multiline edit control or rich edit control. If the control has no text, the return value is 1. The return value will never be less than 1.</returns>
            <remarks>
            <para>The **EM\_GETLINECOUNT** message retrieves the total number of text lines, not just the number of lines that are currently visible. If the Wordwrap feature is enabled, the number of lines can change when the dimensions of the editing window change. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getlinecount#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_LINEINDEX">
            <summary>Gets the character index of the first character of a specified line in a multiline edit control.</summary>
            <returns>The return value is the character index of the line specified in the *wParam* parameter, or it is -1 if the specified line number is greater than the number of lines in the edit control.</returns>
            <remarks>**Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETHANDLE">
            <summary>Sets the handle of the memory that will be used by a multiline edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>Before an application sets a new memory handle, it should send an [**EM\_GETHANDLE**](em-gethandle.md) message to retrieve the handle of the current memory buffer and should free that memory. An edit control automatically reallocates the given buffer whenever it needs additional space for text, or it removes enough text so that additional space is no longer needed. Sending an **EM\_SETHANDLE** message clears the undo buffer ([**EM\_CANUNDO**](em-canundo.md) returns zero) and the internal modification flag ([**EM\_GETMODIFY**](em-getmodify.md) returns zero). The edit control window is redrawn. **Rich Edit:** The **EM\_SETHANDLE** message is not supported. Rich edit controls do not store text as a simple array of characters.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-sethandle#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETHANDLE">
            <summary>Gets a handle of the memory currently allocated for a multiline edit control's text.</summary>
            <returns>The return value is a memory handle identifying the buffer that holds the content of the edit control. If an error occurs, such as sending the message to a single-line edit control, the return value is zero.</returns>
            <remarks>
            <para>If the function succeeds, the application can access the contents of the edit control by casting the return value to [**HLOCAL**](/windows/desktop/WinProg/windows-data-types) and passing it to [**LocalLock**](/windows/desktop/api/winbase/nf-winbase-locallock). **LocalLock** returns a pointer to a buffer that is a null-terminated array of **CHAR**s or **WCHAR**s, depending on whether an ANSI or Unicode function created the control. For example, if [**CreateWindowExA**](/windows/desktop/api/winuser/nf-winuser-createwindowexa) was used the buffer is an array of **CHAR**s, but if **CreateWindowExW** was used the buffer is an array of **WCHAR**s. The application may not change the contents of the buffer. To unlock the buffer, the application calls [**LocalUnlock**](/windows/desktop/api/winbase/nf-winbase-localunlock) before allowing the edit control to receive new messages. > [!Note] > For Comctl32.dll version 6, the buffer always contains an array of **WCHAR**s, regardless of whether an ANSI or Unicode function created the edit control. For more information on DLL versions, see [Common Control Versions](common-control-versions.md).</para>
            <para>If your application cannot abide by the restrictions imposed by **EM\_GETHANDLE**, use the [**GetWindowTextLength**](/windows/desktop/api/winuser/nf-winuser-getwindowtextlengtha) and [**GetWindowText**](/windows/desktop/api/winuser/nf-winuser-getwindowtexta) functions to copy the contents of the edit control into an application-provided buffer. **Rich Edit:** The **EM\_GETHANDLE** message is not supported. Rich edit controls do not store text as a simple array of characters.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-gethandle#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETTHUMB">
            <summary>Gets the position of the scroll box (thumb) in the vertical scroll bar of a multiline edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>The return value is the position of the scroll box.</returns>
            <remarks>**Rich Edit:** Supported in Microsoft Rich Edit 2.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_LINELENGTH">
            <summary>Retrieves the length, in characters, of a line in an edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>
            <para>For multiline edit controls, the return value is the length, in **TCHAR**s, of the line specified by the *wParam* parameter. For ANSI text, this is the number of bytes; for Unicode text, this is the number of characters. It does not include the carriage-return character at the end of the line. For single-line edit controls, the return value is the length, in **TCHAR**s, of the text in the edit control. If *wParam* is greater than the number of characters in the control, the return value is zero.</para>
            </returns>
            <remarks>
            <para>Use the [**EM\_LINEINDEX**](em-lineindex.md) message to retrieve a character index for a given line number within a multiline edit control. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-linelength#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_REPLACESEL">
            <summary>Replaces the selected text in an edit control or a rich edit control with the specified text.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>Use the **EM\_REPLACESEL** message to replace only a portion of the text in an edit control. To replace all of the text, use the [**WM\_SETTEXT**](/windows/desktop/winmsg/wm-settext) message. If there is no selection, the replacement text is inserted at the caret. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md). In a rich edit control, the replacement text takes the formatting of the character at the caret or, if there is a selection, of the first character in the selection.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-replacesel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETLINE">
            <summary>Copies a line of text from an edit control and places it in a specified buffer. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>The return value is the number of **TCHAR**s copied. The return value is zero if the line number specified by the *wParam* parameter is greater than the number of lines in the edit control.</returns>
            <remarks>
            <para>**Edit controls:** The copied line does not contain a terminating null character. **Rich edit controls:** Supported in Microsoft Rich Edit 1.0 and later. The copied line does not contain a terminating null character, unless no text was copied. If no text was copied, the message places a null character at the beginning of the buffer. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getline#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_LIMITTEXT">
            <summary>EM_LIMITTEXT message - Sets the text limit of an edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The **EM\_LIMITTEXT** message limits only the text the user can enter. It does not affect any text already in the edit control when the message is sent, nor does it affect the length of the text copied to the edit control by the [**WM\_SETTEXT**](/windows/desktop/winmsg/wm-settext) message. If an application uses the **WM\_SETTEXT** message to place more text into an edit control than is specified in the **EM\_LIMITTEXT** message, the user can edit the entire contents of the edit control. Before **EM\_LIMITTEXT** is called, the default limit for the amount of text a user can enter in an edit control is 32,767 characters. For single-line edit controls, the text limit is either 0x7FFFFFFE bytes or the value of the *wParam* parameter, whichever is smaller. For multiline edit controls, this value is either -1 byte or the value of the *wParam* parameter, whichever is smaller. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. Use the message [**EM\_EXLIMITTEXT**](em-exlimittext.md) for text length values greater than 64,000. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-limittext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_CANUNDO">
            <summary>Determines whether there are any actions in an edit control's undo queue. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>
            <para>If there are actions in the control's undo queue, the return value is nonzero. If the undo queue is empty, the return value is zero.</para>
            </returns>
            <remarks>
            <para>If the undo queue is not empty, you can send the [**EM\_UNDO**](em-undo.md) message to the control to undo the most recent operation. **Edit controls and Rich Edit 1.0:** The undo queue contains only the most recent operation. **Rich Edit 2.0 and later:** The undo queue can contain multiple operations. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-canundo#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_UNDO">
            <summary>This message undoes the last edit control operation in the control's undo queue. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>
            <para>For a single-line edit control, the return value is always **TRUE**. For a multiline edit control, the return value is **TRUE** if the undo operation is successful, or **FALSE** if the undo operation fails.</para>
            </returns>
            <remarks>
            <para>**Edit controls and Rich Edit 1.0:** An undo operation can also be undone. For example, you can restore deleted text with the first **EM\_UNDO** message, and remove the text again with a second **EM\_UNDO** message as long as there is no intervening edit operation. **Rich Edit 2.0 and later:** The undo feature is multilevel so sending two **EM\_UNDO** messages will undo the last two operations in the undo queue. To redo an operation, send the [**EM\_REDO**](em-redo.md) message. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-undo#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_FMTLINES">
            <summary>Sets a flag that determines whether a multiline edit control includes soft line-break characters. A soft line break consists of two carriage returns and a line feed and is inserted at the end of a line that is broken because of wordwrapping.</summary>
            <returns>The return value is identical to the *wParam* parameter.</returns>
            <remarks>
            <para>This message affects only the buffer returned by the [**EM\_GETHANDLE**](em-gethandle.md) message and the text returned by the [**WM\_GETTEXT**](/windows/desktop/winmsg/wm-gettext) message. It has no effect on the display of the text within the edit control. The **EM\_FMTLINES** message does not affect a line that ends with a hard line break. A hard line break consists of one carriage return and a line feed. > [!Note] > The size of the text changes when this message is processed.</para>
            <para>**Rich Edit:** The **EM\_FMTLINES** message is not supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-fmtlines#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_LINEFROMCHAR">
            <summary>Gets the index of the line that contains the specified character index in a multiline edit control.</summary>
            <returns>The return value is the zero-based line number of the line containing the character index specified by *wParam*.</returns>
            <remarks>**Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. If the character index is greater than 64,000, use the [**EM\_EXLINEFROMCHAR**](em-exlinefromchar.md) message. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETTABSTOPS">
            <summary>The EM\_SETTABSTOPS message sets the tab stops in a multiline edit control.</summary>
            <returns>
            <para>If all the tabs are set, the return value is **TRUE**. If all the tabs are not set, the return value is **FALSE**.</para>
            </returns>
            <remarks>
            <para>The **EM\_SETTABSTOPS** message does not automatically redraw the edit control window. If the application is changing the tab stops for text already in the edit control, it should call the [**InvalidateRect**](/windows/desktop/api/winuser/nf-winuser-invalidaterect) function to redraw the edit control window. The values specified in the array are in dialog template units, which are the device-independent units used in dialog box templates. To convert measurements from dialog template units to screen units (pixels), use the [**MapDialogRect**](/windows/desktop/api/winuser/nf-winuser-mapdialogrect) function. **Rich Edit:** Supported in Microsoft Rich Edit 3.0 and later. A rich edit control can have the maximum number of tab stops specified by MAX\_TAB\_STOPS. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-settabstops#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETPASSWORDCHAR">
            <summary>Sets or removes the password character for an edit control. When a password character is set, that character is displayed in place of the characters typed by the user. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>When an edit control receives the **EM\_SETPASSWORDCHAR** message, the control redraws all visible characters using the character specified by the *wParam* parameter. If *wParam* is zero, the control redraws all visible characters using the characters typed by the user. If an edit control is created with the [**ES\_PASSWORD**](edit-control-styles.md) style, the default password character is set to an asterisk (\*). If an edit control is created without the **ES\_PASSWORD** style, there is no password character. The **ES\_PASSWORD** style is removed if an **EM\_SETPASSWORDCHAR** message is sent with the *wParam* parameter set to zero. **Edit controls:** Multiline edit controls do not support the password style or messages. **Rich Edit:** Supported in Microsoft Rich Edit 2.0 and later. Both single-line and multiline edit controls support the password style and messages. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setpasswordchar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_EMPTYUNDOBUFFER">
            <summary>Resets the undo flag of an edit control. The undo flag is set whenever an operation within the edit control can be undone. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The undo flag is automatically reset whenever the edit control receives a [**WM\_SETTEXT**](/windows/desktop/winmsg/wm-settext) or [**EM\_SETHANDLE**](em-sethandle.md) message. **Edit controls and Rich Edit 1.0:** The control can only undo or redo the most recent operation. **Rich Edit 2.0 and later:** The **EM\_EMPTYUNDOBUFFER** message empties all undo and redo buffers. Rich edit controls enable the user to undo or redo multiple operations. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-emptyundobuffer#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETFIRSTVISIBLELINE">
            <summary>Gets the zero-based index of the uppermost visible line in a multiline edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>
            <para>The return value is the zero-based index of the uppermost visible line in a multiline edit control. **Edit controls:** For single-line edit controls, the return value is the zero-based index of the first visible character. **Rich edit controls:** For single-line rich edit controls, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The number of lines and the length of the lines in an edit control depend on the width of the control and the current Wordwrap setting. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getfirstvisibleline#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETREADONLY">
            <summary>Sets or removes the read-only style (ES\_READONLY) of an edit control. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>
            <para>If the operation succeeds, the return value is nonzero. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>When an edit control has the [**ES\_READONLY**](edit-control-styles.md) style, the user cannot change the text within the edit control. To determine whether an edit control has the [**ES\_READONLY**](edit-control-styles.md) style, use the [**GetWindowLong**](/windows/desktop/api/winuser/nf-winuser-getwindowlonga) function with the GWL\_STYLE flag. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setreadonly#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETWORDBREAKPROC">
            <summary>Replaces an edit control's default Wordwrap function with an application-defined Wordwrap function. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>A Wordwrap function scans a text buffer that contains text to be sent to the screen, looking for the first word that does not fit on the current screen line. The Wordwrap function places this word at the beginning of the next line on the screen. A Wordwrap function defines the point at which the system should break a line of text for multiline edit controls, usually at a space character that separates two words. Either a multiline or a single-line edit control might call this function when the user presses arrow keys in combination with the CTRL key to move the caret to the next word or previous word. The default Wordwrap function breaks a line of text at a space character. The application-defined function may define the Wordwrap to occur at a hyphen or a character other than the space character. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setwordbreakproc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETWORDBREAKPROC">
            <summary>Gets the address of the current Wordwrap function. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>The return value specifies the address of the application-defined Wordwrap function. The return value is **NULL** if no Wordwrap function exists.</returns>
            <remarks>
            <para>A Wordwrap function scans a text buffer that contains text to be sent to the display, looking for the first word that does not fit on the current display line. The wordwrap function places this word at the beginning of the next line on the display. A Wordwrap function defines the point at which the system should break a line of text for multiline edit controls, usually at a space character that separates two words. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getwordbreakproc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETPASSWORDCHAR">
            <summary>Gets the password character that an edit control displays when the user enters text. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>The return value specifies the character to be displayed in place of any characters typed by the user. If the return value is **NULL**, there is no password character, and the control displays the characters typed by the user.</returns>
            <remarks>
            <para>If an edit control is created with the [**ES\_PASSWORD**](edit-control-styles.md) style, the default password character is set to an asterisk (\*). If an edit control is created without the **ES\_PASSWORD** style, there is no password character. To change the password character, send the [**EM\_SETPASSWORDCHAR**](em-setpasswordchar.md) message. **Edit controls:** Multiline edit controls do not support the password style or messages. **Rich edit:** Supported in Microsoft Rich Edit 2.0 and later. Both single-line and multiline edit controls support the password style and messages. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getpasswordchar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETMARGINS">
            <summary>Sets the widths of the left and right margins for an edit control. The message redraws the control to reflect the new margins. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>**Edit controls:** You cannot use **EC\_USEFONTINFO** in the *wParam* parameter, but you can use it in the *lParam* parameter. **Rich Edit:** Supported in Microsoft Rich Edit 1.0 and later. All rich edit versions support the use of **EC\_USEFONTINFO** in the *wParam* parameter. However, only Microsoft Rich Edit 3.0 and later support the use of **EC\_USEFONTINFO** in the *lParam* parameter. For information about the compatibility of rich edit versions with the various system versions, see [About Rich Edit Controls](about-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setmargins#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETMARGINS">
            <summary>Gets the widths of the left and right margins for an edit control.</summary>
            <returns>Returns the width of the left margin in the LOWORD, and the width of the right margin in the HIWORD.</returns>
            <remarks>**Rich Edit:** The **EM\_GETMARGINS** message is not supported.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETIMESTATUS">
            <summary>Sets the status flags that determine how an edit control interacts with the Input Method Editor (IME).</summary>
            <returns>Returns the previous value of the *lParam* parameter.</returns>
            <remarks>**Rich Edit:** The **EM\_SETIMESTATUS** message is not supported.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETIMESTATUS">
            <summary>Gets a set of status flags that indicate how the edit control interacts with the Input Method Editor (IME).</summary>
            <returns>
            <para>Data specific to the type of status to retrieve. With the **EMSIS\_COMPOSITIONSTRING** value for *status*, this return value is one or more of the following values.</para>
            <para>| Return code                                                                                                    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                      | |----------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**EIMES\_GETCOMPSTRATONCE**</dt> </dl>         | If this flag is set, the edit control hooks the [**WM\_IME\_COMPOSITION**](/windows/desktop/Intl/wm-ime-composition) message with *fFlags* set to GCS\_RESULTSTR and returns the result string immediately. If this flag is not set, the edit control passes the **WM\_IME\_COMPOSITION** message to the default window procedure and processes the result string from the [**WM\_CHAR**](/windows/desktop/inputdev/wm-char) message; this is the default behavior of the edit control.<br/> | | <dl> <dt>**EIMES\_CANCELCOMPSTRINFOCUS**</dt> </dl>     | If this flag is set, the edit control cancels the composition string when it receives the [**WM\_SETFOCUS**](/windows/desktop/inputdev/wm-setfocus) message. If this flag is not set, the edit control does not cancel the composition string; this is the default behavior of the edit control.<br/>                                                                                                                                                                       | | <dl> <dt>**EIMES\_COMPLETECOMPSTRKILLFOCUS**</dt> </dl> | If this flag is set, the edit control completes the composition string upon receiving the [**WM\_KILLFOCUS**](/windows/desktop/inputdev/wm-killfocus) message. If this flag is not set, the edit control does not complete the composition string; this is the default behavior of the edit control.<br/>                                                                                                                                                                   |</para>
            </returns>
            <remarks>**Rich Edit:** The **EM\_GETIMESTATUS** message is not supported.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_CANPASTE">
            <summary>Determines whether a rich edit control can paste a specified clipboard format.</summary>
            <returns>
            <para>If the clipboard format can be pasted, the return value is a nonzero value. If the clipboard format cannot be pasted, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-canpaste">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_DISPLAYBAND">
            <summary>Displays a portion of the contents of a rich edit control, as previously formatted for a device using the EM\_FORMATRANGE message.</summary>
            <returns>
            <para>If the operation succeeds, the return value is **TRUE**. If the operation fails, the return value is **FALSE**.</para>
            </returns>
            <remarks>
            <para>Text and Component Object Model (COM) objects are clipped by the rectangle. The application does not need to set the clipping region. Banding is the process by which a single page of output is generated using one or more separate rectangles, or bands. When all bands are placed on the page, a complete image results. This approach is often used by raster printers that do not have sufficient memory or ability to image a full page at one time. Banding devices include most dot matrix printers as well as some laser printers.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-displayband#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_EXGETSEL">
            <summary>Retrieves the starting and ending character positions of the selection in a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-exgetsel">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_EXLIMITTEXT">
            <summary>Sets an upper limit to the amount of text the user can type or paste into a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The text limit set by the **EM\_EXLIMITTEXT** message does not limit the amount of text that you can stream into a rich edit control using the [**EM\_STREAMIN**](em-streamin.md) message with *lParam* set to SF\_TEXT. However, it does limit the amount of text that you can stream into a rich edit control using the **EM\_STREAMIN** message with *lParam* set to SF\_RTF. Before **EM\_EXLIMITTEXT** is called, the default limit to the amount of text a user can enter is 32,767 characters.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-exlimittext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_EXLINEFROMCHAR">
            <summary>Determines which line contains the specified character in a rich edit control.</summary>
            <returns>This message returns the zero-based index of the line.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-exlinefromchar">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_EXSETSEL">
            <summary>Selects a range of characters or Component Object Model (COM) objects in a Microsoft Rich Edit control.</summary>
            <returns>The return value is the selection that is actually set.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-exsetsel">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_FINDTEXT">
            <summary>EM_FINDTEXT message - Finds text within a rich edit control.</summary>
            <returns>If the target string is found, the return value is the zero-based position of the first character of the match. If the target is not found, the return value is -1.</returns>
            <remarks>The **cpMin** member of **FINDTEXT.chrg** always specifies the starting-point of the search, and **cpMax** specifies the end point. When searching backward, **cpMin** must be equal to or greater than **cpMax**. When searching forward, a value of -1 in **cpMax** extends the search range to the end of the text.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_FORMATRANGE">
            <summary>Formats a range of text in a rich edit control for a specific device.</summary>
            <returns>This message returns the index of the last character that fits in the region, plus 1.</returns>
            <remarks>
            <para>This message is typically used to format the content of rich edit control for an output device such as a printer. After using this message to format a range of text, it is important that you free cached information by sending **EM\_FORMATRANGE** again, but with *lParam* set to **NULL**; otherwise, a memory leak will occur. Also, after using this message for one device, you must free cached information before using it again for a different device.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-formatrange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETCHARFORMAT">
            <summary>Determines the character formatting in a rich edit control.</summary>
            <returns>This message returns the value of the **dwMask** member of the [**CHARFORMAT**](/windows/win32/api/richedit/ns-richedit-charformata) structure.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getcharformat">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETEVENTMASK">
            <summary>Retrieves the event mask for a rich edit control. The event mask specifies which notification codes the control sends to its parent window.</summary>
            <returns>This message returns the event mask for the rich edit control.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-geteventmask">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETOLEINTERFACE">
            <summary>Retrieves an IRichEditOle object that a client can use to access a rich edit control's Component Object Model (COM) functionality.</summary>
            <returns>
            <para>If the operation succeeds, the return value is a nonzero value. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getoleinterface">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETPARAFORMAT">
            <summary>Retrieves the paragraph formatting of the current selection in a rich edit control.</summary>
            <returns>This message returns the value of the **dwMask** member of the [**PARAFORMAT**](/windows/desktop/api/Richedit/ns-richedit-paraformat) structure.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getparaformat">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETSELTEXT">
            <summary>Retrieves the currently selected text in a rich edit control.</summary>
            <returns>This message returns the number of characters copied, not including the terminating null character.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getseltext">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_HIDESELECTION">
            <summary>The EM\_HIDESELECTION message hides or shows the selection in a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-hideselection">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_PASTESPECIAL">
            <summary>Pastes a specific clipboard format in a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-pastespecial">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_REQUESTRESIZE">
            <summary>Forces a rich edit control to send an EN\_REQUESTRESIZE notification code to its parent window.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>This message is useful during [**WM\_SIZE**](/windows/desktop/winmsg/wm-size) processing for the parent of a bottomless rich edit control.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SELECTIONTYPE">
            <summary>Determines the selection type for a rich edit control.</summary>
            <returns>
            <para>If the selection is empty, the return value is SEL\_EMPTY. If the selection is not empty, the return value is a set of flags containing one or more of the following values.</para>
            <para>| Return code                                                                                     | Description                                 | |-------------------------------------------------------------------------------------------------|---------------------------------------------| | <dl> <dt>**SEL\_TEXT**</dt> </dl>        | Text.<br/>                            | | <dl> <dt>**SEL\_OBJECT**</dt> </dl>      | At least one COM object.<br/>         | | <dl> <dt>**SEL\_MULTICHAR**</dt> </dl>   | More than one character of text.<br/> | | <dl> <dt>**SEL\_MULTIOBJECT**</dt> </dl> | More than one COM object.<br/>        |</para>
            </returns>
            <remarks>This message is useful during [**WM\_SIZE**](/windows/desktop/winmsg/wm-size) processing for the parent of a bottomless rich edit control.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETBKGNDCOLOR">
            <summary>The EM\_SETBKGNDCOLOR message sets the background color for a rich edit control.</summary>
            <returns>This message returns the original background color.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setbkgndcolor">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETCHARFORMAT">
            <summary>Sets character formatting in a rich edit control.</summary>
            <returns>
            <para>If the operation succeeds, the return value is a nonzero value. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>If this message is sent more than once with the same parameters, the effect on the text is toggled. That is, sending the message once produces the effect, sending the message twice cancels the effect, and so forth.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETEVENTMASK">
            <summary>Sets the event mask for a rich edit control. The event mask specifies which notification codes the control sends to its parent window.</summary>
            <returns>This message returns the previous event mask.</returns>
            <remarks>The default event mask (before any is set) is ENM\_NONE.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETOLECALLBACK">
            <summary>Gives a rich edit control an IRichEditOleCallback object that the control uses to get OLE-related resources and information from the client.</summary>
            <returns>
            <para>If the operation succeeds, the return value is a nonzero value. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setolecallback">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETPARAFORMAT">
            <summary>Sets the paragraph formatting for the current selection in a rich edit control.</summary>
            <returns>
            <para>If the operation succeeds, the return value is a nonzero value. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setparaformat">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETTARGETDEVICE">
            <summary>Sets the target device and line width used for \ 0034;what you see is what you get \ 0034; (WYSIWYG) formatting in a rich edit control.</summary>
            <returns>The return value is zero if the operation fails, or nonzero if it succeeds.</returns>
            <remarks>
            <para>The HDC for the default printer can be obtained as follows.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-settargetdevice#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_STREAMIN">
            <summary>Replaces the contents of a rich edit control with a stream of data provided by an application defined \ 8211;EditStreamCallback callback function.</summary>
            <returns>This message returns the number of characters read.</returns>
            <remarks>When you send an **EM\_STREAMIN** message, the rich edit control makes repeated calls to the [*EditStreamCallback*](/windows/desktop/api/Richedit/nc-richedit-editstreamcallback) function specified by the **pfnCallback** member of the [**EDITSTREAM**](/windows/desktop/api/Richedit/ns-richedit-editstream) structure. Each time the callback function is called, it fills a buffer with data to read into the control. This continues until the callback function indicates that the stream-in operation has been completed or an error occurs.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_STREAMOUT">
            <summary>Causes a rich edit control to pass its contents to an application \ 8211;defined EditStreamCallback callback function. The callback function can then write the stream of data to a file or any other location that it chooses.</summary>
            <returns>This message returns the number of characters written to the data stream.</returns>
            <remarks>When you send an **EM\_STREAMOUT** message, the rich edit control makes repeated calls to the [*EditStreamCallback*](/windows/desktop/api/Richedit/nc-richedit-editstreamcallback) function specified by the **pfnCallback** member of the [**EDITSTREAM**](/windows/desktop/api/Richedit/ns-richedit-editstream) structure. Each time it calls the callback function, the control passes a buffer containing a portion of the contents of the control. This process continues until the control has passed all its contents to the callback function, or until an error occurs.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETTEXTRANGE">
            <summary>Retrieves a specified range of characters from a rich edit control.</summary>
            <returns>The message returns the number of characters copied, not including the terminating null character.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-gettextrange">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_FINDWORDBREAK">
            <summary>Finds the next word break before or after the specified character position or retrieves information about the character at that position.</summary>
            <returns>
            <para>The message returns a value based on the *wParam* parameter.</para>
            <para>| Return code                                                                                    | Description                                                                                                            | |------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**wParam**</dt> </dl>          | Return Value<br/>                                                                                                | | <dl> <dt>**WB\_CLASSIFY**</dt> </dl>    | Returns the character class and word-break flags of the character at the specified position.<br/>                | | <dl> <dt>**WB\_ISDELIMITER**</dt> </dl> | Returns **TRUE** if the character at the specified position is a delimiter; otherwise it returns **FALSE**.<br/> | | <dl> <dt>**Others**</dt> </dl>          | Returns the character index of the word break.<br/>                                                              |</para>
            </returns>
            <remarks>
            <para>If *wParam* is WB\_LEFT and WB\_RIGHT, the word-break procedure finds word breaks only after delimiters. This matches the functionality of an edit control. If *wParam* is WB\_MOVEWORDLEFT or WB\_MOVEWORDRIGHT, the word-break procedure also compares character classes and word-break flags. For information about character classes and word-break flags, see [Word and Line Breaks](using-rich-edit-controls.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-findwordbreak#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETOPTIONS">
            <summary>Sets the options for a rich edit control.</summary>
            <returns>This message returns the current options of the edit control.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setoptions">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETOPTIONS">
            <summary>Retrieves rich edit control options.</summary>
            <returns>This message returns a combination of the current option flag values described in the [**EM\_SETOPTIONS**](em-setoptions.md) message.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getoptions">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_FINDTEXTEX">
            <summary>EM_FINDTEXTEX message - Finds text within a rich edit control.</summary>
            <returns>If the target string is found, the return value is the zero-based position of the first character of the match. If the target is not found, the return value is -1.</returns>
            <remarks>
            <para>Use this message to find ANSI strings. For Unicode, use [**EM\_FINDTEXTEXW**](em-findtextexw.md). The **cpMin** member of **FINDTEXTEX.chrg** always specifies the starting-point of the search, and **cpMax** specifies the end point. When searching backward, **cpMin** must be equal to or greater than **cpMax**. When searching forward, a value of -1 in **cpMax** extends the search range to the end of the text. If the search operation finds a match, the **chrgText** member of the [**FINDTEXTEX**](/windows/desktop/api/Richedit/ns-richedit-findtextexa) structure returns the range of character positions that contains the matching text.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-findtextex#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETWORDBREAKPROCEX">
            <summary>Retrieves the address of the currently registered extended word-break procedure for a rich edit control.</summary>
            <returns>The message returns the address of the current procedure.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getwordbreakprocex">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETWORDBREAKPROCEX">
            <summary>Sets the extended word-break procedure for a rich edit control.</summary>
            <returns>This message returns the address of the previous extended word-break procedure.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setwordbreakprocex">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETUNDOLIMIT">
            <summary>Sets the maximum number of actions that can stored in the undo queue of a rich edit control.</summary>
            <returns>The return value is the new maximum number of undo actions for the rich edit control. This value may be less than *wParam* if memory is limited.</returns>
            <remarks>
            <para>By default, the maximum number of actions in the undo queue is 100. If you increase this number, there must be enough available memory to accommodate the new number. For better performance, set the limit to the smallest possible value. Setting the limit to zero disables the **Undo** feature.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setundolimit#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_REDO">
            <summary>Sends an EM\_REDO message to a rich edit control to redo the next action in the control's redo queue.</summary>
            <returns>
            <para>If the **Redo** operation succeeds, the return value is a nonzero value. If the **Redo** operation fails, the return value is zero.</para>
            </returns>
            <remarks>To determine whether there are any actions in the control's redo queue, send the [**EM\_CANREDO**](em-canredo.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_CANREDO">
            <summary>Determines whether there are any actions in the control redo queue.</summary>
            <returns>
            <para>If there are actions in the control redo queue, the return value is a nonzero value. If the redo queue is empty, the return value is zero.</para>
            </returns>
            <remarks>To redo the most recent undo operation, send the [**EM\_REDO**](em-redo.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETUNDONAME">
            <summary>Microsoft Rich Edit 2.0 and later Retrieves the type of the next undo action, if any.Microsoft Rich Edit 1.0 This message is not supported.</summary>
            <returns>
            <para>If there is an undo action, the value returned is an [**UNDONAMEID**](/windows/desktop/api/Richedit/ne-richedit-undonameid) enumeration value that indicates the type of the next action in the control's undo queue. If there are no actions that can be undone or the type of the next undo action is unknown, the return value is zero.</para>
            </returns>
            <remarks>The types of actions that can be undone or redone include typing, delete, drag, drop, cut, and paste operations. This information can be useful for applications that provide an extended user interface for undo and redo operations, such as a drop-down list box of actions that can be undone.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETREDONAME">
            <summary>Retrieves the type of the next action, if any, in the rich edit control's redo queue.</summary>
            <returns>
            <para>If the redo queue for the control is not empty, the value returned is an [**UNDONAMEID**](/windows/desktop/api/Richedit/ne-richedit-undonameid) enumeration value that indicates the type of the next action in the control's redo queue. If there are no redoable actions or the type of the next redoable action is unknown, the return value is zero.</para>
            </returns>
            <remarks>The types of actions that can be undone or redone include typing, delete, drag-drop, cut, and paste operations. This information can be useful for applications that provide an extended user interface for undo and redo operations, such as a drop-down list box of redoable actions.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_STOPGROUPTYPING">
            <summary>Stops a rich edit control from collecting additional typing actions into the current undo action. The control stores the next typing action, if any, into a new action in the undo queue.</summary>
            <returns>The return value is zero. This message cannot fail.</returns>
            <remarks>
            <para>A rich edit control groups consecutive typing actions, including characters deleted by using the **BackSpace** key, into a single undo action until one of the following events occurs: -   The control receives an **EM\_STOPGROUPTYPING** message. -   The control loses focus. -   The user moves the current selection, either by using the arrow keys or by clicking the mouse. -   The user presses the **Delete** key. -   The user performs any other action, such as a paste operation that does **not** involve typing. You can send the **EM\_STOPGROUPTYPING** message to break consecutive typing actions into smaller undo groups. For example, you could send **EM\_STOPGROUPTYPING** after each character or at each word break.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-stopgrouptyping#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETTEXTMODE">
            <summary>Sets the text mode or undo level of a rich edit control. The message fails if the control contains any text.</summary>
            <returns>
            <para>If the message succeeds, the return value is zero. If the message fails, the return value is a nonzero value.</para>
            </returns>
            <remarks>
            <para>In rich text mode, a rich edit control has standard rich edit functionality. However, in plain text mode, the control is similar to a standard edit control: -   The text in a plain text control can have only one format (such as Bold, 10pt Arial). -   The user cannot paste rich text formats, such as Rich Text Format (RTF) or embedded objects into a plain text control. -   Rich text mode controls always have a default end-of-document marker or carriage return, to format paragraphs. Plain text controls, on the other hand, do not need the default, end-of-document marker, so it is omitted. The control must contain no text when it receives the **EM\_SETTEXTMODE** message. To ensure there is no text, send a [**WM\_SETTEXT**](/windows/desktop/winmsg/wm-settext) message with an empty string ("").</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-settextmode#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETTEXTMODE">
            <summary>Gets the current text mode and undo level of a rich edit control.</summary>
            <returns>The return value is one or more values from the [**TEXTMODE**](/windows/win32/api/richedit/ne-richedit-textmode) enumeration type. The values indicate the current text mode and undo level of the control.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-gettextmode">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_AUTOURLDETECT">
            <summary>Enables or disables automatic detection of hyperlinks by a rich edit control.</summary>
            <returns>
            <para>If the message succeeds, the return value is zero. If the message fails, the return value is a nonzero value. For example, the message might fail due to insufficient memory, an invalid detection option, or an invalid scheme-name string. If *lParam* contains more than 50 scheme names, the message fails with a return value of **E\_INVALIDARG**.</para>
            </returns>
            <remarks>
            <para>If automatic URL detection is enabled (that is, *wParam* includes **AURL\_ENABLEURL**), the rich edit control scans any modified text to determine whether the text matches the format of a URL (or more generally in Windows 8 or later an IRI International Resource Identifier). If *lParam* is NULL, the control detects URLs that begin with the following scheme names: -   callto -   file -   ftp -   gopher -   http -   https -   mailto -   news -   notes -   nntp -   onenote -   outlook -   prospero -   tel -   telnet -   wais -   webcal When automatic link detection is enabled, the rich edit control removes the **CFE\_LINK** effect from modified text that does not have a format recognized by the control. If your application uses the **CFE\_LINK** effect to mark other types of text, do not enable automatic link detection. The rich edit control does not check whether a detected link exists; that responsibility belongs to the client. A rich edit control sends the [EN\_LINK](en-link.md) notification when it receives various messages while the mouse pointer is over text that has the **CFE\_LINK** effect. For more information, see [Automatic RichEdit Hyperlinks](/archive/blogs/murrays/automatic-richedit-hyperlinks) and [RichEdit Friendly Name Hyperlinks](/archive/blogs/murrays/richedit-friendly-name-hyperlinks).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-autourldetect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETAUTOURLDETECT">
            <summary>Indicates whether the auto URL detection is turned on in the rich edit control.</summary>
            <returns>
            <para>If auto-URL detection is active, the return value is 1. If auto-URL detection is inactive, the return value is 0.</para>
            </returns>
            <remarks>
            <para>When auto URL detection is on, Microsoft Rich Edit is constantly checking typed text for a valid URL. Rich Edit recognizes URLs that start with these prefixes: -   http: -   file: -   mailto: -   ftp: -   https: -   gopher: -   nntp: -   prospero: -   telnet: -   news: -   wais: -   outlook: Rich Edit also recognizes standard path names that start with \\\\. When Rich Edit locates a URL, it changes the URL text color, underlines the text, and notifies the client using [EN\_LINK](en-link.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getautourldetect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETPALETTE">
            <summary>Changes the palette that a rich edit control uses for its display window.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>The rich edit control does not check whether the new palette is valid.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETTEXTEX">
            <summary>Gets the text from a rich edit control.</summary>
            <returns>The return value is the number of **TCHAR**s copied into the output buffer, not including the null terminator.</returns>
            <remarks>
            <para>If the size of the output buffer is less than the size of the text in the control, the edit control will copy text from its beginning and place it in the buffer until the buffer is full. A terminating null character will still be placed at the end of the buffer. If ANSI text is requested, **EM\_GETTEXTEX** uses the [**WideCharToMultiByte**](/windows/desktop/api/stringapiset/nf-stringapiset-widechartomultibyte) function to translate the Unicode characters to ANSI. It allows you to go from Unicode to ANSI using a particular code page. The [**GETTEXTEX**](/windows/desktop/api/Richedit/ns-richedit-gettextex) structure contains members (**lpDefaultChar** and **lpUsedDefChar**) that are used in the translation from Unicode to ANSI.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-gettextex#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETTEXTLENGTHEX">
            <summary>Calculates text length in various ways. It is usually called before creating a buffer to receive the text from the control.</summary>
            <returns>The message returns the number of **TCHAR**s in the edit control, depending on the setting of the flags in the [**GETTEXTLENGTHEX**](/windows/desktop/api/Richedit/ns-richedit-gettextlengthex) structure. If incompatible flags were set in the **flags** member, the message returns E\_INVALIDARG .</returns>
            <remarks>This message is a fast and easy way to determine the number of characters in the Unicode version of the rich edit control. However, for a non-Unicode target code page you will potentially be converting to a combination of single-byte and double-byte characters.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SHOWSCROLLBAR">
            <summary>Shows or hides one of the scroll bars in the host window of a rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>This method is only valid when the control is in-place active. Calls made while the control is inactive may fail.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETTEXTEX">
            <summary>Combines the functionality of the WM\_SETTEXT and EM\_REPLACESEL messages, and adds the ability to set text using a code page and to use either rich text or plain text.</summary>
            <returns>
            <para>If the operation is setting all of the text and succeeds, the return value is 1. If the operation is setting the selection and succeeds, the return value is the number of bytes or characters copied. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-settextex">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETPUNCTUATION">
            <summary>Sets the punctuation characters for a rich edit control.</summary>
            <returns>
            <para>If the operation succeeds, the return value is a nonzero value. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setpunctuation">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETPUNCTUATION">
            <summary>Gets the current punctuation characters for the rich edit control.</summary>
            <returns>
            <para>If the operation succeeds, the return value is a nonzero value. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getpunctuation">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETWORDWRAPMODE">
            <summary>Sets the word-wrapping and word-breaking options for a rich edit control.</summary>
            <returns>This message returns the current word-wrapping and word-breaking options.</returns>
            <remarks>This message must not be sent by the application defined word breaking procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETWORDWRAPMODE">
            <summary>Gets the current word wrap and word-break options for the rich edit control.</summary>
            <returns>The message returns the current word wrap and word-break options.</returns>
            <remarks>This message must not be sent by the application-defined, word-break procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETIMECOLOR">
            <summary>Sets the Input Method Editor (IME) composition color for a rich edit control.</summary>
            <returns>
            <para>If the operation succeeds, the return value is a nonzero value. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setimecolor">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETIMECOLOR">
            <summary>Retrieves the Input Method Editor (IME) composition color.</summary>
            <returns>
            <para>If the operation succeeds, the return value is a nonzero value. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getimecolor">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETIMEOPTIONS">
            <summary>Sets the Input Method Editor (IME) options.</summary>
            <returns>
            <para>If the operation succeeds, the return value is a nonzero value. If the operation fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setimeoptions">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETIMEOPTIONS">
            <summary>Retrieves the current Input Method Editor (IME) options.</summary>
            <returns>This message returns one or more of the IME option flag values described in the [**EM\_SETIMEOPTIONS**](em-setimeoptions.md) message.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getimeoptions">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_CONVPOSITION">
            <summary>EM_CONVPOSITION message</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-convposition">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETLANGOPTIONS">
            <summary>Sets options for Input Method Editor (IME) and Asian language support in a rich edit control.</summary>
            <returns>This message returns a value of 1.</returns>
            <remarks>
            <para>The **EM\_SETLANGOPTIONS** message controls the following: -   Automatic font binding. -   Automatic keyboard switching. -   Automatic font size adjustment. -   Use of user-interface default fonts instead of document default fonts. -   Notifications to client during IME composition. -   How IME aborts composition mode. -   Spell checking, autocorrect, and touch keyboard prediction. This message sets the values of all language option flags. To change a subset of the flags, send the [**EM\_GETLANGOPTIONS**](em-getlangoptions.md) message to get the current option flags, change the flags that you need to change, and then send the **EM\_SETLANGOPTIONS** message with the result.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setlangoptions#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETLANGOPTIONS">
            <summary>Gets a rich edit control's option settings for Input Method Editor (IME) and Asian language support.</summary>
            <returns>
            <para>Returns the IME and Asian language settings, which can be zero or more of the following values.</para>
            <para>| Return code                                                                                                     | Description                                                                                                                                                                                                                                                                                                                                                                                                                   | |-----------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**IMF\_AUTOFONT**</dt> </dl>                    | If this flag is set, the control automatically changes fonts when the user explicitly changes to a different keyboard layout. It is useful to turn off **IMF\_AUTOFONT** for universal Unicode fonts. This option is turned on by default (1).<br/>                                                                                                                                                                     | | <dl> <dt>**IMF\_AUTOFONTSIZEADJUST**</dt> </dl>          | If this flag is set, the control scales font-bound font sizes from insertion point size according to script. For example, Asian fonts are slightly larger than Western ones. This option is turned on by default (1).<br/>                                                                                                                                                                                              | | <dl> <dt>**IMF\_AUTOKEYBOARD**</dt> </dl>                | If this flag is set, the control automatically changes the keyboard layout when the user explicitly changes to a different font, or when the user explicitly changes the insertion point to a new location in the text. Will be turned on automatically for bidirectional controls. For all other controls, it is turned off by default. This option is turned off by default (0).<br/>                                 | | <dl> <dt>**IMF\_DISABLEAUTOBIDIAUTOKEYBOARD**</dt> </dl> | **Windows 8**: If this flag is set, the control uses language neutral logic for automatic keyboard switching. This option is turned off by default (0).<br/>                                                                                                                                                                                                                                                            | | <dl> <dt>**IMF\_DUALFONT**</dt> </dl>                    | If this flag is set, the control uses dual-font mode. Used for Asian language support. The control uses an English font for ASCII text and a Asian font for Asian text. This option is turned on by default (1).<br/>                                                                                                                                                                                                   | | <dl> <dt>**IMF\_IMEALWAYSSENDNOTIFY**</dt> </dl>         | This flag controls how the rich edit control notifies the client during IME composition: <br/> 0: No [EN\_CHANGE](en-change.md) or [EN\_SELCHANGE](en-selchange.md) notifications during undetermined state. Send notification when the final string comes in. This is the default.<br/> 1: Send [EN\_CHANGE](en-change.md) and [EN\_SELCHANGE](en-selchange.md) events during undetermined state.<br/> | | <dl> <dt>**IMF\_IMECANCELCOMPLETE**</dt> </dl>           | This flag determines how the control uses the composition string of an IME if the user cancels it. If this flag is set, the control discards the composition string. If this flag is not set, the control uses the composition string as the result string. This option is turned off by default (0).<br/>                                                                                                              | | <dl> <dt>**IMF\_NOIMPLICITLANG**</dt> </dl>              | **Windows 8**: If this flag is set, disable stamping keyboard input with the keyboard language and ensuring that non-East Asian language IDss are compatible with the character repertoire. This option is turned off by default (0). <br/>                                                                                                                                                                             | | <dl> <dt>**IMF\_NOKBDLIDFIXUP**</dt> </dl>               | **Windows 8**: If this flag is set, the rich edit control disables stamping keyboard language on an empty control. This option is turned off by default (0).<br/>                                                                                                                                                                                                                                                       | | <dl> <dt>**IMF\_SPELLCHECKING**</dt> </dl>               | **Windows 8**: If this flag is set, the rich edit control turns on spell checking. This option is turned off by default (0). <br/>                                                                                                                                                                                                                                                                                      | | <dl> <dt>**IMF\_TKBAUTOCORRECTION**</dt> </dl>           | **Windows 8**: If this flag is set, enable touch keyboard autocorrect. This option is turned off by default (0). <br/>                                                                                                                                                                                                                                                                                                  | | <dl> <dt>**IMF\_TKBPREDICTION**</dt> </dl>               | **Windows 10**: Ignored.<br/> **Windows 8**: If this flag is set, the rich edit control enables touch keyboard prediction. This option is turned off by default (0). <br/>                                                                                                                                                                                                                                        | | <dl> <dt>**IMF\_UIFONTS**</dt> </dl>                     | Use user-interface default fonts. This option is turned off by default (0).<br/>                                                                                                                                                                                                                                                                                                                                        |</para>
            </returns>
            <remarks>The **IMF\_AUTOFONT** flag is set by default. The **IMF\_AUTOKEYBOARD** and **IMF\_IMECANCELCOMPLETE** flags are cleared by default.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETIMECOMPMODE">
            <summary>Retrieves the current Input Method Editor (IME) mode for a rich edit control.</summary>
            <returns>
            <para>The return value is one of the following values.</para>
            <para>| Return code                                                                                     | Description                  | |-------------------------------------------------------------------------------------------------|------------------------------| | <dl> <dt>**ICM\_NOTOPEN**</dt> </dl>     | IME is not open.<br/>  | | <dl> <dt>**ICM\_LEVEL3**</dt> </dl>      | True inline mode.<br/> | | <dl> <dt>**ICM\_LEVEL2**</dt> </dl>      | Level 2.<br/>          | | <dl> <dt>**ICM\_LEVEL2\_5**</dt> </dl>   | Level 2.5<br/>         | | <dl> <dt>**ICM\_LEVEL2\_SUI**</dt> </dl> | Special UI.<br/>       |</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getimecompmode">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_FINDTEXTW">
            <summary>EM_FINDTEXTW message - Finds Unicode text within a rich edit control.</summary>
            <returns>If the target string is found, the return value is the zero-based position of the first character of the match. If the target is not found, the return value is -1.</returns>
            <remarks>**EM\_FINDTEXTW** uses the [**FINDTEXTW**](/windows/win32/api/richedit/ns-richedit-findtexta) structure, while [**EM\_FINDTEXTEXW**](em-findtextexw.md) uses the [**FINDTEXTEXW**](/windows/desktop/api/Richedit/ns-richedit-findtextexa) structure. The difference is that **FINDTEXTEXW** reports back the range of text that was found.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_FINDTEXTEXW">
            <summary>EM_FINDTEXTEXW message - Finds Unicode text within a rich edit control.</summary>
            <returns>If the target string is found, the return value is the zero-based position of the first character of the match. If the target is not found, the return value is -1.</returns>
            <remarks>
            <para>Use this message to find Unicode strings. For ANSI;, use [**EM\_FINDTEXTEX**](em-findtextex.md). The **cpMin** member of **FINDTEXTEX.chrg** always specifies the starting-point of the search, and **cpMax** specifies the end point. When searching backward, **cpMin** must be equal to or greater than **cpMax**. When searching forward, a value of -1 in **cpMax** extends the search range to the end of the text. If the search operation finds a match, the **chrgText** member of the [**FINDTEXTEX**](/windows/desktop/api/Richedit/ns-richedit-findtextexa) structure returns the range of character positions that contains the matching text. **EM\_FINDTEXTEXW** uses the [**FINDTEXTEXW**](/windows/desktop/api/Richedit/ns-richedit-findtextexa) structure, while [**EM\_FINDTEXTW**](em-findtextw.md) uses the [**FINDTEXTW**](/windows/win32/api/richedit/ns-richedit-findtexta) structure. The difference is that **EM\_FINDTEXTEXW** reports the range of text that was found.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-findtextexw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_RECONVERSION">
            <summary>Invokes the Input Method Editor (IME) reconversion dialog box.</summary>
            <returns>This message always returns zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-reconversion">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETIMEMODEBIAS">
            <summary>Set the Input Method Editor (IME) mode bias for a rich edit control.</summary>
            <returns>This message returns the new IME mode bias setting.</returns>
            <remarks>
            <para>When the IME generates a list of alternative choices for a set of characters, this message sets the criteria by which some of the choices will appear at the top of the list. To set the Text Services Framework (TSF) mode bias, use [**EM\_SETCTFMODEBIAS**](em-setctfmodebias.md). The application should call [**EM\_ISIME**](em-isime.md) before calling this function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setimemodebias#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETIMEMODEBIAS">
            <summary>Retrieves the Input Method Editor (IME) mode bias for a Microsoft Rich Edit control.</summary>
            <returns>This message returns the current IME mode bias setting.</returns>
            <remarks>
            <para>To get the Text Services Framework mode bias, use [**EM\_GETCTFMODEBIAS**](em-getctfmodebias.md). The application should call [**EM\_ISIME**](em-isime.md) before calling this function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getimemodebias#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETBIDIOPTIONS">
            <summary>The EM\_SETBIDIOPTIONS message sets the current state of the bidirectional options in the rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The rich edit control must be in plain text mode or **EM\_SETBIDIOPTIONS** will not do anything. In plain text controls, **EM\_SETBIDIOPTIONS** automatically determines the paragraph direction and/or alignment based on the context rules. These rules state that the direction and/or alignment is derived from the first strong character in the control. A strong character is one from which text direction can be determined (see Unicode Standard version 2.0). The paragraph direction and/or alignment is applied to the default format. **EM\_SETBIDIOPTIONS** only switches the default paragraph format to RTL (right to left) if it finds an RTL character,</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setbidioptions#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETBIDIOPTIONS">
            <summary>Indicates the current state of the bidirectional options in the rich edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>This message sets the values of the **wMask** and **wEffects** members to the value of the current state of the bidirectional options in the rich edit control.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETTYPOGRAPHYOPTIONS">
            <summary>Sets the current state of the typography options of a rich edit control.</summary>
            <returns>Returns **TRUE** if *wParam* is valid, otherwise **FALSE**.</returns>
            <remarks>Advanced line breaking is turned on automatically by the rich edit control when needed, such as for handling complex scripts like Arabic and Hebrew, and for mathematics. It s also needed for justified paragraphs, hyphenation, and other typographic features.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETTYPOGRAPHYOPTIONS">
            <summary>Returns the current state of the typography options of a rich edit control.</summary>
            <returns>Returns the current typography options. For a list of options, see [**EM\_SETTYPOGRAPHYOPTIONS**](em-settypographyoptions.md).</returns>
            <remarks>You can turn on advanced line breaking by sending the [**EM\_SETTYPOGRAPHYOPTIONS**](em-settypographyoptions.md) message. Advanced and normal line breaking may also be turned on automatically by the rich edit control if it is needed for certain languages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETEDITSTYLE">
            <summary>Sets the current edit style flags for a rich edit control.</summary>
            <returns>The return value is the state of the edit style flags after the rich edit control has attempted to implement your edit style changes. The edit style flags are a set of flags that indicate the current edit style.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-seteditstyle">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETEDITSTYLE">
            <summary>Retrieves the current edit style flags.</summary>
            <returns>
            <para>Returns the current edit style flags, which can include one or more of the following values:</para>
            <para>| Return code | Description | |-------------|-------------| | <dl><dt><strong>SES_BEEPONMAXTEXT</strong></dt></dl> | Rich Edit will call the system beeper if the user attempts to enter more than the maximum characters.<br /> | | <dl><dt><strong>SES_BIDI</strong></dt></dl> | Turns on bidirectional processing. This is automatically turned on by Rich Edit if any of the following window styles are active: <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles"><strong>WS_EX_RIGHT</strong></a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles"><strong>WS_EX_RTLREADING</strong></a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles"><strong>WS_EX_LEFTSCROLLBAR</strong></a>. However, this setting is useful for handling these window styles when using a custom implementation of <a href="https://docs.microsoft.com/windows/desktop/api/Textserv/nl-textserv-itexthost"><strong>ITextHost</strong></a> (default: 0).<br /> | | <dl><dt><strong>SES_CTFALLOWEMBED</strong></dt></dl> | <strong>Windows XP with SP1</strong>: Allow embedded objects to be inserted using TSF (default: 0).<br /> | | <dl><dt><strong>SES_CTFALLOWPROOFING</strong></dt></dl> | <strong>Windows XP with SP1</strong>: Allows TSF proofing tips (default: 0).<br /> | | <dl><dt><strong>SES_CTFALLOWSMARTTAG</strong></dt></dl> | <strong>Windows XP with SP1</strong>: Allows TSF SmartTag tips (default: 0).<br /> | | <dl><dt><strong>SES_CTFNOLOCK</strong></dt></dl> | <strong>Windows 8</strong>: Do not allow the TSF lock read/write access. This pauses TSF input. <br /> | | <dl><dt><strong>SES_DEFAULTLATINLIGA</strong></dt></dl> | <strong>Windows 8</strong>: Fonts with an fi ligature are displayed with default OpenType features resulting in improved typography (default: 0). <br /> | | <dl><dt><strong>SES_DRAFTMODE</strong></dt></dl> | <strong>Windows XP with SP1</strong>: Use draft mode fonts to display text. Draft mode is an accessibility option where the control displays the text with a single font; the font is determined by the system setting for the font used in message boxes. For example, accessible users may read text easier if it is uniform, rather than a mix of fonts and styles (default: 0). <br /> | | <dl><dt><strong>SES_EMULATE10</strong></dt></dl> | <strong>Windows 8</strong>: Emulate RichEdit 1.0 behavior. <br /><blockquote>[!Note]<br />If you really want this behavior, use the Windows riched32.dll instead of riched20.dll or msftedit.dll. Riched32.dll had more functionality.</blockquote><br /> | | <dl><dt><strong>SES_EMULATESYSEDIT</strong></dt></dl> | When this bit is on, rich edit attempts to emulate the system edit control (default: 0).<br /> | | <dl><dt><strong>SES_EXTENDBACKCOLOR</strong></dt></dl> | Extends the background color all the way to the edges of the client rectangle (default: 0).<br /> | | <dl><dt><strong>SES_HIDEGRIDLINES</strong></dt></dl> | <strong>Windows XP with SP1</strong>: If the width of table gridlines is zero, gridlines are not displayed. This is equivalent to the hide gridlines feature in Word's table menu (default: 0).<br /> | | <dl><dt><strong>SES_HYPERLINKTOOLTIPS</strong></dt></dl> | <strong>Windows 8</strong>: When the cursor is over a link, display a tooltip with the target link address (default: 0). <br /> | | <dl><dt><strong>SES_LOGICALCARET</strong></dt></dl> | <strong>Windows 8</strong>: Provide logical caret information instead of a caret bitmap as described in <a href="https://docs.microsoft.com/windows/desktop/api/Textserv/nf-textserv-itexthost-txsetcaretpos"><strong>ITextHost::TxSetCaretPos</strong></a> (default: 0). <br /> | | <dl><dt><strong>SES_LOWERCASE</strong></dt></dl> | Converts all input characters to lowercase (default: 0).<br /> | | <dl><dt><strong>SES_MAPCPS</strong></dt></dl> | Obsolete. Do not use.<br /> | | <dl><dt><strong>SES_MULTISELECT</strong></dt></dl> | <strong>Windows 8</strong>: Enable multiselection with individual mouse selections made while the Ctrl key is pressed (default: 0). <br /> | | <dl><dt><strong>SES_NOEALINEHEIGHTADJUST</strong></dt></dl> | <strong>Windows 8</strong>: Do not adjust line height for East Asian text (default: 0 which adjusts the line height by 15%). <br /> | | <dl><dt><strong>SES_NOFOCUSLINKNOTIFY</strong></dt></dl> | Sends <a href="en-link.md">EN_LINK</a> notification from links that do not have focus.<br /> | | <dl><dt><strong>SES_NOIME</strong></dt></dl> | Disallows IMEs for this instance of the rich edit control (default: 0).<br /> | | <dl><dt><strong>SES_NOINPUTSEQUENCECHK</strong></dt></dl> | When this bit is on, rich edit does not verify the sequence of typed text. Some languages (such as Thai and Vietnamese) require verifying the input sequence order before submitting it to the backing store (default: 0).<br /> | | <dl><dt><strong>SES_SCROLLONKILLFOCUS</strong></dt></dl> | When KillFocus occurs, scroll to the beginning of the text (character position equal to 0) (default: 0).<br /> | | <dl><dt><strong>SES_SMARTDRAGDROP</strong></dt></dl> | <strong>Windows 8</strong>: Add or delete a space according to the context when dropping text (default: 0). <br /> | | <dl><dt><strong>SES_USECRLF</strong></dt></dl> | Obsolete. Do not use.<br /> | | <dl><dt><strong>SES_WORDDRAGDROP</strong></dt></dl> | <strong>Windows 8</strong>: If word select is active, ensure that the drop location is at a word boundary (default: 0). <br /> | | <dl><dt><strong>SES_UPPERCASE</strong></dt></dl> | Converts all input characters to uppercase (default: 0).<br /> | | <dl><dt><strong>SES_USEAIMM</strong></dt></dl> | Uses the Active IMM input method component that ships with Internet Explorer 4.0 or later (default: 0).<br /> | | <dl><dt><strong>SES_USEATFONT</strong></dt></dl> | <strong>Windows XP with SP1</strong>: Uses an @ font, which is designed for vertical text; this is used with the <a href="rich-edit-control-styles.md"><strong>ES_VERTICAL</strong></a> window style. The name of an @ font begins with the @ symbol, for example, "@Batang" (default: 0, but is automatically turned on for vertical text layout). <br /> | | <dl><dt><strong>SES_USECTF</strong></dt></dl> | <strong>Windows XP with SP1</strong>: Turns on TSF support. (default: 0)<br /> | | <dl><dt><strong>SES_XLTCRCRLFTOCR</strong></dt></dl> | Turns on translation of CRCRLFs to CRs. When this bit is on and a file is read in, all instances of CRCRLF will be converted to hard CRs internally. This will affect the text wrapping. Note that if such a file is saved as plain text, the CRs will be replaced by CRLFs. This is the .txt standard for plain text (default: 0, which deletes CRCRLFs on input). <br /> |</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-geteditstyle">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETSCROLLPOS">
            <summary>Obtains the current scroll position of the edit control.</summary>
            <returns>This message always returns 1.</returns>
            <remarks>The values returned in the [**POINT**](/windows/win32/api/windef/ns-windef-point) structure are 16-bit values (even in the 32-bit wide fields).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETSCROLLPOS">
            <summary>Scrolls the contents of a rich edit control to the specified point.</summary>
            <returns>This message always returns 1.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setscrollpos">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Windows.Win32.PInvokeCore.EM_SETFONTSIZE" -->
        <member name="F:Windows.Win32.PInvokeCore.EM_GETZOOM">
            <summary>Gets the current zoom ratio. The zoom ration is always between 1/64 and 64. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>The message returns **TRUE** if message is processed, which it will be if both *wParam* and *lParam* are not **NULL**.</returns>
            <remarks>**Edit:** Supported in Windows 10 1809 and later. The edit control needs to have the **ES\_EX\_ZOOMABLE** extended style set, for this message to have an effect, see [Edit Control Extended Styles](edit-control-window-extended-styles.md). For information about the edit control, see [Edit Controls](edit-controls.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETZOOM">
            <summary>Sets the zoom ratio. The ratio must be a value between 1/64 and 64. You can send this message to either an edit control or a rich edit control.</summary>
            <returns>
            <para>If the new zoom setting is accepted, the return value is **TRUE**. If the new zoom setting is not accepted, the return value is **FALSE**.</para>
            </returns>
            <remarks>**Edit:** Supported in Windows 10 1809 and later. The edit control needs to have the **ES\_EX\_ZOOMABLE** extended style set, for this message to have an effect, see [Edit Control Extended Styles](edit-control-window-extended-styles.md). For information about the edit control, see [Edit Controls](about-edit-controls.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETHYPHENATEINFO">
            <summary>Retrieves information about hyphenation for a Microsoft Rich Edit control.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-gethyphenateinfo">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETHYPHENATEINFO">
            <summary>Sets the way a rich edit control does hyphenation.</summary>
            <remarks>
            <para>> [!Note] > To enable hyphenation, the client must call [**EM\_SETTYPOGRAPHYOPTIONS**](em-settypographyoptions.md), specifying TO\_ADVANCEDTYPOGRAPHY.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-sethyphenateinfo#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETPAGEROTATE">
            <summary>Gets the text layout for a Microsoft Rich Edit control.</summary>
            <returns>Gets the current text layout. For a list of possible text layout values, see [**EM\_SETPAGEROTATE**](em-setpagerotate.md).</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getpagerotate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETPAGEROTATE">
            <summary>Sets the text layout for a rich edit control.</summary>
            <returns>Return value is the new text layout value.</returns>
            <remarks>This message sets the text layout for the entire document. However, embedded contents are not rotated and must be rotated separately by the application.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETCTFMODEBIAS">
            <summary>Gets the Text Services Framework mode bias values for a Microsoft Rich Edit control.</summary>
            <returns>The current Text Services Framework mode bias value.</returns>
            <remarks>To get the IME mode bias, call [**EM\_GETIMEMODEBIAS**](em-getimemodebias.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETCTFMODEBIAS">
            <summary>Sets the Text Services Framework (TSF) mode bias for a rich edit control.</summary>
            <returns>If successful, the return value is the new TSF mode bias value. If unsuccessful, the return value is the old TSF mode bias value.</returns>
            <remarks>
            <para>When a Microsoft Rich Edit application uses TSF, it can select the TSF mode bias. This message sets the criteria by which an alternative choice appears at the top of the list for selection. To set the mode bias for the Input Method Editor (IME), use [**EM\_SETIMEMODEBIAS**](em-setimemodebias.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setctfmodebias#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETCTFOPENSTATUS">
            <summary>Determines if the Text Services Framework (TSF) keyboard is open or closed.</summary>
            <returns>If the TSF keyboard is open, the return value is **TRUE**. Otherwise, it is **FALSE**.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getctfopenstatus">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETCTFOPENSTATUS">
            <summary>Opens or closes the Text Services Framework (TSF) keyboard.</summary>
            <returns>If successful, this message returns **TRUE**. If unsuccessful, this message returns **FALSE**.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setctfopenstatus">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETIMECOMPTEXT">
            <summary>Retrieves the Input Method Editor (IME) composition text.</summary>
            <returns>If successful, the return value is the number of Unicode characters copied to the buffer. Otherwise, it is zero.</returns>
            <remarks>
            <para>This message only takes Unicode strings. **Security Warning:** Be sure to have a buffer sufficient for the size of the input. Failure to do so could cause problems for your application.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getimecomptext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_ISIME">
            <summary>Determine with a rich edit control's current input locale is an East Asian locale.</summary>
            <returns>Returns **TRUE** if it is an East Asian locale. Otherwise, it returns **FALSE**.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-isime">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETIMEPROPERTY">
            <summary>Retrieves the property and capabilities of the Input Method Editor (IME) associated with the current input locale.</summary>
            <returns>Returns the property or capability value, depending on the value of the *lParam* parameter. For more information, see the Remarks.</returns>
            <remarks>
            <para>If *wParam* is IGP\_PROPERTY, it returns one or more of the following values.</para>
            <para>| Requirement | Value | |-------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | IME\_PROP\_AT\_CARET                | If set, conversion window is at the caret position. If clear, the window is near caret position.                                                                                                                                                                  | | IME\_PROP\_SPECIAL\_UI              | If set, IME has a nonstandard user interface. The application should not draw in the IME window.                                                                                                                                                                  | | IME\_PROP\_CANDLIST\_START\_FROM\_1 | If set, strings in the candidate list are numbered starting at 1. If clear, strings start at zero.                                                                                                                                                                | | IME\_PROP\_UNICODE                  | If set, the IME is viewed as a UnicodeIME. The system and the IME will communicate through the UnicodeIME interface. If clear, IME will use the ANSI interface to communicate with the system.                                                                    | | IME\_PROP\_COMPLETE\_ON\_UNSELECT   | If set, conversion window is at the caret position. If clear, the window is near caret position.                                                                                                                                                                  | | IME\_PROP\_ACCEPT\_WIDE\_VKEY       | If set, the IME processes the injected Unicode that came from the [**SendInput**](/windows/desktop/api/winuser/nf-winuser-sendinput) function by using VK\_PACKET. If clear, the IME might not process the injected Unicode, and the injected Unicode might be sent to the application directly. |</para>
            <para>If *wParam* is IGP\_UI, it returns one or more of the following values.</para>
            <para>| Requirement | Value | |-----------------|-------------------------------------------------------------------------------------------------------| | UI\_CAP\_2700   | Supports text escapement values of 0 or 2700. For more information, see **lfEscapement**.             | | UI\_CAP\_ROT90  | Supports text escapement values of 0, 900, 1800, or 2700. For more information, see **lfEscapement**. | | UI\_CAP\_ROTANY | Supports any text escapement value. For more information, see **lfEscapement**.                       |</para>
            <para>If *wParam* is IGP\_SETCOMPSTR, it returns one or more of the following values.</para>
            <para>| Requirement | Value | |------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | SCS\_CAP\_COMPSTR            | Can create the composition string by calling the [**ImmSetCompositionString**](/windows/desktop/api/imm/nf-imm-immsetcompositionstringa) function with the SCS\_SETSTR value.                                                      | | SCS\_CAP\_MAKEREAD           | Can create the reading string from corresponding composition string when using the [**ImmSetCompositionString**](/windows/desktop/api/imm/nf-imm-immsetcompositionstringa) function with SCS\_SETSTR and without setting *lpRead*. | | SCS\_CAP\_SETRECONVERTSTRING | This IME can support reconversion. Use [**ImmSetCompositionString**](/windows/desktop/api/imm/nf-imm-immsetcompositionstringa) to do the reconversion.                                                                             |</para>
            <para>If *wParam* is IGP\_SELECT, it returns one or more of the following values.</para>
            <para>| Requirement | Value | |-----------------------|------------------------------------------------------| | SELECT\_CAP\_CONVMODE | Inherits conversion mode when a new IME is selected. | | SELECT\_CAP\_SENTENCE | Inherits sentence mode when a new IME is selected.   |</para>
            <para>If *wParam* is IGP\_GETIMEVERSION, it returns one or more of the following values.</para>
            <para>| Requirement | Value | |--------------|---------------------------------------------| | IMEVER\_0310 | The IME was created for Windows 3.1.        | | IMEVER\_0400 | The IME was created for Windows 95 or later |</para>
            <para>This message is similar to [**ImmGetProperty**](/windows/desktop/api/imm/nf-imm-immgetproperty), except that it uses the current input locale. The application should call [**EM\_ISIME**](em-isime.md) before calling this function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getimeproperty#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_INSERTTABLE">
            <summary>Inserts one or more identical table rows with empty cells.</summary>
            <returns>Returns S\_OK if the table is inserted, or an error code if not.</returns>
            <remarks>
            <para>If the **cpStartRow** member of the [**TABLEROWPARMS**](/windows/desktop/api/Richedit/ns-richedit-tablerowparms) is –1, this message deletes the selected text (if any), and then inserts empty table rows with the row and cell parameters given by *wParam* and *lParam*. It leaves the selection pointing to the start of the first cell in the first row. The client can then populate the table cells by pointing the selection (or an [**ITextRange**](/windows/desktop/api/Tom/nn-tom-itextrange)) to the various cell end marks and inserting and formatting the desired text. Such text can include nested table rows. Alternatively, if the **cpStartRow** member of the **TABLEROWPARMS** is 0 or greater, table rows are inserted at the character position given by **cpStartRow**. This only changes the current selection if the table is inserted inside the selected text. A Microsoft Rich Edit table consists of a sequence of table rows which, in turn, consist of sequences of paragraphs. A table row starts with the special two-character delimiter paragraph U+FFF9 U+000D and ends with the two-character delimiter paragraph U+FFFB U+000D. Each cell is terminated by the cell mark U+0007, which is treated as a hard end-of-paragraph mark just as U+000D (CR) is. The table row and cell parameters are treated as special paragraph formatting of the table-row delimiters. The formatting contains the information in the [**TABLEROWPARMS**](/windows/desktop/api/Richedit/ns-richedit-tablerowparms) structure. The cell parameters given by the [**TABLECELLPARMS**](/windows/desktop/api/Richedit/ns-richedit-tablecellparms) structure are stored in an expanded version of the tabs array. This format allows tables to be nested within other tables, up to fifteen levels deep.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-inserttable#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETAUTOCORRECTPROC">
            <summary>Gets a pointer to the application-defined AutoCorrectProc function.</summary>
            <returns>Returns a pointer to the application-defined [*AutoCorrectProc*](/windows/desktop/api/Richedit/nc-richedit-autocorrectproc) function.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getautocorrectproc">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETAUTOCORRECTPROC">
            <summary>Defines the current autocorrect callback procedure.</summary>
            <returns>If the operation succeeds, the return value is zero. If the operation fails, the return value is a nonzero value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setautocorrectproc">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_CALLAUTOCORRECTPROC">
            <summary>Calls the autocorrect callback function that is stored by the EM\_SETAUTOCORRECTPROC message, provided that the text preceding the insertion point is a candidate for autocorrection.</summary>
            <returns>The return value is zero if the message succeeds, or nonzero if an error occurs.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-callautocorrectproc">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETTABLEPARMS">
            <summary>Retrieves the table parameters for a table row and the cell parameters for the specified number of cells.</summary>
            <returns>
            <para>Returns S\_OK if successful, or one of the following error codes.</para>
            <para>| Return code                                                                                    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                | |------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**E\_FAIL** </dt> </dl>        | Changes cannot be made. This can occur if the control is a plain-text or single-line control, or if the insertion point is inside a math object. It also occurs if tables are disabled if the [**EM\_SETEDITSTYLEEX**](em-seteditstyleex.md) message sets the **SES\_EX\_NOTABLE** value. <br/>                                                                                                                                                                     | | <dl> <dt>**E\_INVALIDARG**</dt> </dl>   | The *wParam* or *lParam* is NULL or points to an invalid structure. The **cbRow** member of the [**TABLEROWPARMS**](/windows/desktop/api/Richedit/ns-richedit-tablerowparms) structure must equal `sizeof(TABLEROWPARMS)` or sizeof(TABLEROWPARMS)   2\*sizeof(long). The latter value is the size of the RichEdit 4.1 **TABLEROWPARMS** structure. The **cbCell** member of the **TABLEROWPARMS** structure must equal `sizeof(TABLECELLPARMS)`. The query character position must be at a table row delimiter. | | <dl> <dt>**E\_OUTOFMEMORY** </dt> </dl> | Insufficient memory is available.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                               |</para>
            </returns>
            <remarks>
            <para>This message gets the table parameters for the row at the character position specified by the **cpStartRow** member of the [**TABLEROWPARMS**](/windows/desktop/api/Richedit/ns-richedit-tablerowparms) structure, and the number of cells specified by the **cCells** member of the [**TABLECELLPARMS**](/windows/desktop/api/Richedit/ns-richedit-tablecellparms) structure. The character position specified by the **cpStartRow** member of the [**TABLEROWPARMS**](/windows/desktop/api/Richedit/ns-richedit-tablerowparms) structure should be at the start of the table row, or at the end delimiter of the table row. If **cpStartRow** is set to  1, the character position is given by the current selection. In this case, position the selection at the end of the row (between the cell mark and the end delimiter of the table row), or select the row.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-gettableparms#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETEDITSTYLEEX">
            <summary>Sets the current extended edit style flags.</summary>
            <returns>The return value is the state of the extended edit style flags after rich edit has attempted to implement your edit style changes. The edit style flags are a set of flags that indicate the current edit style.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-seteditstyleex">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETEDITSTYLEEX">
            <summary>Retrieves the current extended edit style flags.</summary>
            <returns>
            <para>Returns the extended edit style flags, which can include one or more of the following values.</para>
            <para>| Return code                                                                                                | Description                                                                                                                                                                                                                                                  | |------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**SES\_EX\_HANDLEFRIENDLYURL**</dt> </dl>  | Display friendly name links with the same text color and underlining as automatic links, provided that temporary formatting isn t used or uses text autocolor (default: 0).<br/>                                                                       | | <dl> <dt>**SES\_EX\_MULTITOUCH**</dt> </dl>         | Enable touch support in Rich Edit. This includes selection, caret placement, and context-menu invocation. When this flag is not set, touch is emulated by mouse commands, which do not take touch-mode specifics into account (default: 0). <br/>      | | <dl> <dt>**SES\_EX\_NOACETATESELECTION**</dt> </dl> | Display selected text using classic Windows selection text and background colors instead of background acetate color (default: 0). <br/>                                                                                                               | | <dl> <dt>**SES\_EX\_NOMATH**</dt> </dl>             | Disable insertion of math zones (default: 1). To enable math editing and display, send the [**EM\_SETEDITSTYLEEX**](em-seteditstyleex.md) message with *wParam* set to 0, and *lParam* set to **SES\_EX\_NOMATH**. <br/>                              | | <dl> <dt>**SES\_EX\_NOTABLE**</dt> </dl>            | Disable insertion of tables. The [**EM\_INSERTTABLE**](em-inserttable.md) message returns **E\_FAIL** and RTF tables are skipped (default: 0). <br/>                                                                                                  | | <dl> <dt>**SES\_EX\_USESINGLELINE**</dt> </dl>      | Enable a multiline control to act like a single-line control with the ability to scroll vertically when the single-line height is greater than the window height (default: 0). <br/>                                                                   | | <dl> <dt>**SES\_HIDETEMPFORMAT**</dt> </dl>         | Hide temporary formatting that is created when [**ITextFont.Reset**](/windows/desktop/api/Tom/nf-tom-itextfont-reset) is called with **tomApplyTmp**. For example, such formatting is used by spell checkers to display a squiggly underline under possibly misspelled words.<br/> | | <dl> <dt>**SES\_EX\_USEMOUSEWPARAM**</dt> </dl>     | Use *wParam* when handling the [**WM\_MOUSEMOVE**](/windows/desktop/inputdev/wm-mousemove) message and do not call [**GetAsyncKeyState**](/windows/desktop/api/winuser/nf-winuser-getasynckeystate).<br/>                                                                                              |</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-geteditstyleex">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETSTORYTYPE">
            <summary>Gets the story type.</summary>
            <returns>
            <para>Returns the story type, which can be a client-defined custom value, or one of the following values: <dl> <dt> **[**tomCommentsStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomEndnotesStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomEvenPagesFooterStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomEvenPagesHeaderStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomFindStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomFirstPageFooterStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomFirstPageHeaderStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomFootnotesStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomMainTextStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomPrimaryFooterStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomPrimaryHeaderStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomReplaceStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomScratchStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomTextFrameStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> <dt> **[**tomUnknownStory**](/windows/win32/api/tom/ne-tom-tomconstants)** </dt> </dl></para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getstorytype">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETSTORYTYPE">
            <summary>Sets the story type.</summary>
            <returns>The story type that was set.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setstorytype">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETELLIPSISMODE">
            <summary>Retrieves the current ellipsis mode.</summary>
            <returns>If wparam is 0 and lparam is not NULL, the return value equals TRUE; otherwise, the return value equals FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getellipsismode">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETELLIPSISMODE">
            <summary>This message sets the current ellipsis mode.</summary>
            <returns>If wparam is 0 and lparam is one of the values in the table above, the return value equals TRUE; otherwise, the return value equals FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setellipsismode">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETTABLEPARMS">
            <summary>Changes the parameters of rows in a table.</summary>
            <returns>
            <para>Returns S\_OK if successful, or one of the following error codes.</para>
            <para>| Return code                                                                                    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | |------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**E\_FAIL** </dt> </dl>        | Changes cannot be made. This can occur if the control is a plain-text or single-line control, or if the insertion point is inside a math object. It also occurs if tables are disabled, or if the [**EM\_SETEDITSTYLEEX**](em-seteditstyleex.md) message sets the **SES\_EX\_NOTABLE** value. <br/>                                                                                                                                                                                                                                                                              | | <dl> <dt>**E\_INVALIDARG**</dt> </dl>   | The *wParam* or *lParam* is NULL or points to an invalid structure. The **cCell** member of the [**TABLEROWPARMS**](/windows/desktop/api/Richedit/ns-richedit-tablerowparms) structure must be at least 1 and not more than 63. The **cbRow** member must equal `sizeof(TABLEROWPARMS)` or `sizeof(TABLEROWPARMS)   2*sizeof(long)`. The latter value is the size of the RichEdit 4.1 **TABLEROWPARMS** structure. The **cbCell** member of **TABLEROWPARMS** must equal `sizeof(TABLECELLPARMS)`. The insertion point must be at the start of a table or inside a table row, and the number of cells can only change by one. | | <dl> <dt>**E\_OUTOFMEMORY** </dt> </dl> | Insufficient memory is available.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |</para>
            </returns>
            <remarks>This message changes the parameters of the number of rows specified by the **cRow** member of the [**TABLEROWPARMS**](/windows/desktop/api/Richedit/ns-richedit-tablerowparms) structure, if the table has that many consecutive rows. If **cRow** is less than 0, the message iterates until the end of the table. If the new cell count differs from the current cell count by +1 or  1, it inserts or deletes the cell at the index specified by the **iCell** member of **TABLEROWPARMS**. The starting table row is identified by a character position. This position is specified by **cpStartRow** members with values that are greater than or equal to zero. The position should be inside the table row, but not inside a nested table, unless you want to change that table s parameters. If the **cpStartRow** member is  1, the character position is given by the current selection. For this, position the selection anywhere inside the table row, or select the row with the active end of the selection at the end of the table row.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETTOUCHOPTIONS">
            <summary>Retrieves the touch options that are associated with a rich edit control.</summary>
            <returns>Returns the value of the option specified by the *wParam* parameter. It is nonzero if *wParam* is **RTO\_SHOWHANDLES** and the touch grippers are visible; zero, otherwise.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-gettouchoptions">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETTOUCHOPTIONS">
            <summary>Sets the touch options associated with a rich edit control.</summary>
            <returns>This message returns zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-settouchoptions">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_INSERTIMAGE">
            <summary>Replaces the selection with a blob that displays an image.</summary>
            <returns>
            <para>Returns S\_OK if successful, or one of the following error codes.</para>
            <para>| Return code                                                                                    | Description                                                   | |------------------------------------------------------------------------------------------------|---------------------------------------------------------------| | <dl> <dt>**E\_FAIL** </dt> </dl>        | Cannot insert the image. <br/>                          | | <dl> <dt>**E\_INVALIDARG**</dt> </dl>   | The *lParam* parameter is NULL or points to an invalid image. | | <dl> <dt>**E\_OUTOFMEMORY** </dt> </dl> | Insufficient memory is available.<br/>                  |</para>
            </returns>
            <remarks>If the selection is an insertion point, the image blob is inserted at the insertion point.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_SETUIANAME">
            <summary>Sets the name of a rich edit control for UI Automation (UIA).</summary>
            <returns>TRUE if the name for UIA is successfully set, otherwise FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-setuianame">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.EM_GETELLIPSISSTATE">
            <summary>Retrieves the current ellipsis state.</summary>
            <returns>The return value is TRUE if an ellipsis is being displayed and FALSE otherwise.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/em-getellipsisstate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.IDI_APPLICATION">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfo">GetIconInfo</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconW</see>.</summary>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.IDI_HAND">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfo">GetIconInfo</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconW</see>.</summary>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.IDI_QUESTION">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfo">GetIconInfo</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconW</see>.</summary>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.IDI_EXCLAMATION">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfo">GetIconInfo</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconW</see>.</summary>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.IDI_ASTERISK">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfo">GetIconInfo</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconW</see>.</summary>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.IDI_WINLOGO">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfo">GetIconInfo</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoEx</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw">GetIconInfoExW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIcon</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconA</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">LoadIconW</see>, <see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw">LoadIconW</see>.</summary>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.IDI_SHIELD">
            <summary>Security Shield icon.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.IDI_WARNING">
            <summary>Exclamation point icon.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.IDI_ERROR">
            <summary>Hand-shaped icon.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.IDI_INFORMATION">
            <summary>Asterisk icon.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DDE_INITIATE">
            <summary>A Dynamic Data Exchange (DDE) client application sends a WM\_DDE\_INITIATE message to initiate a conversation with a server application responding to the specified application and topic names.</summary>
            <remarks>If the low-order word of *lParam* is **NULL**, any server application can respond. If the high-order word of *lParam* is **NULL**, any topic is valid. Upon receiving a **WM\_DDE\_INITIATE** request with the high-order word of the *lParam* parameter set to **NULL**, a server must send a [**WM\_DDE\_ACK**](wm-dde-ack.md) message for each of the topics it supports.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DDE_TERMINATE">
            <summary>A Dynamic Data Exchange (DDE) application (client or server) posts a WM\_DDE\_TERMINATE message to terminate a conversation. To post this message, call the PostMessage function with the following parameters.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DDE_ADVISE">
            <summary>A Dynamic Data Exchange (DDE) client application posts the WM\_DDE\_ADVISE message to a DDE server application to request the server to supply an update for a data item whenever the item changes.</summary>
            <remarks>If a client application supports more than one clipboard format for a single topic and item, it can post multiple **WM\_DDE\_ADVISE** messages for the topic and item, specifying a different clipboard format with each message. Note that a server can support multiple formats only for hot data links, not warm data links.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DDE_UNADVISE">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_UNADVISE message to inform a DDE server application that the specified item or a particular clipboard format for the item should no longer be updated.</summary>
            <remarks>
            <para>The client application allocates the high-order word of *lParam* by calling the [**GlobalAddAtom**](/windows/desktop/api/Winbase/nf-winbase-globaladdatoma) function. The server application posts the [**WM\_DDE\_ACK**](wm-dde-ack.md) message to respond positively or negatively. When posting **WM\_DDE\_ACK**, the server can either reuse the atom, or it can delete the atom and create a new one.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-dde-unadvise#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DDE_ACK">
            <summary>The WM\_DDE\_ACK message notifies a Dynamic Data Exchange (DDE) application of the receipt and processing of the following messages WM\_DDE\_POKE, WM\_DDE\_EXECUTE, WM\_DDE\_DATA, WM\_DDE\_ADVISE, WM\_DDE\_UNADVISE, WM\_DDE\_INITIATE, or WM\_DDE\_REQUEST (in some cases). To post this message, call the PostMessage function with the following parameters.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DDE_DATA">
            <summary>A Dynamic Data Exchange (DDE) server application posts a WM\_DDE\_DATA message to a DDE client application to pass a data item to the client or to notify the client of the availability of a data item.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DDE_REQUEST">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_REQUEST message to a DDE server application to request the value of a data item. To post this message, call the PostMessage function with the following parameters.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DDE_POKE">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_POKE message to a DDE server application.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DDE_EXECUTE">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_EXECUTE message to a DDE server application to send a string to the server to be processed as a series of commands.</summary>
            <remarks>
            <para>The command string is a null-terminated string consisting of one or more opcode strings enclosed in single brackets (\[ \]). Each opcode string has the following syntax, where the *parameters* list is optional: *opcode parameters* The *opcode* is any application-defined single token. It cannot include spaces, commas, parentheses, brackets, or quotation marks. The *parameters* list can contain any application-defined value or values. Multiple parameters are separated by commas, and the entire parameter list is enclosed in parentheses. Parameters cannot include commas or parentheses except inside a quoted string. If a bracket or parenthesis character is to appear in a quoted string, it need not be doubled, as was the case under the old rules. The following are valid command strings:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-dde-execute#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CTLCOLOR">
            <summary>The WM\_CTLCOLOR message is used in 16-bit versions of Windows to change the color scheme of list boxes, the list boxes of combo boxes, message boxes, button controls, edit controls, static controls, and dialog boxes.Note  For information related to this message and 32-bit versions of Windows, see Remarks.</summary>
            <returns>If an application processes this message, it returns a handle to a brush. The system uses the brush to paint the background of the control.</returns>
            <remarks>
            <para>The **WM\_CTLCOLOR** message from 16-bit Windows has been replaced by more specific notifications. These replacements include the following: -   [**WM\_CTLCOLORBTN**](../controls/wm-ctlcolorbtn.md) -   [**WM\_CTLCOLOREDIT**](../controls/wm-ctlcoloredit.md) -   [**WM\_CTLCOLORDLG**](../dlgbox/wm-ctlcolordlg.md) -   [**WM\_CTLCOLORLISTBOX**](../controls/wm-ctlcolorlistbox.md) -   [**WM\_CTLCOLORSCROLLBAR**](../controls/wm-ctlcolorscrollbar.md) -   [**WM\_CTLCOLORSTATIC**](../controls/wm-ctlcolorstatic.md)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/DevNotes/wm-ctlcolor-#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MOUSEHOVER">
            <summary>Posted to a window when the cursor hovers over the client area of the window for the period of time specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Hover tracking stops when **WM\_MOUSEHOVER** is generated. The application must call [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) again if it requires further tracking of mouse hover behavior. Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousehover#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MOUSELEAVE">
            <summary>Posted to a window when the cursor leaves the client area of the window specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>All tracking requested by [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) is canceled when this message is generated. The application must call **TrackMouseEvent** when the mouse reenters its window if it requires further tracking of mouse hover behavior.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CHOOSEFONT_GETLOGFONT">
            <summary>An application sends the WM\_CHOOSEFONT\_GETLOGFONT message to a Font dialog box to retrieve information about the user's current font selections.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The [**ChooseFont**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) function creates a **Font** dialog box. When the user closes the **Font** dialog box, the **ChooseFont** function returns information about the user's font selections in the [**CHOOSEFONT**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) structure. The **lpLogFont** member of the **CHOOSEFONT** structure is a pointer to a [**LOGFONT**](/windows/win32/api/wingdi/ns-wingdi-logfonta) structure. Use the **WM\_CHOOSEFONT\_GETLOGFONT** message to get information about the user's current font selections while the **Font** dialog box is open. For example, if you enable the **Apply** button in the **Font** dialog box, send the message to get the font information to apply to the current text selection. Typically, you enable a [*CFHookProc*](/windows/win32/api/commdlg/nc-commdlg-lpcfhookproc) hook procedure to process [**WM\_COMMAND**](/windows/desktop/menurc/wm-command) messages for the **Apply** button. When the user clicks the **Apply** button, the hook procedure sends the **WM\_CHOOSEFONT\_GETLOGFONT** message to the dialog box.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-choosefont-getlogfont#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CHOOSEFONT_SETLOGFONT">
            <summary>An application sends the WM\_CHOOSEFONT\_SETLOGFONT message to a Font dialog box to set the current logical font information.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>When you call the [**ChooseFont**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) function to create a **Font** dialog box, you can use the **lpLogFont** member of the [**CHOOSEFONT**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) structure to specify a [**LOGFONT**](/windows/win32/api/wingdi/ns-wingdi-logfonta) structure containing initial values for the dialog box. Use the **WM\_CHOOSEFONT\_SETLOGFONT** message to specify a **LOGFONT** structure with different values while the **Font** dialog box is open. Typically, you would send the **WM\_CHOOSEFONT\_SETLOGFONT** message from a [**CFHookProc**](/windows/win32/api/commdlg/nc-commdlg-lpcfhookproc) hook procedure. The hook procedure can also send the [**WM\_CHOOSEFONT\_GETLOGFONT**](wm-choosefont-getlogfont.md) and [**WM\_CHOOSEFONT\_SETFLAGS**](wm-choosefont-setflags.md) messages.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-choosefont-setlogfont#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CHOOSEFONT_SETFLAGS">
            <summary>An application sends the WM\_CHOOSEFONT\_SETFLAGS message to a Font dialog box to set the display options for the dialog box.</summary>
            <returns>No return value.</returns>
            <remarks>
            <para>The [**ChooseFont**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) function creates a **Font** dialog box and uses a [**CHOOSEFONT**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) structure to specify the initial values for the **Flags** member. Use the **WM\_CHOOSEFONT\_SETFLAGS** message to specify different values for the **Flags** member while the **Font** dialog box is open. Typically, you should send the **WM\_CHOOSEFONT\_SETFLAGS** message from a [**CFHookProc**](/windows/win32/api/commdlg/nc-commdlg-lpcfhookproc) hook procedure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-choosefont-setflags#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PSD_FULLPAGERECT">
            <summary>Notifies a PagePaintHook hook procedure of the coordinates of the sample page rectangle in the Page Setup dialog box. The dialog box sends this message when it is about to draw the contents of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box sends no more messages and does not draw in the sample page until the next time the system needs to redraw the sample page. If the hook procedure returns **FALSE**, the dialog box sends the remaining messages of the drawing sequence.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PSD_MINMARGINRECT">
            <summary>Notifies a PagePaintHook hook procedure of the coordinates of the margin rectangle in the sample page. A Page Setup dialog box sends this message when it is about to draw the contents of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box sends no more messages and does not draw in the sample page until the next time the system needs to redraw the sample page. If the hook procedure returns **FALSE**, the dialog box sends the remaining messages of the drawing sequence.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PSD_MARGINRECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw the margin rectangle of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the margin rectangle in the sample page. If the hook procedure returns **FALSE**, the dialog box draws the margin rectangle in the sample page.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PSD_GREEKTEXTRECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw Greek text inside the margin rectangle of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the Greek text portion of the sample page. If the hook procedure returns **FALSE**, the dialog box draws the Greek text portion of the sample page.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PSD_ENVSTAMPRECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw the envelope-stamp rectangle of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the envelope-stamp portion of the sample page. If the hook procedure returns **FALSE**, the dialog box draws the envelope-stamp portion of the sample page.</para>
            </returns>
            <remarks>
            <para>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure. A hook procedure receives this message only if the selected paper type is an envelope.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-psd-envstamprect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PSD_YAFULLPAGERECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw the return address portion of an envelope sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the return address portion of an envelope sample page. If the hook procedure returns **FALSE**, the dialog box draws the return address portion of an envelope sample page. If the paper type is not an envelope, the return value has no effect.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CPL_LAUNCH">
            <summary>WM_CPL_LAUNCH message - This message is not supported.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/shell/wm-cpl-launch">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CPL_LAUNCHED">
            <summary>WM_CPL_LAUNCHED message - This message is not supported.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/shell/wm-cpl-launched">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_TABLET_ADDED">
            <summary>The WM\_TABLET\_ADDED message is posted when a tablet device is added to Windows.</summary>
            <remarks>
            <para>This message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows. The indexes passed in *wParam* are related to the index used by the [**ITabletManager::GetTablet**](/previous-versions/windows/desktop/legacy/aa373683(v=vs.85)) method.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-added#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_TABLET_DELETED">
            <summary>The WM\_TABLET\_DELETED message is posted when a tablet device is removed from Windows.</summary>
            <remarks>
            <para>This message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows. The indexes passed in *wParam* are related to the index used by the [**ITabletManager::GetTablet**](/previous-versions/windows/desktop/legacy/aa373683(v=vs.85)) method.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-deleted#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_TABLET_FLICK">
            <summary>Sent when a user performs a pen flick. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>A pen flick is a unidirectional pen gesture that requires the user to contact the digitizer in a quick, straight flicking motion. A flick is characterized by high speed and a high degree of straightness. A flick is identified by its direction. Flicks can be made in eight directions corresponding to the cardinal and secondary compass directions. When a pen flick occurs, Windows first notifies an application by sending a **WM\_TABLET\_FLICK** message, which a window receives through its [*WindowProc*](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. Return the **FLICK\_WM\_HANDLED\_MASK** constant, described in [Flicks Constants](flicks-constants.md), to indicate that the application responded to the **WM\_TABLET\_FLICK** message. If the application does not return **FLICK\_WM\_HANDLED\_MASK**, Windows performs the default action specified in the flicks control panel by sending a follow-up notification, such as [**WM\_APPCOMMAND**](../inputdev/wm-appcommand.md), [**WM\_VSCROLL**](../controls/wm-vscroll.md), or [**WM\_KEYDOWN**](../inputdev/wm-keydown.md), depending on which action is associated with the pen flick. Use caution when handling the **WM\_TABLET\_FLICK** message. **WM\_TABLET\_FLICK** is passed via the [**SendMessageTimeout**](/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta) function. If you call methods on a COM interface, that object must be within the same process. If not, COM throws an exception.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-flick-message#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_TABLET_QUERYSYSTEMGESTURESTATUS">
            <summary>Sent when the system asks a window which system gestures it would like to receive.</summary>
            <remarks>
            <para>By handling this message, you can dynamically disable flicks for regions of a window. > [!Note] > The *lParam* can be converted to x-coordinates and y-coordinates by using the `GET_X_LPARAM` and `GET_Y_LPARAM` macros.</para>
            <para>By default, your window will receive all system gesture events. You can choose which events you would like your window to receive and which events you would like disabled by responding to the **WM\_TABLET\_QUERYSYSTEMGESTURESTATUS** message in your **WndProc**. The **WM\_TABLET\_QUERYSYSTEMGESTURESTATUS** message is defined in tpcshrd.h. The values to enable and disable system tablet system gestures are also defined in tpcshrd.h as follows: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-querysystemgesturestatus-message#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CONTEXTMENU">
            <summary>Notifies a window that the user clicked the right mouse button (right-clicked) in the window.</summary>
            <returns>No return value.</returns>
            <remarks>
            <para>A window can process this message by displaying a shortcut menu using the [**TrackPopupMenu**](/windows/desktop/api/Winuser/nf-winuser-trackpopupmenu) or [**TrackPopupMenuEx**](/windows/desktop/api/Winuser/nf-winuser-trackpopupmenuex) functions. To obtain the horizontal and vertical positions, use the following code.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-contextmenu#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_UNICHAR">
            <summary>The WM\_UNICHAR message can be used by an application to post input to other windows.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_UNICHAR** message is similar to [**WM\_CHAR**](wm-char.md), but it uses Unicode Transformation Format (UTF)-32, whereas **WM\_CHAR** uses UTF-16. This message is designed to send or post Unicode characters to ANSI windows and can handle Unicode Supplementary Plane characters. Because there is not necessarily a one-to-one correspondence between keys pressed and character messages generated, the information in the high-order word of the *lParam* parameter is generally not useful to applications. The information in the high-order word applies only to the most recent [**WM\_KEYDOWN**](wm-keydown.md) message that precedes the posting of the **WM\_UNICHAR** message. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the *lParam* parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-unichar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PRINTCLIENT">
            <summary>The WM\_PRINTCLIENT message is sent to a window to request that it draw its client area in the specified device context, most commonly in a printer device context.</summary>
            <remarks>
            <para>A window can process this message in much the same manner as [**WM\_PAINT**](./wm-paint.md), except that [**BeginPaint**](/windows/desktop/api/Winuser/nf-winuser-beginpaint) and [**EndPaint**](/windows/desktop/api/Winuser/nf-winuser-endpaint) need not be called (a device context is provided), and the window should draw its entire client area rather than just the invalid region. Windows that can be used anywhere in the system, such as controls, should process this message. It is probably worthwhile for other windows to process this message as well because it is relatively easy to implement. The [AnimateWindow](/windows/desktop/api/winuser/nf-winuser-animatewindow) function requires that the window being animated implements the **WM\_PRINTCLIENT** message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-printclient#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NOTIFY">
            <summary>Sent by a common control to its parent window when an event has occurred or the control requires some information.</summary>
            <returns>The return value is ignored except for notification messages that specify otherwise.</returns>
            <remarks>
            <para>The destination of the message must be the **HWND** of the parent of the control. This value can be obtained by using [**GetParent**](/windows/desktop/api/winuser/nf-winuser-getparent), as shown in the following example, where *m\_controlHwnd* is the **HWND** of the control itself.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-notify#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DEVICECHANGE">
            <summary>Notifies an application of a change to the hardware configuration of a device or the computer.</summary>
            <returns>
            <para>Return **TRUE** to grant the request. Return **BROADCAST\_QUERY\_DENY** to deny the request.</para>
            </returns>
            <remarks>For devices that offer software-controllable features, such as ejection and locking, the system typically sends a [DBT\_DEVICEREMOVEPENDING](dbt-deviceremovepending.md) message to let applications and device drivers end their use of the device gracefully. If the system forcibly removes a device, it may not send a [DBT\_DEVICEQUERYREMOVE](dbt-devicequeryremove.md) message before doing so.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NULL">
            <summary>Performs no operation. An application sends the WM\_NULL message if it wants to post a message that the recipient window will ignore.</summary>
            <returns>
            <para>Type: **LRESULT** An application returns zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>For example, if an application has installed a **WH\_GETMESSAGE** hook and wants to prevent a message from being processed, the [**GetMsgProc**](/previous-versions/windows/desktop/legacy/ms644981(v=vs.85)) callback function can change the message number to **WM\_NULL** so the recipient will ignore it. As another example, an application can check if a window is responding to messages by sending the **WM\_NULL** message with the [**SendMessageTimeout**](/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-null#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CREATE">
            <summary>Sent when an application requests that a window be created by calling the CreateWindowEx or CreateWindow function.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero to continue creation of the window. If the application returns –1, the window is destroyed and the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) or [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa) function returns a **NULL** handle.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-create">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DESTROY">
            <summary>Sent when a window is being destroyed. It is sent to the window procedure of the window being destroyed after the window is removed from the screen.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>If the window being destroyed is part of the clipboard viewer chain (set by calling the [**SetClipboardViewer**](/windows/win32/api/winuser/nf-winuser-setclipboardviewer) function), the window must remove itself from the chain by processing the [**ChangeClipboardChain**](/windows/win32/api/winuser/nf-winuser-changeclipboardchain) function before returning from the **WM\_DESTROY** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MOVE">
            <summary>Sent after a window has been moved.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>The parameters are given in screen coordinates for overlapped and pop-up windows and in parent-client coordinates for child windows. The following example demonstrates how to obtain the position from the *lParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-move#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SIZE">
            <summary>Sent to a window after its size has changed.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>If the [**SetScrollPos**](https://msdn.microsoft.com/library/Cc411085(v=MSDN.10).aspx) or [**MoveWindow**](/windows/win32/api/winuser/nf-winuser-movewindow) function is called for a child window as a result of the **WM\_SIZE** message, the *bRedraw* or *bRepaint* parameter should be nonzero to cause the window to be repainted. Although the width and height of a window are 32-bit values, the *lParam* parameter contains only the low-order 16 bits of each. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends the **WM\_SIZE** and **WM\_MOVE** messages when it processes the [**WM\_WINDOWPOSCHANGED**](wm-windowposchanged.md) message. The **WM\_SIZE** and **WM\_MOVE** messages are not sent if an application handles the **WM\_WINDOWPOSCHANGED** message without calling **DefWindowProc**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-size#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ACTIVATE">
            <summary>Sent to both the window being activated and the window being deactivated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>If the window is being activated and is not minimized, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sets the keyboard focus to the window. If the window is activated by a mouse click, it also receives a [**WM\_MOUSEACTIVATE**](wm-mouseactivate.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SETFOCUS">
            <summary>Sent to a window after it has gained the keyboard focus.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>To display a caret, an application should call the appropriate caret functions when it receives the **WM\_SETFOCUS** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_KILLFOCUS">
            <summary>Sent to a window immediately before it loses the keyboard focus.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>If an application is displaying a caret, the caret should be destroyed at this point. While processing this message, do not make any function calls that display or activate a window. This causes the thread to yield control and can cause the application to stop responding to messages. For more information, see [Message Deadlocks](/windows/desktop/winmsg/about-messages-and-message-queues).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-killfocus#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ENABLE">
            <summary>Sent when an application changes the enabled state of a window.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-enable">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SETREDRAW">
            <summary>You send the **WM_SETREDRAW** message to a window to allow changes in that window to be redrawn, or to prevent changes in that window from being redrawn.</summary>
            <returns>Your application should return 0 if it processes this message.</returns>
            <remarks>
            <para>This message can be useful if your application must add several items to a list box. Your application can call this message with *wParam* set to **FALSE**, add the items, and then call the message again with *wParam* set to **TRUE**. Finally, your application can call [**RedrawWindow**](/windows/win32/api/Winuser/nf-winuser-redrawwindow)(*hWnd*, **NULL**, **NULL**, RDW\_ERASE \| RDW\_FRAME \| RDW\_INVALIDATE \| RDW\_ALLCHILDREN) to cause the list box to be repainted. > [!NOTE] > You should use [**RedrawWindow**](/windows/win32/api/Winuser/nf-winuser-redrawwindow) with the specified flags, instead of [**InvalidateRect**](/windows/win32/api/Winuser/nf-winuser-invalidaterect), because the former is necessary for some controls that have nonclient area of their own, or have window styles that cause them to be given a nonclient area (such as **WS_THICKFRAME**, **WS_BORDER**, or **WS_EX_CLIENTEDGE**). If the control does not have a nonclient area, then **RedrawWindow** with these flags will do only as much invalidation as **InvalidateRect** would. Passing a **WM_SETREDRAW** message to the **DefWindowProc** function removes the **WS_VISIBLE** style from the window when *wParam* is set to **FALSE**. Although the window content remains visible on screen, the [**IsWindowVisible**](/windows/win32/api/winuser/nf-winuser-iswindowvisible) function returns **FALSE** when called on a window in this state. Passing a **WM_SETREDRAW** message to the **DefWindowProc** function adds the **WS_VISIBLE** style to the window, if not set, when *wParam* is set to **TRUE**. If your application sends the **WM_SETREDRAW** message with *wParam* set to **TRUE** to a hidden window, then the window becomes visible. **Windows 10 and later; Windows Server 2016 and later**. The system sets a property named *SysSetRedraw* on a window whose window procedure passes **WM_SETREDRAW** messages to **DefWindowProc**. You can use the [**GetProp**](/windows/win32/api/Winuser/nf-winuser-getpropa) function to get the property value when it's available. **GetProp** returns a non-zero value when redraw is disabled. **GetProp** will return zero when redraw is enabled, or when the window property doesn't exist.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-setredraw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SETTEXT">
            <summary>Sets the text of a window.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is **TRUE** if the text is set. It is **FALSE** (for an edit control), **LB\_ERRSPACE** (for a list box), or **CB\_ERRSPACE** (for a combo box) if insufficient space is available to set the text in the edit control. It is **CB\_ERR** if this message is sent to a combo box without an edit control.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sets and displays the window text. For an edit control, the text is the contents of the edit control. For a combo box, the text is the contents of the edit-control portion of the combo box. For a button, the text is the button name. For other windows, the text is the window title. This message does not change the current selection in the list box of a combo box. An application should use the [**CB\_SELECTSTRING**](../controls/cb-selectstring.md) message to select the item in a list box that matches the text in the edit control.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-settext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GETTEXT">
            <summary>Copies the text that corresponds to a window into a buffer provided by the caller.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is the number of characters copied, not including the terminating null character.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function copies the text associated with the window into the specified buffer and returns the number of characters copied. Note, for non-text static controls this gives you the text with which the control was originally created, that is, the ID number. However, it gives you the ID of the non-text static control as originally created. That is, if you subsequently used a **STM\_SETIMAGE** to change it the original ID would still be returned. For an edit control, the text to be copied is the content of the edit control. For a combo box, the text is the content of the edit control (or static-text) portion of the combo box. For a button, the text is the button name. For other windows, the text is the window title. To copy the text of an item in a list box, an application can use the [**LB\_GETTEXT**](../controls/lb-gettext.md) message. When the **WM\_GETTEXT** message is sent to a static control with the **SS\_ICON** style, a handle to the icon will be returned in the first four bytes of the buffer pointed to by *lParam*. This is true only if the [**WM\_SETTEXT**](wm-settext.md) message has been used to set the icon. **Rich Edit:** If the text to be copied exceeds 64K, use either the [**EM\_STREAMOUT**](../controls/em-streamout.md) or [**EM\_GETSELTEXT**](../controls/em-getseltext.md) message. Sending a **WM\_GETTEXT** message to a non-text static control, such as a static bitmap or static icon control, does not return a string value. Instead, it returns zero. In addition, in early versions of Windows, applications could send a **WM\_GETTEXT** message to a non-text static control to retrieve the control's ID. To retrieve a control's ID, applications can use [**GetWindowLong**](/windows/win32/api/winuser/nf-winuser-getwindowlonga) passing **GWL\_ID** as the index value or [**GetWindowLongPtr**](/windows/win32/api/winuser/nf-winuser-getwindowlongptra) using **GWLP\_ID**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-gettext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GETTEXTLENGTH">
            <summary>Determines the length, in characters, of the text associated with a window.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is the length of the text in characters, not including the terminating null character.</para>
            </returns>
            <remarks>
            <para>For an edit control, the text to be copied is the content of the edit control. For a combo box, the text is the content of the edit control (or static-text) portion of the combo box. For a button, the text is the button name. For other windows, the text is the window title. To determine the length of an item in a list box, an application can use the [**LB\_GETTEXTLEN**](../controls/lb-gettextlen.md) message. When the **WM\_GETTEXTLENGTH** message is sent, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns the length, in characters, of the text. Under certain conditions, the **DefWindowProc** function returns a value that is larger than the actual length of the text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence of double-byte character set (DBCS) characters within the text. The return value, however, will always be at least as large as the actual length of the text; you can thus always use it to guide buffer allocation. This behavior can occur when an application uses both ANSI functions and common dialogs, which use Unicode. To obtain the exact length of the text, use the [**WM\_GETTEXT**](wm-gettext.md), [**LB\_GETTEXT**](../controls/lb-gettext.md), or [**CB\_GETLBTEXT**](../controls/cb-getlbtext.md) messages, or the [**GetWindowText**](/windows/win32/api/winuser/nf-winuser-getwindowtexta) function. Sending a **WM\_GETTEXTLENGTH** message to a non-text static control, such as a static bitmap or static icon controlc, does not return a string value. Instead, it returns zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-gettextlength#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PAINT">
            <summary>The WM\_PAINT message is sent when the system or another application makes a request to paint a portion of an application's window.</summary>
            <returns>An application returns zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_PAINT** message is generated by the system and should not be sent by an application. To force a window to draw into a specific device context, use the [**WM\_PRINT**](wm-print.md) or [**WM\_PRINTCLIENT**](wm-printclient.md) message. Note that this requires the target window to support the **WM\_PRINTCLIENT** message. Most common controls support the **WM\_PRINTCLIENT** message. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function validates the update region. The function may also send the [**WM\_NCPAINT**](wm-ncpaint.md) message to the window procedure if the window frame must be painted and send the [**WM\_ERASEBKGND**](../winmsg/wm-erasebkgnd.md) message if the window background must be erased. The system sends this message when there are no other messages in the application's message queue. [**DispatchMessage**](/windows/win32/api/winuser/nf-winuser-dispatchmessage) determines where to send the message; [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) determines which message to dispatch. **GetMessage** returns the **WM\_PAINT** message when there are no other messages in the application's message queue, and **DispatchMessage** sends the message to the appropriate window procedure. A window may receive internal paint messages as a result of calling [**RedrawWindow**](/windows/desktop/api/Winuser/nf-winuser-redrawwindow) with the RDW\_INTERNALPAINT flag set. In this case, the window may not have an update region. An application may call the [**GetUpdateRect**](/windows/desktop/api/Winuser/nf-winuser-getupdaterect) function to determine whether the window has an update region. If **GetUpdateRect** returns zero, the application need not call the [**BeginPaint**](/windows/desktop/api/Winuser/nf-winuser-beginpaint) and [**EndPaint**](/windows/desktop/api/Winuser/nf-winuser-endpaint) functions. An application must check for any necessary internal painting by looking at its internal data structures for each **WM\_PAINT** message, because a **WM\_PAINT** message may have been caused by both a non-NULL update region and a call to [**RedrawWindow**](/windows/desktop/api/Winuser/nf-winuser-redrawwindow) with the RDW\_INTERNALPAINT flag set. The system sends an internal **WM\_PAINT** message only once. After an internal **WM\_PAINT** message is returned from [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) or is sent to a window by [**UpdateWindow**](/windows/desktop/api/Winuser/nf-winuser-updatewindow), the system does not post or send further **WM\_PAINT** messages until the window is invalidated or until [**RedrawWindow**](/windows/desktop/api/Winuser/nf-winuser-redrawwindow) is called again with the RDW\_INTERNALPAINT flag set. For some common controls, the default **WM\_PAINT** message processing checks the *wParam* parameter. If *wParam* is non-NULL, the control assumes that the value is an HDC and paints using that device context.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-paint#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CLOSE">
            <summary>Sent as a signal that a window or an application should terminate.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>An application can prompt the user for confirmation, prior to destroying a window, by processing the **WM\_CLOSE** message and calling the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) function only if the user confirms the choice. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function calls the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) function to destroy the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-close#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_QUERYENDSESSION">
            <summary>The WM\_QUERYENDSESSION message is sent when the user chooses to end the session or when an application calls one of the system shutdown functions.</summary>
            <returns>
            <para>Applications should respect the user's intentions and return **TRUE**. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns **TRUE** for this message. If shutting down would corrupt the system or media that is being burned, the application can return **FALSE**. However, it is good practice to respect the user's actions.</para>
            </returns>
            <remarks>
            <para>When an application returns **TRUE** for this message, it receives the [**WM\_ENDSESSION**](wm-endsession.md) message, regardless of how the other applications respond to the **WM\_QUERYENDSESSION** message. Each application should return **TRUE** or **FALSE** immediately upon receiving this message, and defer any cleanup operations until it receives the **WM\_ENDSESSION** message. Applications can display a user interface prompting the user for information at shutdown, however it is not recommended. After five seconds, the system displays information about the applications that are preventing shutdown and allows the user to terminate them. For example, Windows XP displays a dialog box, while Windows Vista displays a full screen with additional information about the applications blocking shutdown. If your application must block or postpone system shutdown, use the [**ShutdownBlockReasonCreate**](/windows/desktop/api/Winuser/nf-winuser-shutdownblockreasoncreate) function. For more information, see [Shutdown Changes for Windows Vista](shutdown-changes-for-windows-vista.md). Console applications can use the [**SetConsoleCtrlHandler**](/windows/console/setconsolectrlhandler) function to receive shutdown notification. Service applications can use the [**RegisterServiceCtrlHandlerEx**](/windows/win32/api/winsvc/nf-winsvc-registerservicectrlhandlerexa) function to receive shutdown notifications in a handler routine.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Shutdown/wm-queryendsession#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_QUERYOPEN">
            <summary>Sent to an icon when the user requests that the window be restored to its previous size and position.</summary>
            <returns>
            <para>Type: **LRESULT** If the icon can be opened, an application that processes this message should return **TRUE**; otherwise, it should return **FALSE** to prevent the icon from being opened.</para>
            </returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns **TRUE**. While processing this message, the application should not perform any action that would cause an activation or focus change (for example, creating a dialog box).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-queryopen#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ENDSESSION">
            <summary>The WM\_ENDSESSION message is sent to an application after the system processes the results of the WM\_QUERYENDSESSION message. The WM\_ENDSESSION message informs the application whether the session is ending.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Applications that have unsaved data could save the data to a temporary location and restore it the next time the application starts. It is recommended that applications save their data and state frequently; for example, automatically save data between save operations initiated by the user to reduce the amount of data to be saved at shutdown. The application need not call the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) or [**PostQuitMessage**](/windows/win32/api/winuser/nf-winuser-postquitmessage) function when the session is ending.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Shutdown/wm-endsession#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_QUIT">
            <summary>Indicates a request to terminate an application, and is generated when the application calls the PostQuitMessage function. This message causes the GetMessage function to return zero.</summary>
            <returns>
            <para>Type: **LRESULT** This message does not have a return value because it causes the message loop to terminate before the message is sent to the application's window procedure.</para>
            </returns>
            <remarks>
            <para>The **WM\_QUIT** message is not associated with a window and therefore will never be received through a window's window procedure. It is retrieved only by the [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) functions. Do not post the **WM\_QUIT** message using the [**PostMessage**](/windows/win32/api/winuser/nf-winuser-postmessagea) function; use [**PostQuitMessage**](/windows/win32/api/winuser/nf-winuser-postquitmessage).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-quit#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ERASEBKGND">
            <summary>Sent when the window background must be erased (for example, when a window is resized). The message is sent to prepare an invalidated portion of a window for painting.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return nonzero if it erases the background; otherwise, it should return zero.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function erases the background by using the class background brush specified by the **hbrBackground** member of the [**WNDCLASS**](/windows/win32/api/winuser/ns-winuser-wndclassa) structure. If **hbrBackground** is **NULL**, the application should process the **WM\_ERASEBKGND** message and erase the background. An application should return nonzero in response to **WM\_ERASEBKGND** if it processes the message and erases the background; this indicates that no further erasing is required. If the application returns zero, the window will remain marked for erasing. (Typically, this indicates that the **fErase** member of the [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) structure will be **TRUE**.)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-erasebkgnd#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SYSCOLORCHANGE">
            <summary>The WM\_SYSCOLORCHANGE message is sent to all top-level windows when a change is made to a system color setting.</summary>
            <remarks>
            <para>The system sends a [**WM\_PAINT**](wm-paint.md) message to any window that is affected by a system color change. Applications that have brushes using the existing system colors should delete those brushes and re-create them using the new system colors. Top level windows that use common controls must forward the **WM\_SYSCOLORCHANGE** message to the controls; otherwise, the controls will not be notified of the color change. This ensures that the colors used by your common controls are consistent with those used by other user interface objects. For example, a toolbar control uses the "3D Objects" color to draw its buttons. If the user changes the 3D Objects color but the **WM\_SYSCOLORCHANGE** message is not forwarded to the toolbar, the toolbar buttons will remain in their original color while the color of other buttons in the system changes.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-syscolorchange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SHOWWINDOW">
            <summary>Sent to a window when the window is about to be hidden or shown.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function hides or shows the window, as specified by the message. If a window has the [**WS\_VISIBLE**](window-styles.md) style when it is created, the window receives this message after it is created, but before it is displayed. A window also receives this message when its visibility state is changed by the [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow) or [**ShowOwnedPopups**](/windows/win32/api/winuser/nf-winuser-showownedpopups) function. The **WM\_SHOWWINDOW** message is not sent under the following circumstances: -   When a top-level, overlapped window is created with the [**WS\_MAXIMIZE**](window-styles.md) or **WS\_MINIMIZE** style. -   When the **SW\_SHOWNORMAL** flag is specified in the call to the [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-showwindow#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_WININICHANGE">
            <summary>An application sends the WM\_WININICHANGE message to all top-level windows after making a change to the WIN.INI file. The SystemParametersInfo function sends this message after an application uses the function to change a setting in WIN.INI.</summary>
            <returns>
            <para>Type: **LRESULT** If you process this message, return zero.</para>
            </returns>
            <remarks>
            <para>To send the **WM\_WININICHANGE** message to all top-level windows, use the [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) function with the *hWnd* parameter set to **HWND\_BROADCAST**. Calls to functions that change WIN.INI may be mapped to the registry instead. This mapping occurs when WIN.INI and the section being changed are specified in the registry under the following key: **HKEY\_LOCAL\_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping** The change in the storage location has no effect on the behavior of this message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-wininichange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SETTINGCHANGE">
            <summary>A message that is sent to all top-level windows when the SystemParametersInfo function changes a system-wide setting or when policy settings have changed.</summary>
            <returns>
            <para>Type: **LRESULT** If you process this message, return zero.</para>
            </returns>
            <remarks>The *lParam* parameter indicates which system metric has changed, for example, "ConvertibleSlateMode" if the CONVERTIBLESLATEMODE indicator was toggled or "SystemDockMode" if the DOCKED indicator was toggled.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DEVMODECHANGE">
            <summary>The WM\_DEVMODECHANGE message is sent to all top-level windows whenever the user changes device-mode settings.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>This message cannot be sent directly to a window. To send the **WM\_DEVMODECHANGE** message to all top-level windows, use the [**SendMessageTimeout**](/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta) function with the *hWnd* parameter set to HWND\_BROADCAST.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ACTIVATEAPP">
            <summary>Sent when a window belonging to a different application than the active window is about to be activated. The message is sent to the application whose window is being activated and to the application whose window is being deactivated.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-activateapp">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_FONTCHANGE">
            <summary>An application sends the WM\_FONTCHANGE message to all top-level windows in the system after changing the pool of font resources.</summary>
            <remarks>
            <para>An application that adds or removes fonts from the system (for example, by using the [**AddFontResource**](/windows/desktop/api/Wingdi/nf-wingdi-addfontresourcea) or [**RemoveFontResource**](/windows/desktop/api/Wingdi/nf-wingdi-removefontresourcea) function) should send this message to all top-level windows. To send the **WM\_FONTCHANGE** message to all top-level windows, an application can call the **SendMessage** function with the *hwnd* parameter set to HWND\_BROADCAST.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-fontchange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_TIMECHANGE">
            <summary>A message that is sent whenever there is a change in the system time.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>An application should not broadcast this message, because the system will broadcast this message when the application changes the system time.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CANCELMODE">
            <summary>Sent to cancel certain modes, such as mouse capture.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>When the **WM\_CANCELMODE** message is sent, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function cancels internal processing of standard scroll bar input, cancels internal menu processing, and releases the mouse capture.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SETCURSOR">
            <summary>Sent to a window if the mouse causes the cursor to move within a window and mouse input is not captured.</summary>
            <returns>If an application processes this message, it should return **TRUE** to halt further processing or **FALSE** to continue.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowprocw) function passes the **WM\_SETCURSOR** message to a parent window before processing. If the parent window returns **TRUE**, further processing is halted. Passing the message to a window's parent window gives the parent window control over the cursor's setting in a child window. The **DefWindowProc** function also uses this message to set the cursor to an arrow if it is not in the client area, or to the registered class cursor if it is in the client area. If the low-order word of the *lParam* parameter is **HTERROR** and the high-order word of *lParam* specifies that one of the mouse buttons is pressed, **DefWindowProc** calls the [**MessageBeep**](/windows/desktop/api/winuser/nf-winuser-messagebeep) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MOUSEACTIVATE">
            <summary>Sent when the cursor is in an inactive window and the user presses a mouse button. The parent window receives this message only if the child window passes it to the DefWindowProc function.</summary>
            <returns>
            <para>The return value specifies whether the window should be activated and whether the identifier of the mouse message should be discarded. It must be one of the following values.</para>
            <para>| Return code/value                                                                                                                                          | Description                                                                      | |------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------| | <dl> <dt>**MA\_ACTIVATE**</dt> <dt>1</dt> </dl>         | Activates the window, and does not discard the mouse message.<br/>         | | <dl> <dt>**MA\_ACTIVATEANDEAT**</dt> <dt>2</dt> </dl>   | Activates the window, and discards the mouse message.<br/>                 | | <dl> <dt>**MA\_NOACTIVATE**</dt> <dt>3</dt> </dl>       | Does not activate the window, and does not discard the mouse message.<br/> | | <dl> <dt>**MA\_NOACTIVATEANDEAT**</dt> <dt>4</dt> </dl> | Does not activate the window, but discards the mouse message.<br/>         |</para>
            </returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function passes the message to a child window's parent window before any processing occurs. The parent window determines whether to activate the child window. If it activates the child window, the parent window should return **MA\_NOACTIVATE** or **MA\_NOACTIVATEANDEAT** to prevent the system from processing the message further.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CHILDACTIVATE">
            <summary>Sent to a child window when the user clicks the window's title bar or when the window is activated, moved, or sized.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-childactivate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_QUEUESYNC">
            <summary>Sent by a computer-based training (CBT) application to separate user-input messages from other messages sent through the WH\_JOURNALPLAYBACK procedure.</summary>
            <returns>
            <para>Type: **void** A CBT application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>Whenever a CBT application uses the [**WH\_JOURNALPLAYBACK**](about-hooks.md) procedure, the first and last messages are **WM\_QUEUESYNC**. This allows the CBT application to intercept and examine user-initiated messages without doing so for events that it sends. If an application specifies a **NULL** window handle, the message is posted to the message queue of the active window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-queuesync#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GETMINMAXINFO">
            <summary>Sent to a window when the size or position of the window is about to change. An application can use this message to override the window's default maximized size and position, or its default minimum or maximum tracking size.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>The maximum tracking size is the largest window size that can be produced by using the borders to size the window. The minimum tracking size is the smallest window size that can be produced by using the borders to size the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NEXTDLGCTL">
            <summary>Sent to a dialog box procedure to set the keyboard focus to a different control in the dialog box.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>This message performs additional dialog box management operations beyond those performed by the [**SetFocus**](/windows/desktop/api/winuser/nf-winuser-setfocus) function **WM\_NEXTDLGCTL** updates the default pushbutton border, sets the default control identifier, and automatically selects the text of an edit control (if the target window is an edit control). Do not use the [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) function to send a **WM\_NEXTDLGCTL** message if your application will concurrently process other messages that set the focus. Use the [**PostMessage**](/windows/desktop/api/winuser/nf-winuser-postmessagea) function instead.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-nextdlgctl#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SPOOLERSTATUS">
            <summary>The WM\_SPOOLERSTATUS message is sent from Print Manager whenever a job is added to or removed from the Print Manager queue.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>This message is for informational purposes only. This message is advisory and does not have guaranteed delivery semantics. Applications should not assume that they will receive a WM\_SPOOLERSTATUS message for every change in spooler status. The WM\_SPOOLERSTATUS message is not supported after Windows XP. To be notified of changes to the print queue status, you can use [**FindFirstPrinterChangeNotification**](findfirstprinterchangenotification.md) and [**FindNextPrinterChangeNotification**](findnextprinterchangenotification.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/printdocs/wm-spoolerstatus#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DRAWITEM">
            <summary>Sent to the parent window of an owner-drawn button, combo box, list box, or menu when a visual aspect of the button, combo box, list box, or menu has changed.</summary>
            <returns>If an application processes this message, it should return **TRUE**.</returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function draws the focus rectangle for an owner-drawn list box item. The *itemAction* member of the [**DRAWITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-drawitemstruct) structure specifies the drawing operation that an application should perform. Before returning from processing this message, an application should ensure that the device context identified by the *hDC* member of the [**DRAWITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-drawitemstruct) structure is in the default state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-drawitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MEASUREITEM">
            <summary>Sent to the owner window of a combo box, list box, list-view control, or menu item when the control or menu is created.</summary>
            <returns>If an application processes this message, it should return **TRUE**.</returns>
            <remarks>
            <para>When the owner window receives the **WM\_MEASUREITEM** message, the owner fills in the [**MEASUREITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-measureitemstruct) structure pointed to by the *lParam* parameter of the message and returns; this informs the system of the dimensions of the control. If a list box or combo box is created with the [**LBS\_OWNERDRAWVARIABLE**](list-box-styles.md) or [**CBS\_OWNERDRAWVARIABLE**](combo-box-styles.md) style, this message is sent to the owner for each item in the control; otherwise, this message is sent once. The system sends the **WM\_MEASUREITEM** message to the owner window of combo boxes and list boxes created with the OWNERDRAWFIXED style before sending the [**WM\_INITDIALOG**](/windows/desktop/dlgbox/wm-initdialog) message. As a result, when the owner receives this message, the system has not yet determined the height and width of the font used in the control; function calls and calculations requiring these values should occur in the main function of the application or library.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-measureitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DELETEITEM">
            <summary>Sent to the owner of a list box or combo box when the list box or combo box is destroyed or when items are removed by the LB\_DELETESTRING, LB\_RESETCONTENT, CB\_DELETESTRING, or CB\_RESETCONTENT message.</summary>
            <returns>An application should return **TRUE** if it processes this message.</returns>
            <remarks>
            <para>Microsoft Windows NT and later: Windows sends a **WM\_DELETEITEM** message only for items deleted from an owner-drawn list box (with the [**LBS\_OWNERDRAWFIXED**](list-box-styles.md) or [**LBS\_OWNERDRAWVARIABLE**](list-box-styles.md) style) or owner-drawn combo box (with the [**CBS\_OWNERDRAWFIXED**](combo-box-styles.md) or [**CBS\_OWNERDRAWVARIABLE**](combo-box-styles.md) style). Windows 95: Windows sends the **WM\_DELETEITEM** message for any deleted list box or combo box item with nonzero item data.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-deleteitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_VKEYTOITEM">
            <summary>Sent by a list box with the LBS\_WANTKEYBOARDINPUT style to its owner in response to a WM\_KEYDOWN message.</summary>
            <returns>The return value specifies the action that the application performed in response to the message. A return value of -2 indicates that the application handled all aspects of selecting the item and requires no further action by the list box. (See Remarks.) A return value of -1 indicates that the list box should perform the default action in response to the keystroke. A return value of 0 or greater specifies the index of an item in the list box and indicates that the list box should perform the default action for the keystroke on the specified item.</returns>
            <remarks>
            <para>A return value of -2 is valid only for keys that are not translated into characters by the list box control. If the [**WM\_KEYDOWN**](/windows/desktop/inputdev/wm-keydown) message translates to a [**WM\_CHAR**](/windows/desktop/inputdev/wm-char) message and the application processes the **WM\_VKEYTOITEM** message generated as a result of the key press, the list box ignores the return value and does the default processing for that character). **WM\_KEYDOWN** messages generated by keys such as VK\_UP, VK\_DOWN, VK\_NEXT, and VK\_PREVIOUS are not translated to **WM\_CHAR** messages. In such cases, trapping the **WM\_VKEYTOITEM** message and returning -2 prevents the list box from doing the default processing for that key. To trap keys that generate a char message and do special processing, the application must subclass the list box, trap both the [**WM\_KEYDOWN**](/windows/desktop/inputdev/wm-keydown) and [**WM\_CHAR**](/windows/desktop/inputdev/wm-char) messages, and process the messages appropriately in the subclass procedure. The preceding remarks apply to regular list boxes that are created with the [**LBS\_WANTKEYBOARDINPUT**](list-box-styles.md) style. If the list box is owner-drawn, the application must process the [**WM\_CHARTOITEM**](wm-chartoitem.md) message. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns -1. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-vkeytoitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CHARTOITEM">
            <summary>Sent by a list box with the LBS\_WANTKEYBOARDINPUT style to its owner in response to a WM\_CHAR message.</summary>
            <returns>The return value specifies the action that the application performed in response to the message. A return value of -1 or -2 indicates that the application handled all aspects of selecting the item and requires no further action by the list box. A return value of 0 or greater specifies the zero-based index of an item in the list box and indicates that the list box should perform the default action for the keystroke on the specified item.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns -1. Only owner-drawn list boxes that do not have the [**LBS\_HASSTRINGS**](list-box-styles.md) style can receive this message. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The *DWL\_MSGRESULT* value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-chartoitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SETFONT">
            <summary>Sets the font that a control is to use when drawing text.</summary>
            <returns>
            <para>Type: **LRESULT** This message does not return a value.</para>
            </returns>
            <remarks>
            <para>The **WM\_SETFONT** message applies to all controls, not just those in dialog boxes. The best time for the owner of a dialog box control to set the font of the control is when it receives the [**WM\_INITDIALOG**](../dlgbox/wm-initdialog.md) message. The application should call the [**DeleteObject**](/windows/win32/api/wingdi/nf-wingdi-deleteobject) function to delete the font when it is no longer needed; for example, after it destroys the control. The size of the control does not change as a result of receiving this message. To avoid clipping text that does not fit within the boundaries of the control, the application should correct the size of the control window before it sets the font. When a dialog box uses the [DS\_SETFONT](../dlgbox/about-dialog-boxes.md) style to set the text in its controls, the system sends the **WM\_SETFONT** message to the dialog box procedure before it creates the controls. An application can create a dialog box that contains the DS\_SETFONT style by calling any of the following functions: -   [**CreateDialogIndirect**](/windows/win32/api/winuser/nf-winuser-createdialogindirecta) -   [**CreateDialogIndirectParam**](/windows/win32/api/winuser/nf-winuser-createdialogindirectparama) -   [**DialogBoxIndirect**](/windows/win32/api/winuser/nf-winuser-dialogboxindirecta) -   [**DialogBoxIndirectParam**](/windows/win32/api/winuser/nf-winuser-dialogboxindirectparama)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-setfont#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GETFONT">
            <summary>Retrieves the font with which the control is currently drawing its text.</summary>
            <returns>
            <para>Type: **HFONT** The return value is a handle to the font used by the control, or **NULL** if the control is using the system font.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-getfont">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SETHOTKEY">
            <summary>Sent to a window to associate a hot key with the window. When the user presses the hot key, the system activates the window.</summary>
            <returns>
            <para>The return value is one of the following.</para>
            <para>| Return value                                                                  | Description                                                                             | |-------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------| | <dl> <dt>-1</dt> </dl> | The function is unsuccessful; the hot key is invalid.<br/>                        | | <dl> <dt>0</dt> </dl>  | The function is unsuccessful; the window is invalid.<br/>                         | | <dl> <dt>1</dt> </dl>  | The function is successful, and no other window has the same hot key.<br/>        | | <dl> <dt>2</dt> </dl>  | The function is successful, but another window already has the same hot key.<br/> |</para>
            </returns>
            <remarks>
            <para>A hot key cannot be associated with a child window. **VK\_ESCAPE**, **VK\_SPACE**, and **VK\_TAB** are invalid hot keys. When the user presses the hot key, the system generates a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message with *wParam* equal to **SC\_HOTKEY** and *lParam* equal to the window's handle. If this message is passed on to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca), the system will bring the window's last active popup (if it exists) or the window itself (if there is no popup window) to the foreground. A window can only have one hot key. If the window already has a hot key associated with it, the new hot key replaces the old one. If more than one window has the same hot key, the window that is activated by the hot key is random. These hot keys are unrelated to the hot keys set by [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-sethotkey#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GETHOTKEY">
            <summary>Sent to determine the hot key associated with a window.</summary>
            <returns>
            <para>The return value is the virtual-key code and modifiers for the hot key, or **NULL** if no hot key is associated with the window. The virtual-key code is in the low byte of the return value and the modifiers are in the high byte. The modifiers can be a combination of the following flags from CommCtrl.h.</para>
            <para>| Return code/value                                                                                                                                         | Description             | |-----------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------| | <dl> <dt>**HOTKEYF\_ALT**</dt> <dt>0x04</dt> </dl>     | ALT key<br/>      | | <dl> <dt>**HOTKEYF\_CONTROL**</dt> <dt>0x02</dt> </dl> | CTRL key<br/>     | | <dl> <dt>**HOTKEYF\_EXT**</dt> <dt>0x08</dt> </dl>     | Extended key<br/> | | <dl> <dt>**HOTKEYF\_SHIFT**</dt> <dt>0x01</dt> </dl>   | SHIFT key<br/>    |</para>
            </returns>
            <remarks>These hot keys are unrelated to the hot keys set by the [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_QUERYDRAGICON">
            <summary>Sent to a minimized (iconic) window.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return a handle to a cursor or icon that the system is to display while the user drags the icon. The cursor or icon must be compatible with the display driver's resolution. If the application returns **NULL**, the system displays the default cursor.</para>
            </returns>
            <remarks>
            <para>When the user drags the icon of a window without a class icon, the system replaces the icon with a default cursor. If the application requires a different cursor to be displayed during dragging, it must return a handle to the cursor or icon compatible with the display driver's resolution. If an application returns a handle to a color cursor or icon, the system converts the cursor or icon to black and white. The application can call the [**LoadCursor**](/windows/win32/api/winuser/nf-winuser-loadcursora) or [**LoadIcon**](/windows/win32/api/winuser/nf-winuser-loadicona) function to load a cursor or icon from the resources in its executable (.exe) file and to retrieve this handle. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-querydragicon#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_COMPAREITEM">
            <summary>Sent to determine the relative position of a new item in the sorted list of an owner-drawn combo box or list box.</summary>
            <returns>
            <para>The return value indicates the relative position of the two items. It may be any of the values shown in the following table.</para>
            <para>| Return code                                                                          | Description                                                  | |--------------------------------------------------------------------------------------|--------------------------------------------------------------| | <dl> <dt>**Value**</dt> </dl> | Meaning<br/>                                           | | <dl> <dt>**-1**</dt> </dl>    | Item 1 precedes item 2 in the sorted order.<br/>       | | <dl> <dt>**0**</dt> </dl>     | Items 1 and 2 are equivalent in the sorted order.<br/> | | <dl> <dt>**1**</dt> </dl>     | Item 1 follows item 2 in the sorted order.<br/>        |</para>
            </returns>
            <remarks>
            <para>When the owner of an owner-drawn combo box or list box receives this message, the owner returns a value indicating which of the items specified by the [**COMPAREITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-compareitemstruct) structure will appear before the other. Typically, the system sends this message several times until it determines the exact position for the new item. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-compareitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GETOBJECT">
            <summary>Sent by both Microsoft Active Accessibility and Microsoft UI Automation to obtain information about an accessible object contained in a server application.</summary>
            <returns>
            <para>If the window or control does not need to respond to this message, it should pass the message to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function; otherwise, the window or control should return a value that corresponds to the request specified by *dwObjId*: -   If the window or control implements UI Automation, the window or control should return the value obtained by a call to the [**UiaReturnRawElementProvider**](/windows/desktop/api/UIAutomationCoreApi/nf-uiautomationcoreapi-uiareturnrawelementprovider) function. -   If *dwObjId* is [**OBJID\_NATIVEOM**](object-identifiers.md) and the window exposes a native Object Model, the windows should return the value obtained by a call to the [**LresultFromObject**](/windows/desktop/api/Oleacc/nf-oleacc-lresultfromobject) function. -   If *dwObjId* is [**OBJID\_CLIENT**](object-identifiers.md) and the window implements [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible), the window should return the value obtained by a call to the [**LresultFromObject**](/windows/desktop/api/Oleacc/nf-oleacc-lresultfromobject) function.</para>
            </returns>
            <remarks>
            <para>When a client calls [**AccessibleObjectFromWindow**](/windows/desktop/api/Oleacc/nf-oleacc-accessibleobjectfromwindow) or any of the other **AccessibleObjectFrom***X* functions that retrieve an interface to an object, Microsoft Active Accessibility sends the **WM\_GETOBJECT** message to the appropriate window procedure within the appropriate server application. While processing **WM\_GETOBJECT**, server applications call [**LresultFromObject**](/windows/desktop/api/Oleacc/nf-oleacc-lresultfromobject) and use the return value of this function as the return value for the message. Microsoft Active Accessibility, in conjunction with the COM library, performs the appropriate marshaling and passes the interface pointer from the server back to the client. Servers do not respond to **WM\_GETOBJECT** before the object is fully initialized or after it begins to close down. When an application creates a new window, the system sends [**EVENT\_OBJECT\_CREATE**](event-constants.md) to notify clients before it sends the [WM\_CREATE](../winmsg/wm-create.md) message to the application's window procedure. Because many applications use WM\_CREATE to start their initialization process, servers do not respond to the **WM\_GETOBJECT** message until finished processing the **WM\_CREATE** message. A server uses **WM\_GETOBJECT** to perform the following tasks: -   [Create New Accessible Objects](create-new-accessible-objects.md) -   [Reuse Existing Pointers to Objects](reuse-existing-pointers-to-objects.md) -   [Create New Interfaces to the Same Object](create-new-interfaces-to-the-same-object.md) For clients, this means that they might receive distinct interface pointers for the same user interface element, depending on the server's action. To determine if two interface pointers point to the same user interface element, clients compare [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) properties of the object. Comparing pointers does not work.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/WinAuto/wm-getobject#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_COMPACTING">
            <summary>Sent to all top-level windows when the system detects more than 12.5 percent of system time over a 30- to 60-second interval is being spent compacting memory. This indicates that system memory is low.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>When an application receives this message, it should free as much memory as possible, taking into account the current level of activity of the application and the total number of applications running on the system.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_WINDOWPOSCHANGING">
            <summary>Sent to a window whose size, position, or place in the Z order is about to change as a result of a call to the SetWindowPos function or another window-management function.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>For a window with the [**WS\_OVERLAPPED**](window-styles.md) or **WS\_THICKFRAME** style, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends the [**WM\_GETMINMAXINFO**](wm-getminmaxinfo.md) message to the window. This is done to validate the new size and position of the window and to enforce the [CS\_BYTEALIGNCLIENT](about-window-classes.md) and CS\_BYTEALIGNWINDOW client styles. By not passing the **WM\_WINDOWPOSCHANGING** message to the **DefWindowProc** function, an application can override these defaults. While this message is being processed, modifying any of the values in [**WINDOWPOS**](/windows/win32/api/winuser/ns-winuser-windowpos) affects the window's new size, position, or place in the Z order. An application can prevent changes to the window by setting or clearing the appropriate bits in the **flags** member of **WINDOWPOS**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-windowposchanging#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_WINDOWPOSCHANGED">
            <summary>Sent to a window whose size, position, or place in the Z order has changed as a result of a call to the SetWindowPos function or another window-management function.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends the [**WM\_SIZE**](wm-size.md) and [**WM\_MOVE**](wm-move.md) messages to the window. The **WM\_SIZE** and **WM\_MOVE** messages are not sent if an application handles the **WM\_WINDOWPOSCHANGED** message without calling **DefWindowProc**. It is more efficient to perform any move or size change processing during the **WM\_WINDOWPOSCHANGED** message without calling **DefWindowProc**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POWER">
            <summary>Notifies applications that the system, typically a battery-powered personal computer, is about to enter a suspended mode.</summary>
            <returns>The value an application returns depends on the value of the *wParam* parameter. If *wParam* is **PWR\_SUSPENDREQUEST**, the return value is **PWR\_FAIL** to prevent the system from entering the suspended state; otherwise, it is **PWR\_OK**. If *wParam* is **PWR\_SUSPENDRESUME** or **PWR\_CRITICALRESUME**, the return value is zero.</returns>
            <remarks>
            <para>This message is broadcast only to an application that is running on a system that conforms to the Advanced Power Management (APM) basic input/output system (BIOS) specification. The message is broadcast by the power-management driver to each window returned by the **EnumWindows** function. The suspended mode is the state in which the greatest amount of power savings occurs, but all operational data and parameters are preserved. Random-access memory (RAM) contents are preserved, but many devices are likely to be turned off.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Power/wm-power#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_COPYDATA">
            <summary>An application sends the WM\_COPYDATA message to pass data to another application.</summary>
            <returns>If the receiving application processes this message, it should return **TRUE**; otherwise, it should return **FALSE**.</returns>
            <remarks>
            <para>The data being passed must not contain pointers or other references to objects not accessible to the application receiving the data. While this message is being sent, the referenced data must not be changed by another thread of the sending process. The receiving application should consider the data read-only. The *lParam* parameter is valid only during the processing of the message. The receiving application should not free the memory referenced by *lParam*. If the receiving application must access the data after [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) returns, it must copy the data into a local buffer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-copydata#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CANCELJOURNAL">
            <summary>Posted to an application when a user cancels the application's journaling activities. The message is posted with a NULL window handle.</summary>
            <returns>
            <para>Type: **void** This message does not return a value. It is meant to be processed from within an application's main loop or a [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) hook procedure, not from a window procedure.</para>
            </returns>
            <remarks>
            <para>Journal record and playback modes are modes imposed on the system that let an application sequentially record or play back user input. The system enters these modes when an application installs a [*JournalRecordProc*](/previous-versions/windows/desktop/legacy/ms644983(v=vs.85)) or [*JournalPlaybackProc*](/previous-versions/windows/desktop/legacy/ms644982(v=vs.85)) hook procedure. When the system is in either of these journaling modes, applications must take turns reading input from the input queue. If any one application stops reading input while the system is in a journaling mode, other applications are forced to wait. To ensure a robust system, one that cannot be made unresponsive by any one application, the system automatically cancels any journaling activities when a user presses CTRL+ESC or CTRL+ALT+DEL. The system then unhooks any journaling hook procedures, and posts a **WM\_CANCELJOURNAL** message, with a **NULL** window handle, to the application that set the journaling hook. The **WM\_CANCELJOURNAL** message has a **NULL** window handle, therefore it cannot be dispatched to a window procedure. There are two ways for an application to see a **WM\_CANCELJOURNAL** message: If the application is running in its own main loop, it must catch the message between its call to [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) and its call to [**DispatchMessage**](/windows/win32/api/winuser/nf-winuser-dispatchmessage). If the application is not running in its own main loop, it must set a [*GetMsgProc*](/previous-versions/windows/desktop/legacy/ms644981(v=vs.85)) hook procedure (through a call to [**SetWindowsHookEx**](/windows/win32/api/winuser/nf-winuser-setwindowshookexa) specifying the **WH\_GETMESSAGE** hook type) that watches for the message. When an application sees a **WM\_CANCELJOURNAL** message, it can assume two things: the user has intentionally canceled the journal record or playback mode, and the system has already unhooked any journal record or playback hook procedures. Note that the key combinations mentioned above (CTRL+ESC or CTRL+ALT+DEL) cause the system to cancel journaling. If any one application is made unresponsive, they give the user a means of recovery. The [**VK\_CANCEL**](../inputdev/virtual-key-codes.md) virtual key code (usually implemented as the CTRL+BREAK key combination) is what an application that is in journal record mode should watch for as a signal that the user wishes to cancel the journaling activity. The difference is that watching for **VK\_CANCEL** is a suggested behavior for journaling applications, whereas CTRL+ESC or CTRL+ALT+DEL cause the system to cancel journaling regardless of a journaling application's behavior.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-canceljournal#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_INPUTLANGCHANGEREQUEST">
            <summary>Posted to the window with the focus when the user chooses a new input language, either with the hotkey (specified in the Keyboard control panel application) or from the indicator on the system taskbar.</summary>
            <returns>
            <para>Type: **LRESULT** This message is posted, not sent, to the application, so the return value is ignored. To accept the change, the application should pass the message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca). To reject the change, the application should return zero without calling **DefWindowProc**.</para>
            </returns>
            <remarks>
            <para>When the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function receives the **WM\_INPUTLANGCHANGEREQUEST** message, it activates the new input locale and notifies the application of the change by sending the [**WM\_INPUTLANGCHANGE**](wm-inputlangchange.md) message. The language indicator is present on the taskbar only if you have installed more than one keyboard layout and if you have enabled the indicator using the Keyboard control panel application.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-inputlangchangerequest#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_INPUTLANGCHANGE">
            <summary>Sent to the topmost affected window after an application's input language has been changed. You should make any application-specific settings and pass the message to the DefWindowProc function, which passes the message to all first-level child windows.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return nonzero if it processes this message.</para>
            </returns>
            <remarks>
            <para>You can retrieve the [BCP 47](https://www.rfc-editor.org/info/bcp47) [locale name](../Intl/locale-names.md) from the language identifier by calling the [LCIDToLocaleName](/windows/win32/api/winnls/nf-winnls-lcidtolocalename) function. Once you have the locale name, you can then use [modern locale functions](/windows/win32/intl/calling-the--locale-name--functions) to extract additional locale information. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-inputlangchange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_TCARD">
            <summary>Sent to an application that has initiated a training card with Windows Help.</summary>
            <returns>The return value is ignored; use zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/shell/wm-tcard">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_HELP">
            <summary>Indicates that the user pressed the F1 key.</summary>
            <returns>Returns **TRUE**.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function passes **WM\_HELP** to the parent window of a child window or to the owner of a top-level window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_USERCHANGED">
            <summary>Sent to all windows after the user has logged on or off. When the user logs on or off, the system updates the user-specific settings. The system sends this message immediately after updating the settings.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-userchanged">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NOTIFYFORMAT">
            <summary>Determines if a window accepts ANSI or Unicode structures in the WM\_NOTIFY notification message. WM\_NOTIFYFORMAT messages are sent from a common control to its parent window and from the parent window to the common control.</summary>
            <returns>
            <para>Returns one of the following values.</para>
            <para>| Return code                                                                                 | Description                                                                                                    | |---------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------| | <dl> <dt>**NFR\_ANSI**</dt> </dl>    | ANSI structures should be used in [**WM\_NOTIFY**](wm-notify.md) messages sent by the control.<br/>     | | <dl> <dt>**NFR\_UNICODE**</dt> </dl> | Unicode structures should be used in [**WM\_NOTIFY**](wm-notify.md) messages sent by the control. <br/> | | <dl> <dt>**0**</dt> </dl>            | An error occurred.<br/>                                                                                  |</para>
            </returns>
            <remarks>
            <para>When a common control is created, the control sends a **WM\_NOTIFYFORMAT** message to its parent window to determine the type of structures to use in [**WM\_NOTIFY**](wm-notify.md) messages. If the parent window does not handle this message, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function responds according to the type of the parent window. That is, if the parent window is a Unicode window, **DefWindowProc** returns NFR\_UNICODE, and if the parent window is an ANSI window, **DefWindowProc** returns NFR\_ANSI. If the parent window is a dialog box and does not handle this message, the [**DefDlgProc**](/windows/desktop/api/winuser/nf-winuser-defdlgprocw) function similarly responds according to the type of the dialog box (Unicode or ANSI). A parent window can change the type of structures a common control uses in [**WM\_NOTIFY**](wm-notify.md) messages by setting *lParam* to NF\_REQUERY and sending a **WM\_NOTIFYFORMAT** message to the control. This causes the control to send an NF\_QUERY form of the **WM\_NOTIFYFORMAT** message to the parent window. All common controls will send **WM\_NOTIFYFORMAT** messages. However, the standard Windows controls (edit controls, combo boxes, list boxes, buttons, scroll bars, and static controls) do not.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-notifyformat#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_STYLECHANGING">
            <summary>Sent to a window when the SetWindowLong function is about to change one or more of the window's styles.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-stylechanging">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_STYLECHANGED">
            <summary>Sent to a window after the SetWindowLong function has changed one or more of the window's styles.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-stylechanged">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DISPLAYCHANGE">
            <summary>The WM\_DISPLAYCHANGE message is sent to all windows when the display resolution has changed.</summary>
            <remarks>This message is only sent to top-level windows. For all other windows it is posted.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GETICON">
            <summary>Sent to a window to retrieve a handle to the large or small icon associated with a window. The system displays the large icon in the ALT+TAB dialog, and the small icon in the window caption.</summary>
            <returns>
            <para>Type: **HICON** The return value is a handle to the large or small icon, depending on the value of *wParam*. When an application receives this message, it can return a handle to a large or small icon, or pass the message to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function.</para>
            </returns>
            <remarks>
            <para>When an application receives this message, it can return a handle to a large or small icon, or pass the message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca). [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) returns a handle to the large or small icon associated with the window, depending on the value of *wParam*. A window that has no icon explicitly set (with **WM\_SETICON**) uses the icon for the registered window class, and in this case [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) will return 0 for a **WM\_GETICON** message. If sending a **WM\_GETICON** message to a window returns 0, next try calling the [**GetClassLongPtr**](/windows/win32/api/winuser/nf-winuser-getclasslongptra) function for the window. If that returns 0 then try the [**LoadIcon**](/windows/win32/api/winuser/nf-winuser-loadicona) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-geticon#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SETICON">
            <summary>Associates a new large or small icon with a window. The system displays the large icon in the ALT+TAB dialog box, and the small icon in the window caption.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is a handle to the previous large or small icon, depending on the value of *wParam*. It is **NULL** if the window previously had no icon of the type indicated by *wParam*.</para>
            </returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns a handle to the previous large or small icon associated with the window, depending on the value of *wParam*.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCCREATE">
            <summary>Sent prior to the WM\_CREATE message when a window is first created.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return **TRUE** to continue creation of the window. If the application returns **FALSE**, the [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa) or [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function will return a **NULL** handle.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-nccreate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCDESTROY">
            <summary>Notifies a window that its nonclient area is being destroyed. The DestroyWindow function sends the WM\_NCDESTROY message to the window following the WM\_DESTROY message.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>This message frees any memory internally allocated for the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCCALCSIZE">
            <summary>Sent when the size and position of a window's client area must be calculated. By processing this message, an application can control the content of the window's client area when the size or position of the window changes.</summary>
            <returns>
            <para>Type: **LRESULT** If the *wParam* parameter is **FALSE**, the application should return zero. If *wParam* is **TRUE**, the application should return zero or a combination of the following values. If *wParam* is **TRUE** and an application returns zero, the old client area is preserved and is aligned with the upper-left corner of the new client area.</para>
            <para>| Return code/value                                                                                                                                           | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | |-------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**WVR\_ALIGNTOP**</dt> <dt>0x0010</dt> </dl>    | Specifies that the client area of the window is to be preserved and aligned with the top of the new position of the window. For example, to align the client area to the upper-left corner, return the WVR\_ALIGNTOP and **WVR\_ALIGNLEFT** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | | <dl> <dt>**WVR\_ALIGNRIGHT**</dt> <dt>0x0080</dt> </dl>  | Specifies that the client area of the window is to be preserved and aligned with the right side of the new position of the window. For example, to align the client area to the lower-right corner, return the **WVR\_ALIGNRIGHT** and WVR\_ALIGNBOTTOM values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | | <dl> <dt>**WVR\_ALIGNLEFT**</dt> <dt>0x0020</dt> </dl>   | Specifies that the client area of the window is to be preserved and aligned with the left side of the new position of the window. For example, to align the client area to the lower-left corner, return the **WVR\_ALIGNLEFT** and **WVR\_ALIGNBOTTOM** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | | <dl> <dt>**WVR\_ALIGNBOTTOM**</dt> <dt>0x0040</dt> </dl> | Specifies that the client area of the window is to be preserved and aligned with the bottom of the new position of the window. For example, to align the client area to the top-left corner, return the WVR\_ALIGNTOP and **WVR\_ALIGNLEFT** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | | <dl> <dt>**WVR\_HREDRAW**</dt> <dt>0x0100</dt> </dl>     | Used in combination with any other values, except **WVR\_VALIDRECTS**, causes the window to be completely redrawn if the client rectangle changes size horizontally. This value is similar to [CS\_HREDRAW](about-window-classes.md) class style<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | | <dl> <dt>**WVR\_VREDRAW**</dt> <dt>0x0200</dt> </dl>     | Used in combination with any other values, except **WVR\_VALIDRECTS**, causes the window to be completely redrawn if the client rectangle changes size vertically. This value is similar to [CS\_VREDRAW](about-window-classes.md) class style<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | | <dl> <dt>**WVR\_REDRAW**</dt> <dt>0x0300</dt> </dl>      | This value causes the entire window to be redrawn. It is a combination of **WVR\_HREDRAW** and **WVR\_VREDRAW** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | | <dl> <dt>**WVR\_VALIDRECTS**</dt> <dt>0x0400</dt> </dl>  | This value indicates that, upon return from [**WM\_NCCALCSIZE**](wm-nccalcsize.md), the rectangles specified by the **rgrc**\[1\] and **rgrc**\[2\] members of the [**NCCALCSIZE\_PARAMS**](/windows/win32/api/winuser/ns-winuser-nccalcsize_params) structure contain valid destination and source area rectangles, respectively. The system combines these rectangles to calculate the area of the window to be preserved. The system copies any part of the window image that is within the source rectangle and clips the image to the destination rectangle. Both rectangles are in parent-relative or screen-relative coordinates. This flag cannot be combined with any other flags. <br/> This return value allows an application to implement more elaborate client-area preservation strategies, such as centering or preserving a subset of the client area.<br/> |</para>
            </returns>
            <remarks>
            <para>The window may be redrawn, depending on whether the [CS\_HREDRAW](about-window-classes.md) or CS\_VREDRAW class style is specified. This is the default, backward-compatible processing of this message by the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function (in addition to the usual client rectangle calculation described in the preceding table). When *wParam* is **TRUE**, simply returning 0 without processing the [**NCCALCSIZE\_PARAMS**](/windows/win32/api/winuser/ns-winuser-nccalcsize_params) rectangles will cause the client area to resize to the size of the window, including the window frame. This will remove the window frame and caption items from your window, leaving only the client area displayed. Starting with Windows Vista, removing the standard frame by simply returning 0 when the *wParam* is **TRUE** does not affect frames that are extended into the client area using the [**DwmExtendFrameIntoClientArea**](/windows/win32/api/dwmapi/nf-dwmapi-dwmextendframeintoclientarea) function. Only the standard frame will be removed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-nccalcsize#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCHITTEST">
            <summary>Sent to a window in order to determine what part of the window corresponds to a particular screen coordinate.</summary>
            <returns>
            <para>The return value of the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function is one of the following values, indicating the position of the cursor hot spot.</para>
            <para>| Return code/value                                                                                                                                    | Description                                                                                                                                                                                                        | |------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**HTBORDER**</dt> <dt>18</dt> </dl>      | In the border of a window that does not have a sizing border.<br/>                                                                                                                                           | | <dl> <dt>**HTBOTTOM**</dt> <dt>15</dt> </dl>      | In the lower-horizontal border of a resizable window (the user can click the mouse to resize the window vertically).<br/>                                                                                    | | <dl> <dt>**HTBOTTOMLEFT**</dt> <dt>16</dt> </dl>  | In the lower-left corner of a border of a resizable window (the user can click the mouse to resize the window diagonally).<br/>                                                                              | | <dl> <dt>**HTBOTTOMRIGHT**</dt> <dt>17</dt> </dl> | In the lower-right corner of a border of a resizable window (the user can click the mouse to resize the window diagonally).<br/>                                                                             | | <dl> <dt>**HTCAPTION**</dt> <dt>2</dt> </dl>      | In a title bar.<br/>                                                                                                                                                                                         | | <dl> <dt>**HTCLIENT**</dt> <dt>1</dt> </dl>       | In a client area.<br/>                                                                                                                                                                                       | | <dl> <dt>**HTCLOSE**</dt> <dt>20</dt> </dl>       | In a **Close** button.<br/>                                                                                                                                                                                  | | <dl> <dt>**HTERROR**</dt> <dt>-2</dt> </dl>       | On the screen background or on a dividing line between windows (same as **HTNOWHERE**, except that the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function produces a system beep to indicate an error).<br/> | | <dl> <dt>**HTGROWBOX**</dt> <dt>4</dt> </dl>      | In a size box (same as **HTSIZE**).<br/>                                                                                                                                                                     | | <dl> <dt>**HTHELP**</dt> <dt>21</dt> </dl>        | In a **Help** button.<br/>                                                                                                                                                                                   | | <dl> <dt>**HTHSCROLL**</dt> <dt>6</dt> </dl>      | In a horizontal scroll bar.<br/>                                                                                                                                                                             | | <dl> <dt>**HTLEFT**</dt> <dt>10</dt> </dl>        | In the left border of a resizable window (the user can click the mouse to resize the window horizontally).<br/>                                                                                              | | <dl> <dt>**HTMENU**</dt> <dt>5</dt> </dl>         | In a menu.<br/>                                                                                                                                                                                              | | <dl> <dt>**HTMAXBUTTON**</dt> <dt>9</dt> </dl>    | In a **Maximize** button.<br/>                                                                                                                                                                               | | <dl> <dt>**HTMINBUTTON**</dt> <dt>8</dt> </dl>    | In a **Minimize** button.<br/>                                                                                                                                                                               | | <dl> <dt>**HTNOWHERE**</dt> <dt>0</dt> </dl>      | On the screen background or on a dividing line between windows.<br/>                                                                                                                                         | | <dl> <dt>**HTREDUCE**</dt> <dt>8</dt> </dl>       | In a **Minimize** button.<br/>                                                                                                                                                                               | | <dl> <dt>**HTRIGHT**</dt> <dt>11</dt> </dl>       | In the right border of a resizable window (the user can click the mouse to resize the window horizontally).<br/>                                                                                             | | <dl> <dt>**HTSIZE**</dt> <dt>4</dt> </dl>         | In a size box (same as **HTGROWBOX**).<br/>                                                                                                                                                                  | | <dl> <dt>**HTSYSMENU**</dt> <dt>3</dt> </dl>      | In a window menu or in a **Close** button in a child window.<br/>                                                                                                                                            | | <dl> <dt>**HTTOP**</dt> <dt>12</dt> </dl>         | In the upper-horizontal border of a window.<br/>                                                                                                                                                             | | <dl> <dt>**HTTOPLEFT**</dt> <dt>13</dt> </dl>     | In the upper-left corner of a window border.<br/>                                                                                                                                                            | | <dl> <dt>**HTTOPRIGHT**</dt> <dt>14</dt> </dl>    | In the upper-right corner of a window border.<br/>                                                                                                                                                           | | <dl> <dt>**HTTRANSPARENT**</dt> <dt>-1</dt> </dl> | In a window currently covered by another window in the same thread (the message will be sent to underlying windows in the same thread until one of them returns a code that is not **HTTRANSPARENT**).<br/>  | | <dl> <dt>**HTVSCROLL**</dt> <dt>7</dt> </dl>      | In the vertical scroll bar.<br/>                                                                                                                                                                             | | <dl> <dt>**HTZOOM**</dt> <dt>9</dt> </dl>         | In a **Maximize** button.<br/>                                                                                                                                                                               |</para>
            </returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nchittest#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCPAINT">
            <summary>The WM\_NCPAINT message is sent to a window when its frame must be painted.</summary>
            <returns>An application returns zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function paints the window frame. An application can intercept the **WM\_NCPAINT** message and paint its own custom window frame. The clipping region for a window is always rectangular, even if the shape of the frame is altered. The *wParam* value can be passed to [**GetDCEx**](/windows/desktop/api/Winuser/nf-winuser-getdcex) as in the following example.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-ncpaint#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCACTIVATE">
            <summary>Sent to a window when its nonclient area needs to be changed to indicate an active or inactive state.</summary>
            <returns>
            <para>Type: **LRESULT** When the *wParam* parameter is **FALSE**, an application should return **TRUE** to indicate that the system should proceed with the default processing, or it should return **FALSE** to prevent the change. When *wParam* is **TRUE**, the return value is ignored.</para>
            </returns>
            <remarks>
            <para>Processing messages related to the nonclient area of a standard window is not recommended, because the application must be able to draw all the required parts of the nonclient area for the window. If an application does process this message, it must return **TRUE** to direct the system to complete the change of active window. If the window is minimized when this message is received, the application should pass the message to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function draws the title bar or icon title in its active colors when the *wParam* parameter is **TRUE** and in its inactive colors when *wParam* is **FALSE**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-ncactivate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GETDLGCODE">
            <summary>Sent to the window procedure associated with a control.</summary>
            <returns>
            <para>The return value is one or more of the following values, indicating which type of input the application processes.</para>
            <para>| Return code/value                                                                                                                                                | Description                                                                                                                | |------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**DLGC\_BUTTON**</dt> <dt>0x2000</dt> </dl>          | Button.<br/>                                                                                                         | | <dl> <dt>**DLGC\_DEFPUSHBUTTON**</dt> <dt>0x0010</dt> </dl>   | Default push button.<br/>                                                                                            | | <dl> <dt>**DLGC\_HASSETSEL**</dt> <dt>0x0008</dt> </dl>       | [**EM\_SETSEL**](/windows/desktop/Controls/em-setsel) messages.<br/>                                                           | | <dl> <dt>**DLGC\_RADIOBUTTON**</dt> <dt>0x0040</dt> </dl>     | Radio button.<br/>                                                                                                   | | <dl> <dt>**DLGC\_STATIC**</dt> <dt>0x0100</dt> </dl>          | Static control.<br/>                                                                                                 | | <dl> <dt>**DLGC\_UNDEFPUSHBUTTON**</dt> <dt>0x0020</dt> </dl> | Non-default push button.<br/>                                                                                        | | <dl> <dt>**DLGC\_WANTALLKEYS**</dt> <dt>0x0004</dt> </dl>     | All keyboard input.<br/>                                                                                             | | <dl> <dt>**DLGC\_WANTARROWS**</dt> <dt>0x0001</dt> </dl>      | Direction keys.<br/>                                                                                                 | | <dl> <dt>**DLGC\_WANTCHARS**</dt> <dt>0x0080</dt> </dl>       | [**WM\_CHAR**](/windows/desktop/inputdev/wm-char) messages.<br/>                                                                      | | <dl> <dt>**DLGC\_WANTMESSAGE**</dt> <dt>0x0004</dt> </dl>     | All keyboard input (the application passes this message in the [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) structure to the control).<br/> | | <dl> <dt>**DLGC\_WANTTAB**</dt> <dt>0x0002</dt> </dl>         | TAB key.<br/>                                                                                                        |</para>
            </returns>
            <remarks>
            <para>Although the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function always returns zero in response to the **WM\_GETDLGCODE** message, the window procedure for the predefined control classes return a code appropriate for each class. The **WM\_GETDLGCODE** message and the returned values are useful only with user-defined dialog box controls or standard controls modified by subclassing.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-getdlgcode#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SYNCPAINT">
            <summary>The WM\_SYNCPAINT message is used to synchronize painting while avoiding linking independent GUI threads.</summary>
            <returns>An application returns zero if it processes this message.</returns>
            <remarks>When a window has been hidden, shown, moved, or sized, the system may determine that it is necessary to send a **WM\_SYNCPAINT** message to the top-level windows of other threads. Applications must pass **WM\_SYNCPAINT** to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  for processing. The **DefWindowProc** function will send a [**WM\_NCPAINT**](wm-ncpaint.md) message to the window procedure if the window frame must be painted and send a [**WM\_ERASEBKGND**](../winmsg/wm-erasebkgnd.md) message if the window background must be erased.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCMOUSEMOVE">
            <summary>Posted to a window when the cursor is moved within the nonclient area of the window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>If it is appropriate to do so, the system sends the [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the window. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmousemove#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCLBUTTONDOWN">
            <summary>Posted when the user presses the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function tests the specified point to find the location of the cursor and performs the appropriate action. If appropriate, **DefWindowProc** sends the [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the window. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nclbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCLBUTTONUP">
            <summary>Posted when the user releases the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function tests the specified point to find out the location of the cursor and performs the appropriate action. If appropriate, **DefWindowProc** sends the [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the window. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nclbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCLBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nclbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCRBUTTONDOWN">
            <summary>Posted when the user presses the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncrbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCRBUTTONUP">
            <summary>Posted when the user releases the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncrbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCRBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window need not have the **CS\_DBLCLKS** style to receive **WM\_NCRBUTTONDBLCLK** messages. The system generates a **WM\_NCRBUTTONDBLCLK** message when the user presses, releases, and again presses the right mouse button within the system's double-click time limit. Double-clicking the right mouse button actually generates four messages: [**WM\_NCRBUTTONDOWN**](wm-ncrbuttondown.md), [**WM\_NCRBUTTONUP**](wm-ncrbuttonup.md), **WM\_NCRBUTTONDBLCLK**, and **WM\_NCRBUTTONUP** again. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncrbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCMBUTTONDOWN">
            <summary>Posted when the user presses the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCMBUTTONUP">
            <summary>Posted when the user releases the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCMBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window need not have the **CS\_DBLCLKS** style to receive **WM\_NCMBUTTONDBLCLK** messages. The system generates a **WM\_NCMBUTTONDBLCLK** message when the user presses, releases, and again presses the middle mouse button within the system's double-click time limit. Double-clicking the middle mouse button actually generates four messages: [**WM\_NCMBUTTONDOWN**](wm-ncmbuttondown.md), [**WM\_NCMBUTTONUP**](wm-ncmbuttonup.md), **WM\_NCMBUTTONDBLCLK**, and **WM\_NCMBUTTONUP** again. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCXBUTTONDOWN">
            <summary>Posted when the user presses the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncxbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCXBUTTONUP">
            <summary>Posted when the user releases the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncxbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCXBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncxbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_INPUT_DEVICE_CHANGE">
            <summary>Sent to the window that registered to receive raw input. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-input-device-change">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_INPUT">
            <summary>Sent to the window that is getting raw input. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>Raw input is available only when the application calls [**RegisterRawInputDevices**](/windows/win32/api/winuser/nf-winuser-registerrawinputdevices) with valid device specifications.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_KEYDOWN">
            <summary>Posted to the window with the keyboard focus when a nonsystem key is pressed. A nonsystem key is a key that is pressed when the ALT key is not pressed.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>If the F10 key is pressed, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sets an internal flag. When **DefWindowProc** receives the [**WM\_KEYUP**](wm-keyup.md) message, the function checks whether the internal flag is set and, if so, sends a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the top-level window. The **WM\_SYSCOMMAND** parameter of the message is set to SC\_KEYMENU. Because of the autorepeat feature, more than one **WM\_KEYDOWN** message may be posted before a [**WM\_KEYUP**](wm-keyup.md) message is posted. The previous key state (bit 30) can be used to determine whether the **WM\_KEYDOWN** message indicates the first down transition or a repeated down transition. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. Applications must pass *wParam* to [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) without altering it at all.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-keydown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_KEYUP">
            <summary>Posted to the window with the keyboard focus when a nonsystem key is released. A nonsystem key is a key that is pressed when the ALT key is not pressed, or a keyboard key that is pressed when a window has the keyboard focus.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the top-level window if the F10 key or the ALT key was released. The *wParam* parameter of the message is set to SC\_KEYMENU. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. Applications must pass *wParam* to [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) without altering it at all.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-keyup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CHAR">
            <summary>Posted to the window with the keyboard focus when a WM\_KEYDOWN message is translated by the TranslateMessage function. The WM\_CHAR message contains the character code of the key that was pressed.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_CHAR** message uses UTF-16 (16-bit Unicode Transformation Format) code units in its **wParam** if the Unicode version of the [**RegisterClass**](/windows/win32/api/winuser/nf-winuser-registerclassw) function was used to register the window class. Otherwise, the system provides characters in the current process code page, which can be set to UTF-8 in Windows Version 1903 (May 2019 Update) and newer. For more information, see [Registering Window Classes](/windows/win32/intl/registering-window-classes) and [Use UTF-8 code pages in Windows apps](/windows/apps/design/globalizing/use-utf8-code-page). Starting with Windows Vista, **WM\_CHAR** message can send [UTF-16 surrogate pairs](/windows/win32/intl/surrogates-and-supplementary-characters) to Unicode windows. Use the [IS_HIGH_SURROGATE](/windows/win32/api/Winnls/nf-winnls-is_high_surrogate), [IS_LOW_SURROGATE](/windows/win32/api/winnls/nf-winnls-is_low_surrogate), and [IS_SURROGATE_PAIR](/windows/win32/api/winnls/nf-winnls-is_surrogate_pair) macros to detect such cases, if necessary. There is not necessarily a one-to-one correspondence between keys pressed and character messages generated, and so the information in the high-order word of the *lParam* parameter is generally not useful to applications. The information in the high-order word applies only to the most recent [**WM\_KEYDOWN**](wm-keydown.md) message that precedes the posting of the **WM\_CHAR** message. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the *lParam* parameter. The [**WM\_UNICHAR**](wm-unichar.md) message is the same as **WM\_CHAR**, except it uses UTF-32. It is designed to send or post Unicode characters to ANSI windows, and it can handle Unicode Supplementary Plane characters.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-char#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DEADCHAR">
            <summary>Posted to the window with the keyboard focus when a WM\_KEYUP message is translated by the TranslateMessage function.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_DEADCHAR** message typically is used by applications to give the user feedback about each key pressed. For example, an application can display the accent in the current character position without moving the caret. Because there is not necessarily a one-to-one correspondence between keys pressed and character messages generated, the information in the high-order word of the *lParam* parameter is generally not useful to applications. The information in the high-order word applies only to the most recent [**WM\_KEYDOWN**](wm-keydown.md) message that precedes the posting of the **WM\_DEADCHAR** message. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the *lParam* parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-deadchar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SYSKEYDOWN">
            <summary>Posted to the window with the keyboard focus when the user presses the F10 key (which activates the menu bar) or holds down the ALT key and then presses another key.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function examines the specified key and generates a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message if the key is either TAB or ENTER. When the context code is zero, the message can be passed to the [**TranslateAccelerator**](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) function, which will handle it as though it were a normal key message instead of a character-key message. This allows accelerator keys to be used with the active window even if the active window does not have the keyboard focus. Because of automatic repeat, more than one **WM\_SYSKEYDOWN** message may occur before a [**WM\_SYSKEYUP**](wm-syskeyup.md) message is sent. The previous key state (bit 30) can be used to determine whether the **WM\_SYSKEYDOWN** message indicates the first down transition or a repeated down transition. For enhanced 101- and 102-key keyboards, enhanced keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. This message is also sent whenever the user presses the F10 key without the ALT key.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-syskeydown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SYSKEYUP">
            <summary>Posted to the window with the keyboard focus when the user releases a key that was pressed while the ALT key was held down.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the top-level window if the F10 key or the ALT key was released. The *wParam* parameter of the message is set to **SC\_KEYMENU**. When the context code is zero, the message can be passed to the [**TranslateAccelerator**](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) function, which will handle it as though it were a normal key message instead of a character-key message. This allows accelerator keys to be used with the active window even if the active window does not have the keyboard focus. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. For non-U.S. enhanced 102-key keyboards, the right ALT key is handled as a CTRL+ALT key. The following table shows the sequence of messages that result when the user presses and releases this key.</para>
            <para>| Message                           | Virtual-key code | |-----------------------------------|------------------| | [**WM\_KEYDOWN**](wm-keydown.md) | **VK\_CONTROL**  | | [**WM\_KEYDOWN**](wm-keydown.md) | **VK\_MENU**     | | [**WM\_KEYUP**](wm-keyup.md)     | **VK\_CONTROL**  | | **WM\_SYSKEYUP**                  | **VK\_MENU**     |</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-syskeyup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SYSCHAR">
            <summary>Posted to the window with the keyboard focus when a WM\_SYSKEYDOWN message is translated by the TranslateMessage function.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>When the context code is zero, the message can be passed to the [**TranslateAccelerator**](/windows/desktop/api/Winuser/nf-winuser-translateacceleratora) function, which will handle it as though it were a standard key message instead of a system character-key message. This allows accelerator keys to be used with the active window even if the active window does not have the keyboard focus. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; the PRINT SCRN key; the BREAK key; the NUMLOCK key; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-syschar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SYSDEADCHAR">
            <summary>Sent to the window with the keyboard focus when a WM\_SYSKEYDOWN message is translated by the TranslateMessage function.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_STARTCOMPOSITION">
            <summary>Sent immediately before the IME generates the composition string as a result of a keystroke. A window receives this message through its WindowProc function.</summary>
            <returns>
            <para>This message has no parameters.</para>
            <para>This message has no return value.</para>
            </returns>
            <remarks>
            <para>This message is a notification to an IME window to open its composition window. An application should process this message if it displays composition characters itself. If an application has created an IME window, it should pass this message to that window. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function processes the message by passing it to the default IME window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-startcomposition#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_ENDCOMPOSITION">
            <summary>Sent to an application when the IME ends composition. A window receives this message through its WindowProc function.</summary>
            <returns>
            <para>This message has no parameters.</para>
            <para>This message has no return value.</para>
            </returns>
            <remarks>
            <para>An application should process this message if it displays composition characters itself. If the application has created an IME window, it should pass this message to that window. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function processes this message by passing it to the default IME window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-endcomposition#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_COMPOSITION">
            <summary>Sent to an application when the IME changes composition status as a result of a keystroke. A window receives this message through its WindowProc function.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>An application should process this message if it displays composition characters itself. Otherwise, it should send the message to the IME window. If the application has created an IME window, it should pass this message to that window. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function processes this message by passing it to the default IME window. The IME window processes this message by updating its appearance based on the change flag specified. An application can call [**ImmGetCompositionString**](/windows/desktop/api/Imm/nf-imm-immgetcompositionstringa) to retrieve the new composition status. If none of the GCS\_ values are set, the message indicates that the current composition has been canceled and applications that draw the composition string should delete the string.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-composition#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_INITDIALOG">
            <summary>Sent to the dialog box procedure immediately before a dialog box is displayed. Dialog box procedures typically use this message to initialize controls and carry out any other initialization tasks that affect the appearance of the dialog box.</summary>
            <returns>
            <para>The dialog box procedure should return **TRUE** to direct the system to set the keyboard focus to the control specified by *wParam*. Otherwise, it should return **FALSE** to prevent the system from setting the default keyboard focus. The dialog box procedure should return the value directly. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            </returns>
            <remarks>
            <para>The control to receive the default keyboard focus is always the first control in the dialog box that is visible, not disabled, and that has the **WS\_TABSTOP** style. When the dialog box procedure returns **TRUE**, the system checks the control to ensure that the procedure has not disabled it. If it has been disabled, the system sets the keyboard focus to the next control that is visible, not disabled, and has the **WS\_TABSTOP**. An application can return **FALSE** only if it has set the keyboard focus to one of the controls of the dialog box.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-initdialog#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_COMMAND">
            <summary>Sent when the user selects a command item from a menu, when a control sends a notification message to its parent window, or when an accelerator keystroke is translated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use of the *wParam* and *lParam* parameters are summarized here.</para>
            <para>| Message Source | wParam (high word)                | wParam (low word)                | lParam                       | |----------------|-----------------------------------|----------------------------------|------------------------------| | Menu           | 0                                 | Menu identifier (IDM\_\*)        | 0                            | | Accelerator    | 1                                 | Accelerator identifier (IDM\_\*) | 0                            | | Control        | Control-defined notification code | Control identifier               | Handle to the control window |</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-command#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SYSCOMMAND">
            <summary>A window receives this message when the user chooses a command from the Window menu (formerly known as the system or control menu) or when the user chooses the maximize button, minimize button, restore button, or close button.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>To obtain the position coordinates in screen coordinates, use the following code:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-syscommand#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_TIMER">
            <summary>Posted to the installing thread's message queue when a timer expires. The message is posted by the GetMessage or PeekMessage function.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>You can process the message by providing a **WM\_TIMER** case in the window procedure. Otherwise, [**DispatchMessage**](/windows/win32/api/winuser/nf-winuser-dispatchmessage) will call the [*TimerProc*](/windows/win32/api/winuser/nc-winuser-timerproc) callback function specified in the call to the [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) function used to install the timer. The **WM\_TIMER** message is a low-priority message. The [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) and [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) functions post this message only when no other higher-priority messages are in the thread's message queue.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-timer#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_HSCROLL">
            <summary>The WM\_HSCROLL message is sent to a window when a scroll event occurs in the window's standard horizontal scroll bar.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The SB\_THUMBTRACK request code is typically used by applications that provide feedback as the user drags the scroll box. If an application scrolls the content of the window, it must also reset the position of the scroll box by using the [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos) function. Note that the **WM\_HSCROLL** message carries only 16 bits of scroll box position data. Thus, applications that rely solely on **WM\_HSCROLL** (and [**WM\_VSCROLL**](wm-vscroll.md)) for scroll position data have a practical maximum position value of 65,535. However, because the [**SetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-setscrollinfo), [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos), [**SetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-setscrollrange), [**GetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-getscrollinfo), [**GetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-getscrollpos), and [**GetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-getscrollrange) functions support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the **WM\_HSCROLL** and [**WM\_VSCROLL**](wm-vscroll.md) messages. See **GetScrollInfo** for a description of the technique.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-hscroll#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_VSCROLL">
            <summary>The WM\_VSCROLL message is sent to a window when a scroll event occurs in the window's standard vertical scroll bar.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The SB\_THUMBTRACK request code is typically used by applications that provide feedback as the user drags the scroll box. If an application scrolls the content of the window, it must also reset the position of the scroll box by using the [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos) function. Note that the **WM\_VSCROLL** message carries only 16 bits of scroll box position data. Thus, applications that rely solely on **WM\_VSCROLL** (and [**WM\_HSCROLL**](wm-hscroll.md)) for scroll position data have a practical maximum position value of 65,535. However, because the [**SetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-setscrollinfo), [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos), [**SetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-setscrollrange), [**GetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-getscrollinfo), [**GetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-getscrollpos), and [**GetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-getscrollrange) functions support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the [**WM\_HSCROLL**](wm-hscroll.md) and **WM\_VSCROLL** messages. See **GetScrollInfo** for a description of the technique.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-vscroll#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_INITMENU">
            <summary>Sent when a menu is about to become active.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>A **WM\_INITMENU** message is sent only when a menu is first accessed; only one **WM\_INITMENU** message is generated for each access. For example, moving the mouse across several menu items while holding down the button does not generate new messages. **WM\_INITMENU** does not provide information about menu items.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_INITMENUPOPUP">
            <summary>WM_INITMENUPOPUP message - Sent when a drop-down menu or submenu is about to become active. This allows an application to modify the menu before it is displayed, without changing the entire menu.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-initmenupopup">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GESTURE">
            <summary>Passes information about a gesture.</summary>
            <returns>
            <para>If an application processes this message, it should return 0. If the application does not process the message, it must call [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). Not doing so will cause the application to leak memory because the touch input handle will not be closed and associated process memory will not be freed.</para>
            </returns>
            <remarks>
            <para>The following table lists the supported gesture commands.</para>
            <para>| Gesture ID            | Value (*dwID*) | Description                                                                                                                                                                                                                                                                          | |-----------------------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | **GID\_BEGIN**        | 1              | Indicates a generic gesture is beginning.                                                                                                                                                                                                                                            | | **GID\_END**          | 2              | Indicates a generic gesture end.                                                                                                                                                                                                                                                     | | **GID\_ZOOM**         | 3              | Indicates zoom start, zoom move, or zoom stop. The first **GID\_ZOOM** command message begins a zoom but does not cause any zooming. The second **GID\_ZOOM** command triggers a zoom relative to the state contained in the first **GID\_ZOOM**.                                    | | **GID\_PAN**          | 4              | Indicates pan move or pan start. The first **GID\_PAN** command indicates a pan start but does not perform any panning. With the second **GID\_PAN** command message, the application will begin panning.                                                                            | | **GID\_ROTATE**       | 5              | Indicates rotate move or rotate start. The first **GID\_ROTATE** command message indicates a rotate move or rotate start but will not rotate. The second **GID\_ROTATE** command message will trigger a rotation operation relative to state contained in the first **GID\_ROTATE**. | | **GID\_TWOFINGERTAP** | 6              | Indicates two-finger tap gesture.                                                                                                                                                                                                                                                    | | **GID\_PRESSANDTAP**  | 7              | Indicates the press and tap gesture.                                                                                                                                                                                                                                                 |</para>
            <para>> [!Note] > In order to enable legacy support, messages with the **GID\_BEGIN** and **GID\_END** gesture commands need to be forwarded using [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            <para>The following table indicates the gesture arguments passed in the *lParam* and *wParam* parameters.</para>
            <para>| Gesture ID            | Gesture        | *ullArgument*                                                                                                                                                                                                                                                                                                                                                                                            | *ptsLocation* in [**GestureInfo**](/windows/desktop/api/winuser/nf-winuser-getgestureinfo) structure                                                  | |-----------------------|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------| | **GID\_ZOOM**         | Zoom In/Out    | Indicates the distance between the two points.                                                                                                                                                                                                                                                                                                                                                           | Indicates the center of the zoom.                                                                                 | | **GID\_PAN**          | Pan            | Indicates the distance between the two points.                                                                                                                                                                                                                                                                                                                                                           | Indicates the current position of the pan.                                                                        | | **GID\_ROTATE**       | Rotate (pivot) | Indicates the angle of rotation if the **GF\_BEGIN** flag is set. Otherwise, this is the angle change since the rotation has started. This is signed to indicate the direction of the rotation. Use the [**GID\_ROTATE\_ANGLE\_FROM\_ARGUMENT**](/windows/desktop/api/winuser/nf-winuser-gid_rotate_angle_from_argument) and [**GID\_ROTATE\_ANGLE\_TO\_ARGUMENT**](/windows/desktop/api/winuser/nf-winuser-gid_rotate_angle_to_argument) macros to get and set the angle value. | This indicates the center of the rotation which is the stationary point that the target object is rotated around. | | **GID\_TWOFINGERTAP** | Two-finger Tap | Indicates the distance between the two fingers.                                                                                                                                                                                                                                                                                                                                                          | Indicates the center of the two fingers.                                                                          | | **GID\_PRESSANDTAP**  | Press and Tap  | Indicates the delta between the first finger and the second finger. This value is stored in the lower 32 bits of the *ullArgument* in a **POINT** structure.                                                                                                                                                                                                                                             | Indicates the position that the first finger comes down on.                                                       |</para>
            <para>> [!Note] > All distances and positions are provided in physical screen coordinates.</para>
            <para>> [!Note] > The *dwID* and *ullArgument* parameters should only be considered to be accompanying the GID\_\* commands and should not be altered by applications.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/wintouch/wm-gesture#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GESTURENOTIFY">
            <summary>Gives you a chance to set the gesture configuration.</summary>
            <returns>A value should be returned from [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca).</returns>
            <remarks>
            <para>When the **WM\_GESTURENOTIFY** message is received, the application can use [**SetGestureConfig**](/windows/desktop/api/winuser/nf-winuser-setgestureconfig) to specify the gestures to receive. This message should always be bubbled up using the [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca) function. > [!Note] > Handling the **WM\_GESTURENOTIFY** message will change the gesture configuration for the lifetime of the Window, not just for the next gesture.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/wintouch/wm-gesturenotify#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MENUSELECT">
            <summary>Sent to a menu's owner window when the user selects a menu item.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>If the high-order word of *wParam* contains 0xFFFF and the *lParam* parameter contains **NULL**, the system has closed the menu. Do not use the value  1 for the high-order word of *wParam*, because this value is specified as (**UINT**) [**HIWORD**](/previous-versions/windows/desktop/legacy/ms632657(v=vs.85))(*wParam*). If the value is 0xFFFF, it would be interpreted as 0x0000FFFF, not  1, because of the cast to a **UINT**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menuselect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MENUCHAR">
            <summary>Sent when a menu is active and the user presses a key that does not correspond to any mnemonic or accelerator key. This message is sent to the window that owns the menu.</summary>
            <returns>
            <para>An application that processes this message should return one of the following values in the high-order word of the return value.</para>
            <para>| Return code/value                                                                                                                                  | Description                                                                                                                                                                              | |----------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**MNC\_CLOSE**</dt> <dt>1</dt> </dl>   | Informs the system that it should close the active menu.<br/>                                                                                                                      | | <dl> <dt>**MNC\_EXECUTE**</dt> <dt>2</dt> </dl> | Informs the system that it should choose the item specified in the low-order word of the return value. The owner window receives a [**WM\_COMMAND**](wm-command.md) message.<br/> | | <dl> <dt>**MNC\_IGNORE**</dt> <dt>0</dt> </dl>  | Informs the system that it should discard the character the user pressed and create a short beep on the system speaker.<br/>                                                       | | <dl> <dt>**MNC\_SELECT**</dt> <dt>3</dt> </dl>  | Informs the system that it should select the item specified in the low-order word of the return value. <br/>                                                                       |</para>
            </returns>
            <remarks>
            <para>The low-order word is ignored if the high-order word contains 0 or 1. An application should process this message when an accelerator is used to select a menu item that displays a bitmap.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menuchar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ENTERIDLE">
            <summary>Sent to the owner window of a modal dialog box or menu that is entering an idle state. A modal dialog box or menu enters an idle state when no messages are waiting in its queue after it has processed one or more previous messages.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>You can suppress the **WM\_ENTERIDLE** message for a dialog box by creating the dialog box with the **DS\_NOIDLEMSG** style.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MENURBUTTONUP">
            <summary>Sent when the user releases the right mouse button while the cursor is on a menu item.</summary>
            <remarks>The **WM\_MENURBUTTONUP** message allows applications to provide a context-sensitive menu also known as a shortcut menu for the menu item specified in this message. To display a context-sensitive menu for a menu item, call the [**TrackPopupMenuEx**](/windows/desktop/api/Winuser/nf-winuser-trackpopupmenuex) function with **TPM\_RECURSE**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MENUDRAG">
            <summary>Sent to the owner of a drag-and-drop menu when the user drags a menu item.</summary>
            <returns>
            <para>The application should return one of the following values.</para>
            <para>| Return code/value                                                                                                                                   | Description                                                                           | |-----------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------| | <dl> <dt>**MND\_CONTINUE**</dt> <dt>0</dt> </dl> | Menu should remain active. If the mouse is released, it should be ignored.<br/> | | <dl> <dt>**MND\_ENDMENU**</dt> <dt>1</dt> </dl>  | Menu should be ended.<br/>                                                      |</para>
            </returns>
            <remarks>
            <para>The application can call the [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) function in response to this message. To create a drag-and-drop menu, call [**SetMenuInfo**](/windows/desktop/api/Winuser/nf-winuser-setmenuinfo) with **MNS\_DRAGDROP**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menudrag#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MENUGETOBJECT">
            <summary>Sent to the owner of a drag-and-drop menu when the mouse cursor enters a menu item or moves from the center of the item to the top or bottom of the item.</summary>
            <returns>
            <para>The application should return one of the following values.</para>
            <para>| Return code/value                                                                                                                                                | Description                                                                                                            | |------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**MNGO\_NOERROR**</dt> <dt>0x00000001</dt> </dl>     | An interface pointer was returned in the **pvObj** member of [**MENUGETOBJECTINFO**](/windows/win32/api/winuser/ns-winuser-menugetobjectinfo)<br/> | | <dl> <dt>**MNGO\_NOINTERFACE**</dt> <dt>0x00000000</dt> </dl> | The interface is not supported.<br/>                                                                             |</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menugetobject">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_UNINITMENUPOPUP">
            <summary>Sent when a drop-down menu or submenu has been destroyed.</summary>
            <remarks>If an application receives a [**WM\_INITMENUPOPUP**](wm-initmenupopup.md) message, it will receive a **WM\_UNINITMENUPOPUP** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MENUCOMMAND">
            <summary>Sent when the user makes a selection from a menu.</summary>
            <remarks>
            <para>The **WM\_MENUCOMMAND** message gives you a handle to the menu so you can access the menu data in the [**MENUINFO**](/windows/win32/api/winuser/ns-winuser-menuinfo) structure and also gives you the index of the selected item, which is typically what applications need. In contrast, the [**WM\_COMMAND**](wm-command.md) message gives you the menu item identifier. The **WM\_MENUCOMMAND** message is sent only for menus that are defined with the **MNS\_NOTIFYBYPOS** flag set in the **dwStyle** member of the [**MENUINFO**](/windows/win32/api/winuser/ns-winuser-menuinfo) structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menucommand#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CHANGEUISTATE">
            <summary>An application sends the WM\_CHANGEUISTATE message to indicate that the UI state should be changed.</summary>
            <remarks>
            <para>A window should send this message to itself or its parent when it must change the UI state elements of all windows in the same hierarchy. The window procedure must let [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) process this message so that the entire window tree has a consistent UI state. When the top-level window receives the **WM\_CHANGEUISTATE** message, it sends a [**WM\_UPDATEUISTATE**](wm-updateuistate.md) message with the same parameters to all child windows. When the system processes the **WM\_UPDATEUISTATE** message, it makes the change in the UI state. If the low-order word of *wParam* is UIS\_INITIALIZE, the system will send the [**WM\_UPDATEUISTATE**](wm-updateuistate.md) message with a UI state based on the last input event. For example, if the last input came from the mouse, the system will hide the keyboard cues. And, if the last input came from the keyboard, the system will show the keyboard cues. If the state that results from processing **WM\_CHANGEUISTATE** is the same as the old state, [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) does not send this message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-changeuistate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_UPDATEUISTATE">
            <summary>An application sends the WM\_UPDATEUISTATE message to change the UI state for the specified window and all its child windows.</summary>
            <remarks>
            <para>A window should send this message to change the UI state of all its child windows. In contrast to the [**WM\_CHANGEUISTATE**](wm-changeuistate.md) message, which is a notification, when [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) processes the **WM\_UPDATEUISTATE** message it changes the UI state and propagates the changes to all child windows. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function updates the UI state according to the *wParam* value. If the UI state is modified, the function sends the message to all the immediate child windows. **DefWindowProc** also sends this message when it receives a [**WM\_CHANGEUISTATE**](wm-changeuistate.md) message notifying the system that a child window intends to modify the UI state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-updateuistate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_QUERYUISTATE">
            <summary>An application sends the WM\_QUERYUISTATE message to retrieve the UI state for a window.</summary>
            <returns>
            <para>The return value is **NULL** if the focus indicators and the keyboard accelerators are visible. Otherwise, the return value can be one or more of the following values.</para>
            <para>| Return code/value                                                                                                                                       | Description                                                                 | |---------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------| | <dl> <dt>**UISF\_ACTIVE**</dt> <dt>0x4</dt> </dl>    | A control should be drawn in the style used for active controls.<br/> | | <dl> <dt>**UISF\_HIDEACCEL**</dt> <dt>0x2</dt> </dl> | Keyboard accelerators are hidden.<br/>                                | | <dl> <dt>**UISF\_HIDEFOCUS**</dt> <dt>0x1</dt> </dl> | Focus indicators are hidden.<br/>                                     |</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-queryuistate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CTLCOLOREDIT">
            <summary>An edit control that is not read-only or disabled sends the WM\_CTLCOLOREDIT message to its parent window when the control is about to be drawn.</summary>
            <returns>If an application processes this message, it must return the handle of a brush. The system uses the brush to paint the background of the edit control.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the edit control. Read-only or disabled edit controls do not send the **WM\_CTLCOLOREDIT** message; instead, they send the [**WM\_CTLCOLORSTATIC**](wm-ctlcolorstatic.md) message. The **WM\_CTLCOLOREDIT** message is never sent between threads, it is only sent within the same thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored. **Rich Edit:** This message is not supported. To set the background color for a rich edit control, use the [**EM\_SETBKGNDCOLOR**](em-setbkgndcolor.md) message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcoloredit#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CTLCOLORLISTBOX">
            <summary>Sent to the parent window of a list box before the system draws the list box. By responding to this message, the parent window can set the text and background colors of the list box by using the specified display device context handle.</summary>
            <returns>If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the background of the list box.</returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the list box. The **WM\_CTLCOLORLISTBOX** message is never sent between threads. It is sent only within one thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorlistbox#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CTLCOLORBTN">
            <summary>The WM\_CTLCOLORBTN message is sent to the parent window of a button before drawing the button. The parent window can change the button's text and background colors. However, only owner-drawn buttons respond to the parent window processing this message.</summary>
            <returns>If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the background of the button.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the button. Buttons with the [**BS\_PUSHBUTTON**](button-styles.md), [**BS\_DEFPUSHBUTTON**](button-styles.md), or [**BS\_PUSHLIKE**](button-styles.md) styles do not use the returned brush. Buttons with these styles are always drawn with the default system colors. Drawing push buttons requires several different brushes-face, highlight, and shadow-but the **WM\_CTLCOLORBTN** message allows only one brush to be returned. To provide a custom appearance for push buttons, use an owner-drawn button. For more information, see [Creating Owner-Drawn Controls](user-controls-intro.md). The **WM\_CTLCOLORBTN** message is never sent between threads. It is sent only within one thread. The text color of a check box or radio button applies to the box or button, its check mark, and the text. The focus rectangle for these buttons remains the system default color (typically black). The text color of a group box applies to the text but not to the line that defines the box. The text color of a push button applies only to its focus rectangle; it does not affect the color of the text. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorbtn#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CTLCOLORDLG">
            <summary>Sent to a dialog box before the system draws the dialog box. By responding to this message, the dialog box can set its text and background colors using the specified display device context handle.</summary>
            <returns>If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the background of the dialog box.</returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the dialog box. The system does not automatically destroy the returned brush. It is the application's responsibility to destroy the brush when it is no longer needed. The **WM\_CTLCOLORDLG** message is never sent between threads. It is sent only within one thread. Note that the **WM\_CTLCOLORDLG** message is sent to the dialog box itself; all of the other **WM\_CTLCOLOR\*** messages are sent to the owner of the control. If a dialog box procedure handles this message, it should cast the desired return value to an **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-ctlcolordlg#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CTLCOLORSCROLLBAR">
            <summary>The WM\_CTLCOLORSCROLLBAR message is sent to the parent window of a scroll bar control when the control is about to be drawn.</summary>
            <returns>If an application processes this message, it must return the handle to a brush. The system uses the brush to paint the background of the scroll bar control.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the scroll bar control. The **WM\_CTLCOLORSCROLLBAR** message is never sent between threads; it is only sent within the same thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored. The **WM\_CTLCOLORSCROLLBAR** message is used only by child scroll bar controls. Scrollbars attached to a window (WS\_SCROLL and WS\_VSCROLL) do not generate this message. To customize the appearance of scrollbars attached to a window, use the flat scroll bar functions.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorscrollbar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CTLCOLORSTATIC">
            <summary>A static control, or an edit control that is read-only or disabled, sends the WM\_CTLCOLORSTATIC message to its parent window when the control is about to be drawn.</summary>
            <returns>If an application processes this message, the return value is a handle to a brush that the system uses to paint the background of the static control.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the static control. You can set the text background color of a disabled edit control, but you cannot set the text foreground color. The system always uses COLOR\_GRAYTEXT. Edit controls that are not read-only or disabled do not send the **WM\_CTLCOLORSTATIC** message; instead, they send the [**WM\_CTLCOLOREDIT**](wm-ctlcoloredit.md) message. The **WM\_CTLCOLORSTATIC** message is never sent between threads; it is sent only within the same thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorstatic#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MOUSEMOVE">
            <summary>Posted to a window when the cursor moves. If the mouse is not captured, the message is posted to the window that contains the cursor. Otherwise, the message is posted to the window that has captured the mouse.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousemove#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Windows.Win32.PInvokeCore.WM_LBUTTONDOWN" -->
        <member name="F:Windows.Win32.PInvokeCore.WM_LBUTTONUP">
            <summary>Posted when the user releases the left mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-lbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_LBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the left mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-lbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_RBUTTONDOWN">
            <summary>Posted when the user presses the right mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-rbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_RBUTTONUP">
            <summary>Posted when the user releases the right mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-rbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_RBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the right mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Only windows that have the **CS\_DBLCLKS** style can receive **WM\_RBUTTONDBLCLK** messages, which the system generates whenever the user presses, releases, and again presses the right mouse button within the system's double-click time limit. Double-clicking the right mouse button actually generates four messages: [**WM\_RBUTTONDOWN**](wm-rbuttondown.md), [**WM\_RBUTTONUP**](wm-rbuttonup.md), **WM\_RBUTTONDBLCLK**, and **WM\_RBUTTONUP** again. Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-rbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MBUTTONDOWN">
            <summary>Posted when the user presses the middle mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MBUTTONUP">
            <summary>Posted when the user releases the middle mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the middle mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MOUSEWHEEL">
            <summary>Sent to the focus window when the mouse wheel is rotated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousewheel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_XBUTTONDOWN">
            <summary>Posted when the user presses the first or second X button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-xbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_XBUTTONUP">
            <summary>Posted when the user releases the first or second X button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-xbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_XBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the first or second X button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-xbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MOUSEHWHEEL">
            <summary>Sent to the active window when the mouse's horizontal scroll wheel is tilted or rotated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousehwheel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PARENTNOTIFY">
            <summary>Sent to a window when a significant action occurs on a descendant window.</summary>
            <returns>
            <para>If the application processes this message, it returns zero. If the application does not process this message, it calls [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>This message is also sent to all ancestor windows of the child window, including the top-level window. All child windows, except those that have the **WS_EX_NOPARENTNOTIFY** extended window style, send this message to their parent windows. By default, child windows in a dialog box have the **WS_EX_NOPARENTNOTIFY** style, unless the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function is called to create the child window without this style. This notification provides the child window's ancestor windows an opportunity to examine the pointer information and, if required, capture the pointer using the pointer capture functions.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-parentnotify#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ENTERMENULOOP">
            <summary>Notifies an application's main window procedure that a menu modal loop has been entered.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns zero.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_EXITMENULOOP">
            <summary>Notifies an application's main window procedure that a menu modal loop has been exited.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns zero.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NEXTMENU">
            <summary>Sent to an application when the right or left arrow key is used to switch between the menu bar and the system menu.</summary>
            <remarks>In responding to this message, the application can specify the menu to switch to in the **hmenuNext** member of [**MDINEXTMENU**](/windows/win32/api/winuser/ns-winuser-mdinextmenu) and the window to receive the menu notification messages in the **hwndNext** member of the **MDINEXTMENU** structure. You must set both members for the changes to take effect (they are initially **NULL**).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SIZING">
            <summary>Sent to a window that the user is resizing. By processing this message, an application can monitor the size and position of the drag rectangle and, if needed, change its size or position.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return **TRUE** if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-sizing">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAPTURECHANGED">
            <summary>Sent to the window that is losing the mouse capture.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>A window receives this message even if it calls [**ReleaseCapture**](/windows/win32/api/winuser/nf-winuser-releasecapture) itself. An application should not attempt to set the mouse capture in response to this message. When it receives this message, a window should redraw itself, if necessary, to reflect the new mouse-capture state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-capturechanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MOVING">
            <summary>Sent to a window that the user is moving. By processing this message, an application can monitor the position of the drag rectangle and, if needed, change its position.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return **TRUE** if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-moving">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POWERBROADCAST">
            <summary>Notifies applications that a power-management event has occurred.</summary>
            <returns>An application should return **TRUE** if it processes this message.</returns>
            <remarks>
            <para>The system always sends a [PBT\_APMRESUMEAUTOMATIC](pbt-apmresumeautomatic.md) message whenever the system resumes. If the system resumes in response to user input such as pressing a key, the system also sends a **PBT\_APMRESUMESUSPEND** message after sending PBT\_APMRESUMEAUTOMATIC. **WM\_POWERBROADCAST** messages do not distinguish between different low-power states. An application can determine only that the system is entering or has resumed from a low-power state; it cannot determine the specific power state. The system records details about power state transitions in the Windows System event log. To prevent the system from transitioning to a low-power state in Windows Vista, an application must call [**SetThreadExecutionState**](/windows/desktop/api/Winbase/nf-winbase-setthreadexecutionstate) to inform the system that it is in use. The following messages are not supported on any of the operating systems specified in the Requirements section: - PBT_APMQUERYSTANDBY - PBT_APMQUERYSTANDBYFAILED - PBT_APMSTANDBY - PBT_APMRESUMESTANDBY</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Power/wm-powerbroadcast#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDICREATE">
            <summary>An application sends the WM\_MDICREATE message to a multiple-document interface (MDI) client window to create an MDI child window.</summary>
            <returns>
            <para>Type: **HWND** If the message succeeds, the return value is the handle to the new child window. If the message fails, the return value is **NULL**.</para>
            </returns>
            <remarks>
            <para>The MDI child window is created with the [**window style**](window-styles.md) bits **WS\_CHILD**, **WS\_CLIPSIBLINGS**, **WS\_CLIPCHILDREN**, **WS\_SYSMENU**, **WS\_CAPTION**, **WS\_THICKFRAME**, **WS\_MINIMIZEBOX**, and **WS\_MAXIMIZEBOX**, plus additional style bits specified in the [**MDICREATESTRUCT**](/windows/win32/api/winuser/ns-winuser-mdicreatestructa) structure. The system adds the title of the new child window to the window menu of the frame window. An application should use this message to create all child windows of the client window. If an MDI client window receives any message that changes the activation of its child windows while the active child window is maximized, the system restores the active child window and maximizes the newly activated child window. When an MDI child window is created, the system sends the [**WM\_CREATE**](wm-create.md) message to the window. The *lParam* parameter of the **WM\_CREATE** message contains a pointer to a [**CREATESTRUCT**](/windows/win32/api/winuser/ns-winuser-createstructa) structure. The *lpCreateParams* member of this structure contains a pointer to the [**MDICREATESTRUCT**](/windows/win32/api/winuser/ns-winuser-mdicreatestructa) structure passed with the **WM\_MDICREATE** message that created the MDI child window. An application should not send a second **WM\_MDICREATE** message while a **WM\_MDICREATE** message is still being processed. For example, it should not send a **WM\_MDICREATE** message while an MDI child window is processing its **WM\_MDICREATE** message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdicreate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDIDESTROY">
            <summary>An application sends the WM\_MDIDESTROY message to a multiple-document interface (MDI) client window to close an MDI child window.</summary>
            <returns>
            <para>Type: **zero** This message always returns zero.</para>
            </returns>
            <remarks>
            <para>This message removes the title of the MDI child window from the MDI frame window and deactivates the child window. An application should use this message to close all MDI child windows. If an MDI client window receives a message that changes the activation of its child windows and the active MDI child window is maximized, the system restores the active child window and maximizes the newly activated child window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdidestroy#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDIACTIVATE">
            <summary>An application sends the WM\_MDIACTIVATE message to a multiple-document interface (MDI) client window to instruct the client window to activate a different MDI child window.</summary>
            <returns>
            <para>Type: **LRESULT** If an application sends this message to an MDI client window, the return value is zero. An MDI child window should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>As the client window processes this message, it sends **WM\_MDIACTIVATE** to the child window being deactivated and to the child window being activated. The message parameters received by an MDI child window are as follows: <dl> <dt> <span id="wParam"></span><span id="wparam"></span><span id="WPARAM"></span>*wParam* </dt> <dd> A handle to the MDI child window being deactivated. </dd> <dt> <span id="lParam"></span><span id="lparam"></span><span id="LPARAM"></span>*lParam* </dt> <dd> A handle to the MDI child window being activated. </dd> </dl> An MDI child window is activated independently of the MDI frame window. When the frame window becomes active, the child window last activated by using the **WM\_MDIACTIVATE** message receives the [**WM\_NCACTIVATE**](wm-ncactivate.md) message to draw an active window frame and title bar; the child window does not receive another **WM\_MDIACTIVATE** message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdiactivate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDIRESTORE">
            <summary>An application sends the WM\_MDIRESTORE message to a multiple-document interface (MDI) client window to restore an MDI child window from maximized or minimized size.</summary>
            <returns>
            <para>Type: **zero** The return value is always zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdirestore">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDINEXT">
            <summary>An application sends the WM\_MDINEXT message to a multiple-document interface (MDI) client window to activate the next or previous child window.</summary>
            <returns>
            <para>Type: **zero** The return value is always zero.</para>
            </returns>
            <remarks>If an MDI client window receives any message that changes the activation of its child windows while the active MDI child window is maximized, the system restores the active child window and maximizes the newly activated child window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDIMAXIMIZE">
            <summary>An application sends the WM\_MDIMAXIMIZE message to a multiple-document interface (MDI) client window to maximize an MDI child window.</summary>
            <returns>
            <para>Type: **zero** The return value is always zero.</para>
            </returns>
            <remarks>If an MDI client window receives any message that changes the activation of its child windows while the currently active MDI child window is maximized, the system restores the active child window and maximizes the newly activated child window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDITILE">
            <summary>An application sends the WM\_MDITILE message to a multiple-document interface (MDI) client window to arrange all of its MDI child windows in a tile format.</summary>
            <returns>
            <para>Type: **BOOL** If the message succeeds, the return value is **TRUE**. If the message fails, the return value is **FALSE**.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mditile">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDICASCADE">
            <summary>An application sends the WM\_MDICASCADE message to a multiple-document interface (MDI) client window to arrange all its child windows in a cascade format.</summary>
            <returns>
            <para>Type: **BOOL** If the message succeeds, the return value is **TRUE**. If the message fails, the return value is **FALSE**.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdicascade">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDIICONARRANGE">
            <summary>An application sends the WM\_MDIICONARRANGE message to a multiple-document interface (MDI) client window to arrange all minimized MDI child windows. It does not affect child windows that are not minimized.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdiiconarrange">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDIGETACTIVE">
            <summary>An application sends the WM\_MDIGETACTIVE message to a multiple-document interface (MDI) client window to retrieve the handle to the active MDI child window.</summary>
            <returns>
            <para>Type: **HWND** The return value is the handle to the active MDI child window.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdigetactive">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDISETMENU">
            <summary>An application sends the WM\_MDISETMENU message to a multiple-document interface (MDI) client window to replace the entire menu of an MDI frame window, to replace the window menu of the frame window, or both.</summary>
            <returns>
            <para>Type: **HMENU** If the message succeeds, the return value is the handle to the old frame window menu. If the message fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>After sending this message, an application must call the [**DrawMenuBar**](/windows/win32/api/winuser/nf-winuser-drawmenubar) function to update the menu bar. If this message replaces the window menu, the MDI child window menu items are removed from the previous window menu and added to the new window menu. If an MDI child window is maximized and this message replaces the MDI frame window menu, the window menu icon and restore icon are removed from the previous frame window menu and added to the new frame window menu.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdisetmenu#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ENTERSIZEMOVE">
            <summary>Sent one time to a window after it enters the moving or sizing modal loop.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-entersizemove">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_EXITSIZEMOVE">
            <summary>Sent one time to a window, after it has exited the moving or sizing modal loop.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-exitsizemove">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DROPFILES">
            <summary>Sent when the user drops a file on the window of an application that has registered itself as a recipient of dropped files.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>The HDROP handle is declared in Shellapi.h. You must include this header in your build to use **WM\_DROPFILES**. For further discussion of how to use drag-and-drop to transfer Shell data, see [Transferring Shell Data Using Drag-and-Drop or the Clipboard](dragdrop.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_MDIREFRESHMENU">
            <summary>An application sends the WM\_MDIREFRESHMENU message to a multiple-document interface (MDI) client window to refresh the window menu of the MDI frame window.</summary>
            <returns>
            <para>Type: **HMENU** If the message succeeds, the return value is the handle to the frame window menu. If the message fails, the return value is **NULL**.</para>
            </returns>
            <remarks>After sending this message, an application must call the [**DrawMenuBar**](/windows/win32/api/winuser/nf-winuser-drawmenubar) function to update the menu bar.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERDEVICECHANGE">
            <summary>Sent to a window when there is a change in the settings of a monitor that has a digitizer attached to it. This message contains information regarding the scaling of the display mode.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdevicechange">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERDEVICEINRANGE">
            <summary>Sent to a window when a pointer device is detected within range of an input digitizer. This message contains information regarding the device and its proximity.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdeviceinrange">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERDEVICEOUTOFRANGE">
            <summary>Sent to a window when a pointer device has departed the range of an input digitizer. This message contains information regarding the device and its proximity.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdeviceoutofrange">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_TOUCH">
            <summary>Notifies the window when one or more touch points, such as a finger or pen, touches a touch-sensitive digitizer surface.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process the message, it must call [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). Not doing so causes the application to leak memory because the touch input handle is not closed and associated process memory is not freed.</para>
            </returns>
            <remarks>**WM\_TOUCH** messages do not respect **HTTRANSPARENT** regions of windows. If a window returns **HTTRANSPARENT** in response to a **WM\_NCHITTEST** message, mouse messages go to the parent, and **WM\_TOUCH** messages go directly to the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCPOINTERUPDATE">
            <summary>Posted to provide an update on a pointer that made contact over the non-client area of a window or when a hovering uncaptured contact moves over the non-client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>If the application does not process this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may perform one or more system actions depending on the hit-test result included in the message. Typically, applications should not need to handle this message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCPOINTERDOWN">
            <summary>Posted when a pointer makes contact over the non-client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>If the application does not process this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may perform one or more system actions depending on the hit-test result included in the message. Typically, applications should not need to handle this message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCPOINTERUP">
            <summary>Posted when a pointer that made contact over the non-client area of a window breaks contact.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>If the application does not process this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may perform one or more system actions depending on the hit-test result included in the message. Typically, applications should not need to handle this message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERUPDATE">
            <summary>Posted to provide an update on a pointer that made contact over the client area of a window or on a hovering uncaptured pointer over the client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>Each pointer has a unique pointer identifier during its lifetime. The lifetime of a pointer begins when it is first detected. A [**WM_POINTERENTER**](wm-pointerenter.md) message is generated if a hovering pointer is detected. A [**WM_POINTERDOWN**](wm-pointerdown.md) message followed by a **WM_POINTERENTER** message is generated if a non-hovering pointer is detected. During its lifetime, a pointer may generate a series of **WM_POINTERUPDATE** messages while it is hovering or in contact. The lifetime of a pointer ends when it is no longer detected. This generates a [**WM_POINTERLEAVE**](wm-pointerleave.md) message. When a pointer is aborted, [**POINTER_FLAG_CANCELED**](pointer-flags-contants.md) is set. A [**WM_POINTERLEAVE**](wm-pointerleave.md) message may also be generated when a non-captured pointer moves outside the bounds of a window. To obtain the horizontal and vertical position of a pointer, use the following:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerupdate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERDOWN">
            <summary>Posted when a pointer makes contact over the client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired **WM_POINTERDOWN**/[**WM_POINTERUP**](wm-pointerup.md) or [**WM_POINTERENTER**](wm-pointerenter.md)/[**WM_POINTERLEAVE**](wm-pointerleave.md) notifications.</para>
            <para>Each pointer has a unique pointer identifier during its lifetime. The lifetime of a pointer begins when it is first detected. A [**WM_POINTERENTER**](wm-pointerenter.md) message is generated if a hovering pointer is detected. A **WM_POINTERDOWN** message followed by a **WM_POINTERENTER** message is generated if a non-hovering pointer is detected. During its lifetime, a pointer may generate a series of [**WM_POINTERUPDATE**](wm-pointerupdate.md) messages while it is hovering or in contact. The lifetime of a pointer ends when it is no longer detected. This generates a [**WM_POINTERLEAVE**](wm-pointerleave.md) message. When a pointer is aborted, [**POINTER_FLAG_CANCELED**](pointer-flags-contants.md) is set. A [**WM_POINTERLEAVE**](wm-pointerleave.md) message may also be generated when a non-captured pointer moves outside the bounds of a window. To obtain the horizontal and vertical position of a pointer, use the following:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERUP">
            <summary>Posted when a pointer that made contact over the client area of a window breaks contact.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired [**WM_POINTERDOWN**](wm-pointerdown.md)/**WM_POINTERUP** or [**WM_POINTERENTER**](wm-pointerenter.md)/[**WM_POINTERLEAVE**](wm-pointerleave.md) notifications.</para>
            <para>Each pointer has a unique pointer identifier during its lifetime. The lifetime of a pointer begins when it is first detected. A [**WM_POINTERENTER**](wm-pointerenter.md) message is generated if a hovering pointer is detected. A [**WM_POINTERDOWN**](wm-pointerdown.md) message followed by a **WM_POINTERENTER** message is generated if a non-hovering pointer is detected. During its lifetime, a pointer may generate a series of [**WM_POINTERUPDATE**](wm-pointerupdate.md) messages while it is hovering or in contact. The lifetime of a pointer ends when it is no longer detected. This generates a [**WM_POINTERLEAVE**](wm-pointerleave.md) message. When a pointer is aborted, [**POINTER_FLAG_CANCELED**](pointer-flags-contants.md) is set. A [**WM_POINTERLEAVE**](wm-pointerleave.md) message may also be generated when a non-captured pointer moves outside the bounds of a window. To obtain the horizontal and vertical position of a pointer, use the following: Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERENTER">
            <summary>Sent to a window when a new pointer enters detection range over the window (hover) or when an existing pointer moves within the boundaries of the window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>The **WM_POINTERENTER** notification can be used by a window to provide feedback to the user while the pointer is over its surface or to otherwise react to the presence of a pointer over its surface. This notification is only sent to the window that is receiving input for the pointer. The following table lists some of the situations in which this notification is sent.</para>
            <para>| Action                                                   | Flags Set                                                                                                                                         | Notifications Sent To                                 | |----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------| | A new pointer enters detection range (hover).            | [**IS_POINTER_NEW_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_new_wparam)<br/> [**IS_POINTER_INRANGE_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_new_wparam)<br/> | Window over which the pointer enters detection range. | | A hovering pointer crosses within the window boundaries. | [**IS_POINTER_INRANGE_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_inrange_wparam)<br/>                                                                      | Window within which the pointer has crossed.          |</para>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired [**WM_POINTERDOWN**](wm-pointerdown.md)/[**WM_POINTERUP**](wm-pointerup.md) or **WM_POINTERENTER**/[**WM_POINTERLEAVE**](wm-pointerleave.md) notifications.</para>
            <para>When inputs come from the mouse, as a result of mouse and pointer message integration, **WM_POINTERENTER** is not sent.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerenter#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERLEAVE">
            <summary>Sent to a window when a pointer leaves detection range over the window (hover) or when a pointer moves outside the boundaries of the window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>The **WM_POINTERLEAVE** notification can be used by a window to change mode or stop any feedback to the user while the pointer is over the window surface. This notification is only sent to the window that is receiving input for the pointer. The following table lists some of the situations in which this notification is sent.</para>
            <para>| Action                                        | Flags Set                                                         | Notifications Sent To                                | |-----------------------------------------------|-------------------------------------------------------------------|------------------------------------------------------| | A hovering pointer crosses window boundaries. | [**IS_POINTER_INRANGE_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_inrange_wparam) | Window outside of whose boundary the pointer moved.  | | A pointer goes out of detection range.        | N/A                                                               | Window for which the pointer leaves detection range. |</para>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired [**WM_POINTERDOWN**](wm-pointerdown.md)/[**WM_POINTERUP**](wm-pointerup.md) or [**WM_POINTERENTER**](wm-pointerenter.md)/**WM_POINTERLEAVE** notifications.</para>
            <para>If contact is maintained with the input digitizer and the pointer moves outside the window, **WM_POINTERLEAVE** is not generated. **WM_POINTERLEAVE** is generated only when a hovering pointer crosses window boundaries or contact is terminated. **WM_POINTERLEAVE** is posted to the posted message queue if the input is originated from a mouse device.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerleave#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERACTIVATE">
            <summary>Sent to an inactive window when a primary pointer generates a WM_POINTERDOWN over the window.</summary>
            <returns>
            <para>If an application processes this message, it should return one of the values described in the Remarks section. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>An application can handle this message and return one of the following values to determine how the system processes the activation and the activating input: -   PA_ACTIVATE -   PA_NOACTIVATE It is important to note that, when the user is interacting with the system with multiple simultaneous pointers, the activation opportunity that the **WM_POINTERACTIVATE** message represents is available to applications only for the first of those pointers. Applications should, therefore, be aware that they may still receive input from pointers while they are inactive. If the application does not handle this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) passes the message to the parent window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointeractivate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERCAPTURECHANGED">
            <summary>Sent to a window that is losing capture of an input pointer.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>A window should use this notification to stop processing subsequent messages and initiate any cleanup required for the pointer being lost. Processing of gestures associated with the pointer should also be terminated (for example, by calling [**StopInteractionContext**](/windows/win32/api/interactioncontext/nf-interactioncontext-stopinteractioncontext)) and remaining contacts re-associated with the window. Typically, if a window receives the **WM_POINTERCAPTURECHANGED** notification, no subsequent notifications related to the input pointer are received. Because of this, do not depend on paired notifications such as [**WM_POINTERENTER**](wm-pointerenter.md) and [**WM_POINTERLEAVE**](wm-pointerleave.md). **WM_POINTERCAPTURECHANGED** does not include [**POINTER_INFO**](/windows/win32/api/winuser/ns-winuser-pointer_info) data. Other than the [**POINTER_FLAG_CAPTURECHANGED**](pointer-flags-contants.md) flag being set, the data returned by [**GetPointerInfo**](/windows/win32/api/winuser/ns-winuser-pointer_info) (or any variant) is identical to that returned prior to the notification. If the application does not process this notification, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may generate one or more [**WM_GESTURE**](../wintouch/wm-gesture.md) messages or, if a gesture is not recognized, **DefWindowProc** may generate mouse input. If an application selectively consumes some pointer input and passes the rest to [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca), the resulting behavior is undefined.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointercapturechanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_TOUCHHITTESTING">
            <summary>Sent to a window on a touch down in order to determine the most probable touch target.</summary>
            <returns>
            <para>If one or more elements are within the touch contact area, an application should return the result of [**PackTouchHitTestingProximityEvaluation**](/windows/win32/api/winuser/nf-winuser-packtouchhittestingproximityevaluation). If no elements are within the touch contact area, an application should set the value of **score** in [**TOUCH_HIT_TESTING_PROXIMITY_EVALUATION**](/windows/win32/api/winuser/ns-winuser-touch_hit_testing_proximity_evaluation) to [**TOUCH_HIT_TESTING_PROXIMITY_FARTHEST**](/previous-versions/windows/desktop/input_touchhittest/hit-testing-scores) and call [**PackTouchHitTestingProximityEvaluation**](/windows/win32/api/winuser/nf-winuser-packtouchhittestingproximityevaluation) to get the LRESULT return value. If the application does not process this message, it must call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>This message is sent to windows that register through the [**RegisterTouchHitTestingWindow**](/windows/win32/api/winuser/nf-winuser-registertouchhittestingwindow) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERWHEEL">
            <summary>Posted to the window with foreground keyboard focus when a scroll wheel is rotated.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>To retrieve the wheel scroll units, use the **inputData** filed of the [**POINTER_INFO**](/windows/win32/api/winuser/ns-winuser-pointer_info) structure returned by calling [**GetPointerInfo**](/windows/win32/api/winuser/ns-winuser-pointer_info) function. This field contains a signed value and is expressed in a multiple of **WHEEL_DELTA**. A positive value indicates a rotation forward and a negative value indicates a rotation backward. Note that the wheel inputs may be delivered even if the mouse cursor is located outside of application s window. The wheel messages are delivered in a way very similar to the keyboard inputs. The focus window of the foregournd message queue receives the wheel messages.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerwheel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERHWHEEL">
            <summary>Posted to the window with foreground keyboard focus when a horizontal scroll wheel is rotated.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>To retrieve the wheel scroll units, use the **inputData** filed of the [**POINTER_INFO**](/windows/win32/api/winuser/ns-winuser-pointer_info) structure returned by calling [**GetPointerInfo**](/windows/win32/api/winuser/ns-winuser-pointer_info) function. This field contains a signed value and is expressed in a multiple of **WHEEL_DELTA**. A positive value indicates a rotation forward and a negative value indicates a rotation backward. Note that the wheel inputs may be delivered even if the mouse cursor is located outside of application s window. The wheel messages are delivered in a way very similar to the keyboard inputs. The focus window of the foregournd message queue receives the wheel messages.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerhwheel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERROUTEDTO">
            <summary>Sent when ongoing pointer input, for an existing pointer ID, transitions from one process to another across content configured for cross-process chaining (AddContentWithCrossProcessChaining).</summary>
            <returns>NULL</returns>
            <remarks>
            <para>This message is not sent when a [**WM_POINTERDOWN**](wm-pointerdown.md) message is posted for a new pointer ID on a different process. A [**WM_POINTERDOWN**](wm-pointerdown.md) message is not sent if a **WM_POINTERROUTEDTO** message is posted first.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerroutedto#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERROUTEDAWAY">
            <summary>Occurs on the process receiving input when the pointer input is routed to another process.AddContentWithCrossProcessChaining).</summary>
            <returns>NULL</returns>
            <remarks>This message is not sent with either a [**WM_POINTERUP**](wm-pointerup.md) message or a [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_POINTERROUTEDRELEASED">
            <summary>Sent to all processes (configured for cross-process chaining through AddContentWithCrossProcessChaining and not currently handling pointer input) ever associated with a specific pointer ID, when a WM_POINTERUP message is received on the current process.</summary>
            <returns>NULL</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerroutedreleased">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_SETCONTEXT">
            <summary>Sent to an application when a window is activated. A window receives this message through its WindowProc function.</summary>
            <returns>Returns the value returned by [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) or [**ImmIsUIMessage**](/windows/desktop/api/Imm/nf-imm-immisuimessagea).</returns>
            <remarks>
            <para>If the application has created an IME window, it should call [**ImmIsUIMessage**](/windows/desktop/api/Imm/nf-imm-immisuimessagea). Otherwise, it should pass this message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca). If the application draws the composition window, the default IME window does not have to show its composition window. In this case, the application must clear the **ISC\_SHOWUICOMPOSITIONWINDOW** value from the *lParam* parameter before passing the message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) or [**ImmIsUIMessage**](/windows/desktop/api/Imm/nf-imm-immisuimessagea). To display a certain user interface window, an application should remove the corresponding value so that the IME will not display it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-setcontext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_NOTIFY">
            <summary>Sent to an application to notify it of changes to the IME window. A window receives this message through its WindowProc function.</summary>
            <returns>The return value depends on the command sent.</returns>
            <remarks>An application processes this message if it is responsible for managing the IME window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_CONTROL">
            <summary>Sent by an application to direct the IME window to carry out the requested command.</summary>
            <returns>The message returns a command-specific value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-control">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_COMPOSITIONFULL">
            <summary>Sent to an application when the IME window finds no space to extend the area for the composition window. A window receives this message through its WindowProc function.</summary>
            <returns>
            <para>This message has no parameters.</para>
            <para>This message has no return value.</para>
            </returns>
            <remarks>
            <para>The application should use the [IMC\_SETCOMPOSITIONWINDOW](imc-setcompositionwindow.md) command to specify how the window should be displayed. The IME window, instead of the IME, sends this notification message by the [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-compositionfull#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_SELECT">
            <summary>Sent to an application when the operating system is about to change the current IME. A window receives this message through its WindowProc function.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>An application that has created an IME window should pass this message to that window so that it can retrieve the keyboard layout handle to the newly selected IME. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function processes this message by passing the information to the default IME window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-select#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_CHAR">
            <summary>Sent to an application when the IME gets a character of the conversion result. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>Unlike the [**WM\_CHAR**](../inputdev/wm-char.md) message for a non-Unicode window, this message can include double-byte and single-byte character values. For a Unicode window, this message is the same as WM\_CHAR. For a non-Unicode window, if the WM\_IME\_CHAR message includes a double-byte character and the application passes this message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca), the IME converts this message into two WM\_CHAR messages, each containing one byte of the double-byte character.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-char#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_REQUEST">
            <summary>Sent to an application to provide commands and request information. A window receives this message through its WindowProc function.</summary>
            <returns>Returns a command-specific value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-request">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_KEYDOWN">
            <summary>Sent to an application by the IME to notify the application of a key press and to keep message order. A window receives this message through its WindowProc function.</summary>
            <returns>An application should return 0 if it processes this message.</returns>
            <remarks>An application can process this message or pass it to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function to generate a matching [**WM\_KEYDOWN**](../inputdev/wm-keydown.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_IME_KEYUP">
            <summary>Sent to an application by the IME to notify the application of a key release and to keep message order. A window receives this message through its WindowProc function.</summary>
            <returns>An application should return 0 if it processes this message.</returns>
            <remarks>An application can process this message or pass it to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function to generate a matching [**WM\_KEYUP**](../inputdev/wm-keyup.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCMOUSEHOVER">
            <summary>Posted to a window when the cursor hovers over the nonclient area of the window for the period of time specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Hover tracking stops when this message is generated. The application must call [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) again if it requires further tracking of mouse hover behavior. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmousehover#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_NCMOUSELEAVE">
            <summary>Posted to a window when the cursor leaves the nonclient area of the window specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>All tracking requested by [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) is canceled when this message is generated. The application must call **TrackMouseEvent** when the mouse reenters its window if it requires further tracking of mouse hover behavior.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DPICHANGED">
            <summary>Sent when the effective dots per inch (dpi) for a window has changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>This message is only relevant for **PROCESS\_PER\_MONITOR\_DPI\_AWARE** applications or **DPI\_AWARENESS\_PER\_MONITOR\_AWARE** threads. It may be received on certain DPI changes if your top-level window or process is running as **DPI unaware** or **system DPI aware**, but in those situations it can be safely ignored. For more information about the different types of awareness, see [**PROCESS\_DPI\_AWARENESS**](/windows/desktop/api/ShellScalingApi/ne-shellscalingapi-process_dpi_awareness) and [**DPI\_AWARENESS**](/windows/desktop/api/windef/ne-windef-dpi_awareness). Older versions of Windows required DPI awareness to be tied at the level of an application. Those apps use **PROCESS\_DPI\_AWARENESS**. Currently, DPI awareness is tied to threads and individual windows rather than the entire application. These apps use **DPI\_AWARENESS**. You only need to use either the X-axis or the Y-axis value when scaling your application since they are the same. In order to handle this message correctly, you will need to resize and reposition your window based on the suggestions provided by *lParam* and using [**SetWindowPos**](/windows/desktop/api/winuser/nf-winuser-setwindowpos). If you do not do this, your window will grow or shrink with respect to everything else on the new monitor. For example, if a user is using multiple monitors and drags your window from a 96 DPI monitor to a 192 DPI monitor, your window will appear to be half as large with respect to other items on the 192 DPI monitor. The base value of DPI is defined as **USER\_DEFAULT\_SCREEN\_DPI** which is set to 96. To determine the scaling factor for a monitor, take the DPI value and divide by **USER\_DEFAULT\_SCREEN\_DPI**. The following table provides some sample DPI values and associated scaling factors.</para>
            <para>| DPI value | Scaling percentage | |-----------|--------------------| | 96        | 100%               | | 120       | 125%               | | 144       | 150%               | | 192       | 200%               |</para>
            <para>The following example provides a sample DPI change handler.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DPICHANGED_BEFOREPARENT">
            <summary>For Per Monitor v2 top-level windows, this message is sent to all HWNDs in the child HWDN tree of the window that is undergoing a DPI change. | WM_DPICHANGED_BEFOREPARENT message (Winuser.h)</summary>
            <returns>This value is unused and ignored by the system.</returns>
            <remarks>
            <para>There is no default handling of this message in [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). This message is only sent when the top-level window has a DPI awareness context of PMv2.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged-beforeparent#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DPICHANGED_AFTERPARENT">
            <summary>For Per Monitor v2 top-level windows, this message is sent to all HWNDs in the child HWDN tree of the window that is undergoing a DPI change. | WM_DPICHANGED_AFTERPARENT message (Winuser.h)</summary>
            <returns>This value is unused and ignored by the system.</returns>
            <remarks>
            <para>There is no default handling of this message in [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). This message is only sent when the top-level window has a DPI awareness context of PMv2.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged-afterparent#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GETDPISCALEDSIZE">
            <summary>This message tells the operating system that the window will be sized to dimensions other than the default.</summary>
            <returns>The function returns a BOOL. Returning TRUE indicates that a new size has been computed. Returning FALSE indicates that the message will not be handled, and the default linear DPI scaling will apply to the window.</returns>
            <remarks>
            <para>This message is only sent to top-level windows which have a DPI awareness context of Per Monitor v2. This event is necessary to facilitate graceful non-linear scaling, and ensures that the windows's position remains constant in relationship to the cursor and when moving back and forth across monitors. There is no specific default handling of this message in [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). As for all messages it does not explicitly handle, [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca) will return zero for this message. As noted above, this return tells the system to use the default linear behavior.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-getdpiscaledsize#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CUT">
            <summary>An application sends a WM\_CUT message to an edit control or combo box to delete (cut) the current selection, if any, in the edit control and copy the deleted text to the clipboard in CF\_TEXT format.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The deletion performed by the **WM\_CUT** message can be undone by sending the edit control an [**EM\_UNDO**](../controls/em-undo.md) message. To delete the current selection without placing the deleted text on the clipboard, use the [**WM\_CLEAR**](wm-clear.md) message. When sent to a combo box, the **WM\_CUT** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-cut#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_COPY">
            <summary>An application sends the WM\_COPY message to an edit control or combo box to copy the current selection to the clipboard in CF\_TEXT format.</summary>
            <returns>Returns nonzero value on success, else zero.</returns>
            <remarks>When sent to a combo box, the **WM\_COPY** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PASTE">
            <summary>An application sends a WM\_PASTE message to an edit control or combo box to copy the current content of the clipboard to the edit control at the current caret position. Data is inserted only if the clipboard contains data in CF\_TEXT format.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>When sent to a combo box, the **WM\_PASTE** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CLEAR">
            <summary>An application sends a WM\_CLEAR message to an edit control or combo box to delete (clear) the current selection, if any, from the edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The deletion performed by the **WM\_CLEAR** message can be undone by sending the edit control an [**EM\_UNDO**](../controls/em-undo.md) message. To delete the current selection and place the deleted content on the clipboard, use the [**WM\_CUT**](wm-cut.md) message. When sent to a combo box, the **WM\_CLEAR** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-clear#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_UNDO">
            <summary>An application sends a WM\_UNDO message to an edit control to undo the last operation. When this message is sent to an edit control, the previously deleted text is restored or the previously added text is deleted.</summary>
            <returns>
            <para>If the message succeeds, the return value is **TRUE**. If the message fails, the return value is **FALSE**.</para>
            </returns>
            <remarks>**Rich Edit:** It is recommended that [**EM\_UNDO**](em-undo.md) be used instead of **WM\_UNDO**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_RENDERFORMAT">
            <summary>Sent to the clipboard owner if it has delayed rendering a specific clipboard format and if an application has requested data in that format.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>When responding to a **WM\_RENDERFORMAT** message, the clipboard owner must not open the clipboard before calling [**SetClipboardData**](/windows/win32/api/winuser/nf-winuser-setclipboarddata). Opening the clipboard is not necessary before placing data in response to **WM\_RENDERFORMAT**, and any attempt to open the clipboard will fail because the clipboard is currently being held open by the application that requested the format to be rendered.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_RENDERALLFORMATS">
            <summary>Sent to the clipboard owner before it is destroyed, if the clipboard owner has delayed rendering one or more clipboard formats.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>When responding to a **WM\_RENDERALLFORMATS** message, the application must call the [**OpenClipboard**](/windows/win32/api/winuser/nf-winuser-openclipboard) function and then check that it is still the clipboard owner by calling the [**GetClipboardOwner**](/windows/win32/api/winuser/nf-winuser-getclipboardowner) function before calling [**SetClipboardData**](/windows/win32/api/winuser/nf-winuser-setclipboarddata). The application needs to check that it is still the clipboard owner after opening the clipboard because after it receives the **WM\_RENDERALLFORMATS** message, but before it opens the clipboard, another application may have opened and taken ownership of the clipboard, and that application's data should not be overwritten. In most cases, the application should not call the [**EmptyClipboard**](/windows/win32/api/winuser/nf-winuser-emptyclipboard) function before calling [**SetClipboardData**](/windows/win32/api/winuser/nf-winuser-setclipboarddata), since doing so will erase the clipboard formats that the application has already rendered. When the application returns, the system removes any unrendered formats from the list of available clipboard formats. For information about delayed rendering, see [Delayed Rendering](clipboard-operations.md#delayed-rendering).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-renderallformats#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DESTROYCLIPBOARD">
            <summary>Sent to the clipboard owner when a call to the EmptyClipboard function empties the clipboard. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-destroyclipboard">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DRAWCLIPBOARD">
            <summary>Sent to the first window in the clipboard viewer chain when the content of the clipboard changes. This enables a clipboard viewer window to display the new content of the clipboard. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>Only clipboard viewer windows receive this message. These are windows that have been added to the clipboard viewer chain by using the [**SetClipboardViewer**](/windows/desktop/api/Winuser/nf-winuser-setclipboardviewer) function. Each window that receives the **WM\_DRAWCLIPBOARD** message must call the [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) function to pass the message on to the next window in the clipboard viewer chain. The handle to the next window in the chain is returned by [**SetClipboardViewer**](/windows/desktop/api/Winuser/nf-winuser-setclipboardviewer), and may change in response to a [**WM\_CHANGECBCHAIN**](wm-changecbchain.md) message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-drawclipboard#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PAINTCLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF\_OWNERDISPLAY format and the clipboard viewer's client area needs repainting.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>To determine whether the entire client area or just a portion of it needs repainting, the clipboard owner must compare the dimensions of the drawing area given in the **rcPaint** member of [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) to the dimensions given in the most recent [**WM\_SIZECLIPBOARD**](wm-sizeclipboard.md) message. The clipboard owner must use the [**GlobalLock**](/windows/desktop/api/winbase/nf-winbase-globallock) function to lock the memory that contains the [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) structure. Before returning, the clipboard owner must unlock that memory by using the [**GlobalUnlock**](/windows/desktop/api/winbase/nf-winbase-globalunlock) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-paintclipboard#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_VSCROLLCLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF\_OWNERDISPLAY format and an event occurs in the clipboard viewer's vertical scroll bar.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>The clipboard owner can use the [**ScrollWindow**](https://msdn.microsoft.com/library/Cc410994(v=MSDN.10).aspx) function to scroll the image in the clipboard viewer window and invalidate the appropriate region.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_SIZECLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF\_OWNERDISPLAY format and the clipboard viewer's client area has changed size.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>When the clipboard viewer window is about to be destroyed or resized, a **WM\_SIZECLIPBOARD** message is sent with a null rectangle (0, 0, 0, 0) as the new size. This permits the clipboard owner to free its display resources. The clipboard owner must use the [**GlobalLock**](/windows/desktop/api/winbase/nf-winbase-globallock) function to lock the memory object that contains [**RECT**](/windows/win32/api/windef/ns-windef-rect). Before returning, the clipboard owner must unlock the object by using the [**GlobalUnlock**](/windows/desktop/api/winbase/nf-winbase-globalunlock) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-sizeclipboard#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ASKCBFORMATNAME">
            <summary>Sent to the clipboard owner by a clipboard viewer window to request the name of a CF\_OWNERDISPLAY clipboard format.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>In response to this message, the clipboard owner should copy the name of the owner-display format to the specified buffer, not exceeding the buffer size specified by the *wParam* parameter. A clipboard viewer window sends this message to the clipboard owner to determine the name of the [**CF\_OWNERDISPLAY**](standard-clipboard-formats.md) format   for example, to initialize a menu listing available formats.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-askcbformatname#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CHANGECBCHAIN">
            <summary>Sent to the first window in the clipboard viewer chain when a window is being removed from the chain. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Each clipboard viewer window saves the handle to the next window in the clipboard viewer chain. Initially, this handle is the return value of the [**SetClipboardViewer**](/windows/desktop/api/Winuser/nf-winuser-setclipboardviewer) function. When a clipboard viewer window receives the **WM\_CHANGECBCHAIN** message, it should call the [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) function to pass the message to the next window in the chain, unless the next window is the window being removed. In this case, the clipboard viewer should save the handle specified by the *lParam* parameter as the next window in the chain.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-changecbchain#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_HSCROLLCLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>The clipboard owner can use the [**ScrollWindow**](https://msdn.microsoft.com/library/Cc410994(v=MSDN.10).aspx) function to scroll the image in the clipboard viewer window and invalidate the appropriate region.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_QUERYNEWPALETTE">
            <summary>The WM\_QUERYNEWPALETTE message informs a window that it is about to receive the keyboard focus, giving the window the opportunity to realize its logical palette when it receives the focus.</summary>
            <returns>If the window realizes its logical palette, it must return **TRUE**; otherwise, it must return **FALSE**.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-querynewpalette">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PALETTEISCHANGING">
            <summary>The WM\_PALETTEISCHANGING message informs applications that an application is going to realize its logical palette.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The application changing its palette does not wait for acknowledgment of this message before changing the palette and sending the [**WM\_PALETTECHANGED**](wm-palettechanged.md) message. As a result, the palette may already be changed by the time an application receives this message. If the application either ignores or fails to process this message and a second application realizes its palette while the first is using palette indexes, there is a strong possibility that the user will see unexpected colors during subsequent drawing operations.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-paletteischanging#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PALETTECHANGED">
            <summary>The WM\_PALETTECHANGED message is sent to all top-level and overlapped windows after the window with the keyboard focus has realized its logical palette, thereby changing the system palette.</summary>
            <remarks>
            <para>This message must be sent to all top-level and overlapped windows, including the one that changed the system palette. If any child windows use a color palette, this message must be passed on to them as well. To avoid creating an infinite loop, a window that receives this message must not realize its palette, unless it determines that *wParam* does not contain its own window handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-palettechanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_HOTKEY">
            <summary>Posted when the user presses a hot key registered by the RegisterHotKey function. The message is placed at the top of the message queue associated with the thread that registered the hot key.</summary>
            <remarks>**WM\_HOTKEY** is unrelated to the [**WM\_GETHOTKEY**](wm-gethotkey.md) and [**WM\_SETHOTKEY**](wm-sethotkey.md) hot keys. The **WM\_HOTKEY** message is sent for generic hot keys while the **WM\_SETHOTKEY** and **WM\_GETHOTKEY** messages relate to window activation hot keys.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_PRINT">
            <summary>The WM\_PRINT message is sent to a window to request that it draw itself in the specified device context, most commonly in a printer device context.</summary>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function processes this message based on which drawing option is specified: if PRF\_CHECKVISIBLE is specified and the window is not visible, do nothing, if PRF\_NONCLIENT is specified, draw the nonclient area in the specified device context, if PRF\_ERASEBKGND is specified, send the window a [**WM\_ERASEBKGND**](../winmsg/wm-erasebkgnd.md) message, if PRF\_CLIENT is specified, send the window a [**WM\_PRINTCLIENT**](wm-printclient.md) message, if PRF\_CHILDREN is set, send each visible child window a **WM\_PRINT** message, if PRF\_OWNED is set, send each visible owned window a **WM\_PRINT** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_APPCOMMAND">
            <summary>Notifies a window that the user generated an application command event, for example, by clicking an application command button using the mouse or typing an application command key on the keyboard.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>[**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) generates the **WM\_APPCOMMAND** message when it processes the [**WM\_XBUTTONUP**](wm-xbuttonup.md) or [**WM\_NCXBUTTONUP**](wm-ncxbuttonup.md) message, or when the user types an application command key. If a child window does not process this message and instead calls [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca), **DefWindowProc** will send the message to its parent window. If a top level window does not process this message and instead calls **DefWindowProc**, **DefWindowProc** will call a shell hook with the hook code equal to **HSHELL\_APPCOMMAND**. To get the coordinates of the cursor if the message was generated by a mouse click, the application can call [**GetMessagePos**](/windows/desktop/api/winuser/nf-winuser-getmessagepos). An application can test whether the message was generated by the mouse by checking whether *lParam* contains **FAPPCOMMAND\_MOUSE**. Unlike other windows messages, an application should return **TRUE** from this message if it processes it. Doing so will allow software that simulates this message on Windows systems earlier than Windows 2000 to determine whether the window procedure processed the message or called [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) to process it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-appcommand#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_THEMECHANGED">
            <summary>Broadcast to every window following a theme change event. Examples of theme change events are the activation of a theme, the deactivation of a theme, or a transition from one theme to another.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. > [!Note] > This message is posted by the operating system. Applications typically do not send this message.</para>
            <para>Themes are specifications for the appearance of controls, so that the visual element of a control is treated separately from its functionality. To release an existing theme handle, call [**CloseThemeData**](/windows/win32/api/uxtheme/nf-uxtheme-closethemedata). To acquire a new theme handle, use [**OpenThemeData**](/windows/win32/api/uxtheme/nf-uxtheme-openthemedata). Following the **WM\_THEMECHANGED** broadcast, any existing theme handles are invalid. A theme-aware window should release and reopen any of its pre-existing theme handles when it receives the **WM\_THEMECHANGED** message. If the [**OpenThemeData**](/windows/win32/api/uxtheme/nf-uxtheme-openthemedata) function returns **NULL**, the window should paint unthemed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-themechanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CLIPBOARDUPDATE">
            <summary>Sent when the contents of the clipboard have changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>To register a window to receive this message, use the [**AddClipboardFormatListener**](/windows/desktop/api/Winuser/nf-winuser-addclipboardformatlistener) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DWMCOMPOSITIONCHANGED">
            <summary>Informs all top-level windows that Desktop Window Manager (DWM) composition has been enabled or disabled.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. The [**DwmIsCompositionEnabled**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmiscompositionenabled) function can be used to determine the current composition state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmcompositionchanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DWMNCRENDERINGCHANGED">
            <summary>Sent when the non-client area rendering policy has changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. The [**DwmGetWindowAttribute**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmgetwindowattribute) and [**DwmSetWindowAttribute**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmsetwindowattribute) functions are used to get or set the non-client rendering policy.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmncrenderingchanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DWMCOLORIZATIONCOLORCHANGED">
            <summary>Informs all top-level windows that the colorization color has changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. [**DwmGetColorizationColor**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmgetcolorizationcolor) is used to determine the current color value.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmcolorizationcolorchanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DWMWINDOWMAXIMIZEDCHANGE">
            <summary>Sent when a Desktop Window Manager (DWM) composed window is maximized.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DWMSENDICONICTHUMBNAIL">
            <summary>Instructs a window to provide a static bitmap to use as a thumbnail representation of that window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>DWM sends this message to a window if all of the following situations are true: -   DWM is displaying an iconic representation of the window. -   The [**DWMWA\_HAS\_ICONIC\_BITMAP**](/windows/desktop/api/Dwmapi/ne-dwmapi-dwmwindowattribute) attribute is set on the window. -   The window did not set a cached bitmap. -   There is room in the cache for another bitmap. The window that receives this message should respond by generating a bitmap that is not larger than the size that is requested in the message parameters. The window then calls the [**DwmSetIconicThumbnail**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmseticonicthumbnail) function to override the default thumbnail. If the window does not supply a bitmap in a given amount of time, DWM uses its own default iconic representation for the window. The window must belong to the calling process.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmsendiconicthumbnail#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_DWMSENDICONICLIVEPREVIEWBITMAP">
            <summary>Instructs a window to provide a static bitmap to use as a live preview (also known as a Peek preview) of that window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A *live preview* (also known as a *Peek preview*) of a window appears when a user moves the mouse pointer over the window's thumbnail in the taskbar or gives the thumbnail focus in the ALT+TAB window. This view is a full-sized preview of the window and can be a live snapshot or an iconic representation. Desktop Window Manager (DWM) sends this message to a window if all of the following situations are true: -   Live preview has been invoked on the window. -   The [**DWMWA\_HAS\_ICONIC\_BITMAP**](/windows/desktop/api/Dwmapi/ne-dwmapi-dwmwindowattribute) attribute is set on the window. -   An iconic representation is the only one that exists for this window. The window that receives this message should respond by generating a full-scale bitmap. The window then calls the [**DwmSetIconicLivePreviewBitmap**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmseticoniclivepreviewbitmap) function to set the live preview. If the window does not set a bitmap in a given amount of time, DWM uses its own default iconic representation for the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmsendiconiclivepreviewbitmap#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_GETTITLEBARINFOEX">
            <summary>Sent to request extended title bar information. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>The following example shows how the message receiver casts an **LPARAM** value to retrieve the [**TITLEBARINFOEX**](/windows/win32/api/winuser/ns-winuser-titlebarinfoex) structure. `TITLEBARINFOEX *ptinfo = (TITLEBARINFOEX *)lParam;`</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-gettitlebarinfoex#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_APP">
            <summary>Used to define private messages, usually of the form WM\_APP+x, where x is an integer value.</summary>
            <remarks>
            <para>The **WM\_APP** constant is used to distinguish between message values that are reserved for use by the system and values that can be used by an application to send messages within a private window class. The following are the ranges of message numbers available.</para>
            <para>| Range                                                 | Meaning                                                        | |-------------------------------------------------------|----------------------------------------------------------------| | 0 through [**WM\_USER**](wm-user.md) –1<br/>   | Messages reserved for use by the system.<br/>            | | [**WM\_USER**](wm-user.md) through 0x7FFF<br/> | Integer messages for use by private window classes.<br/> | | **WM\_APP** through 0xBFFF<br/>                 | Messages available for use by applications.<br/>         | | 0xC000 through 0xFFFF<br/>                      | String messages for use by applications.<br/>            | | Greater than 0xFFFF<br/>                        | Reserved by the system.<br/>                             |</para>
            <para>Message numbers in the first range (0 through [**WM\_USER**](wm-user.md) –1) are defined by the system. Values in this range that are not explicitly defined are reserved by the system. Message numbers in the second range ([**WM\_USER**](wm-user.md) through 0x7FFF) can be defined and used by an application to send messages within a private window class. These values cannot be used to define messages that are meaningful throughout an application because some predefined window classes already define values in this range. For example, predefined control classes such as **BUTTON**, **EDIT**, **LISTBOX**, and **COMBOBOX** may use these values. Messages in this range should not be sent to other applications unless the applications have been designed to exchange messages and to attach the same meaning to the message numbers. Message numbers in the third range (0x8000 through 0xBFFF) are available for applications to use as private messages. Messages in this range do not conflict with system messages. Message numbers in the fourth range (0xC000 through 0xFFFF) are defined at run time when an application calls the [**RegisterWindowMessage**](/windows/win32/api/winuser/nf-winuser-registerwindowmessagea) function to retrieve a message number for a string. All applications that register the same string can use the associated message number for exchanging messages. The actual message number, however, is not a constant and cannot be assumed to be the same between different sessions. Message numbers in the fifth range (greater than 0xFFFF) are reserved by the system.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-app#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_USER">
            <summary>Used to define private messages for use by private window classes, usually of the form WM\_USER+x, where x is an integer value.</summary>
            <remarks>
            <para>The following are the ranges of message numbers.</para>
            <para>| Range                                                        | Meaning                                                        | |--------------------------------------------------------------|----------------------------------------------------------------| | 0 through **WM\_USER** –1<br/>                         | Messages reserved for use by the system.<br/>            | | **WM\_USER** through 0x7FFF<br/>                       | Integer messages for use by private window classes.<br/> | | [**WM\_APP**](wm-app.md) (0x8000) through 0xBFFF<br/> | Messages available for use by applications.<br/>         | | 0xC000 through 0xFFFF<br/>                             | String messages for use by applications.<br/>            | | Greater than 0xFFFF<br/>                               | Reserved by the system.<br/>                             |</para>
            <para>Message numbers in the first range (0 through **WM\_USER** –1) are defined by the system. Values in this range that are not explicitly defined are reserved by the system. Message numbers in the second range (**WM\_USER** through 0x7FFF) can be defined and used by an application to send messages within a private window class. These values cannot be used to define messages that are meaningful throughout an application because some predefined window classes already define values in this range. For example, predefined control classes such as **BUTTON**, **EDIT**, **LISTBOX**, and **COMBOBOX** may use these values. Messages in this range should not be sent to other applications unless the applications have been designed to exchange messages and to attach the same meaning to the message numbers. Message numbers in the third range (0x8000 through 0xBFFF) are available for applications to use as private messages. Messages in this range do not conflict with system messages. Message numbers in the fourth range (0xC000 through 0xFFFF) are defined at run time when an application calls the [**RegisterWindowMessage**](/windows/win32/api/winuser/nf-winuser-registerwindowmessagea) function to retrieve a message number for a string. All applications that register the same string can use the associated message number for exchanging messages. The actual message number, however, is not a constant and cannot be assumed to be the same between different sessions. Message numbers in the fifth range (greater than 0xFFFF) are reserved by the system.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-user#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_CALLBACK_ERROR">
            <summary>The WM\_CAP\_SET\_CALLBACK\_ERROR message sets an error callback function in the client application. AVICap calls this procedure when errors occur. You can send this message explicitly or by using the capSetCallbackOnError macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the error callback function, of type [**capErrorCallback**](/windows/desktop/api/Vfw/nc-vfw-caperrorcallbacka). Specify **NULL** for this parameter to disable a previously installed error callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>Applications can optionally set an error callback function. If set, AVICap calls the error procedure in the following situations: -   The disk is full. -   A capture window cannot be connected with a capture driver. -   A waveform-audio device cannot be opened. -   The number of frames dropped during capture exceeds the specified percentage. -   The frames cannot be captured due to vertical synchronization interrupt problems.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-error#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_CALLBACK_STATUS">
            <summary>The WM\_CAP\_SET\_CALLBACK\_STATUS message sets a status callback function in the application. AVICap calls this procedure whenever the capture window status changes. You can send this message explicitly or by using the capSetCallbackOnStatus macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the status callback function, of type [**capStatusCallback**](/windows/desktop/api/Vfw/nc-vfw-capstatuscallbacka). Specify **NULL** for this parameter to disable a previously installed status callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>Applications can optionally set a status callback function. If set, AVICap calls this procedure in the following situations: -   A capture session is completed. -   A capture driver successfully connected to a capture window. -   An optimal palette is created. -   The number of captured frames is reported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-status#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_CALLBACK_YIELD">
            <summary>The WM\_CAP\_SET\_CALLBACK\_YIELD message sets a callback function in the application. AVICap calls this procedure when the capture window yields during streaming capture. You can send this message explicitly or by using the capSetCallbackOnYield macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the yield callback function, of type [**capYieldCallback**](/windows/desktop/api/Vfw/nc-vfw-capyieldcallback). Specify **NULL** for this parameter to disable a previously installed yield callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>Applications can optionally set a yield callback function. The yield callback function is called at least once for each video frame captured during streaming capture. If a yield callback function is installed, it will be called regardless of the state of the **fYield** member of the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure. If the yield callback function is used, it must be installed before starting the capture session and it must remain enabled for the duration of the session. It can be disabled after streaming capture ends. Applications typically perform some type of message processing in the callback function consisting of a [PeekMessage](/windows/win32/api/winuser/nf-winuser-peekmessagea), [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage), [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) loop, as in the message loop of a [WinMain](/windows/win32/api/winbase/nf-winbase-winmain) function. The yield callback function must also filter and remove messages that can cause reentrancy problems. An application typically returns **TRUE** in the yield procedure to continue streaming capture. If a yield callback function returns **FALSE**, the capture window stops the capture process.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-yield#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_CALLBACK_FRAME">
            <summary>The WM\_CAP\_SET\_CALLBACK\_FRAME message sets a preview callback function in the application. AVICap calls this procedure when the capture window captures preview frames. You can send this message explicitly or by using the capSetCallbackOnFrame macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the preview callback function, of type [**capVideoStreamCallback**](/windows/desktop/api/Vfw/nc-vfw-capvideocallback). Specify **NULL** for this parameter to disable a previously installed callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>The capture window calls the callback function before displaying preview frames. This allows an application to modify the frame if desired. This callback function is not used during streaming video capture.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_CALLBACK_VIDEOSTREAM">
            <summary>The WM\_CAP\_SET\_CALLBACK\_VIDEOSTREAM message sets a callback function in the application.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the video-stream callback function, of type [**capVideoStreamCallback**](/windows/desktop/api/Vfw/nc-vfw-capvideocallback). Specify **NULL** for this parameter to disable a previously installed video-stream callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>The capture window calls the callback function before writing the captured frame to disk. This allows applications to modify the frame if desired. If a video stream callback function is used for streaming capture, the procedure must be installed before starting the capture session and it must remain enabled for the duration of the session. It can be disabled after streaming capture ends.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-videostream#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_CALLBACK_WAVESTREAM">
            <summary>The WM\_CAP\_SET\_CALLBACK\_WAVESTREAM message sets a callback function in the application.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the wave stream callback function, of type [**capWaveStreamCallback**](/windows/desktop/api/Vfw/nc-vfw-capwavecallback). Specify **NULL** for this parameter to disable a previously installed wave stream callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>The capture window calls the procedure before writing the audio buffer to disk. This allows applications to modify the audio buffer if desired. If a wave stream callback function is used, it must be installed before starting the capture session and it must remain enabled for the duration of the session. It can be disabled after streaming capture ends.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-wavestream#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_GET_USER_DATA">
            <summary>The WM\_CAP\_GET\_USER\_DATA message retrieves a LONG\_PTR data value associated with a capture window. You can send this message explicitly or by using the capGetUserData macro.</summary>
            <returns>Returns a value previously saved by using the [**WM\_CAP\_SET\_USER\_DATA**](wm-cap-set-user-data.md) message.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-get-user-data">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_USER_DATA">
            <summary>The WM\_CAP\_SET\_USER\_DATA message associates a LONG\_PTR data value with a capture window. You can send this message explicitly or by using the capSetUserData macro.</summary>
            <returns>
            <para><span id="lUser"></span><span id="luser"></span><span id="LUSER"></span>*lUser* Data value to associate with a capture window.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture is in progress.</para>
            </returns>
            <remarks>Typically this message is used to point to a block of data associated with a capture window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_DRIVER_CONNECT">
            <summary>The WM\_CAP\_DRIVER\_CONNECT message connects a capture window to a capture driver. You can send this message explicitly or by using the capDriverConnect macro.</summary>
            <returns>
            <para><span id="iIndex"></span><span id="iindex"></span><span id="IINDEX"></span>*iIndex* Index of the capture driver. The index can range from 0 through 9.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the specified capture driver cannot be connected to the capture window.</para>
            </returns>
            <remarks>Connecting a capture driver to a capture window automatically disconnects any previously connected capture driver.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_DRIVER_DISCONNECT">
            <summary>The WM\_CAP\_DRIVER\_DISCONNECT message disconnects a capture driver from a capture window. You can send this message explicitly or by using the capDriverDisconnect macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-driver-disconnect">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_DRIVER_GET_NAME">
            <summary>The WM\_CAP\_DRIVER\_GET\_NAME message returns the name of the capture driver connected to the capture window. You can send this message explicitly or by using the capDriverGetName macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the buffer referenced by**szName**.</para>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to an application-defined buffer used to return the device name as a null-terminated string.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The name is a text string retrieved from the driver's resource area. Applications should allocate approximately 80 bytes for this string. If the driver does not contain a name resource, the full path name of the driver listed in the registry or in the SYSTEM.INI file is returned.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_DRIVER_GET_VERSION">
            <summary>The WM\_CAP\_DRIVER\_GET\_VERSION message returns the version information of the capture driver connected to a capture window. You can send this message explicitly or by using the capDriverGetVersion macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the application-defined buffer referenced by**szVer**.</para>
            <para><span id="szVer"></span><span id="szver"></span><span id="SZVER"></span>*szVer* Pointer to an application-defined buffer used to return the version information as a null-terminated string.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The version information is a text string retrieved from the driver's resource area. Applications should allocate approximately 40 bytes for this string. If version information is not available, a **NULL** string is returned.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_DRIVER_GET_CAPS">
            <summary>The WM\_CAP\_DRIVER\_GET\_CAPS message returns the hardware capabilities of the capture driver currently connected to a capture window. You can send this message explicitly or by using the capDriverGetCaps macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psCaps"></span><span id="pscaps"></span><span id="PSCAPS"></span>*psCaps* Pointer to the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure to contain the hardware capabilities.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The capabilities returned in [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) are constant for a given capture driver. Applications need to retrieve this information once when the capture driver is first connected to a capture window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_FILE_SET_CAPTURE_FILE">
            <summary>The WM\_CAP\_FILE\_SET\_CAPTURE\_FILE message names the file used for video capture. You can send this message explicitly or by using the capFileSetCaptureFile macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to the null-terminated string that contains the name of the capture file to use.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the filename is invalid, or if streaming or single-frame capture is in progress.</para>
            </returns>
            <remarks>This message stores the filename in an internal structure. It does not create, allocate, or open the specified file. The default capture filename is C:\\CAPTURE.AVI.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_FILE_GET_CAPTURE_FILE">
            <summary>The WM\_CAP\_FILE\_GET\_CAPTURE\_FILE message returns the name of the current capture file. You can send this message explicitly or by using the capFileGetCaptureFile macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the application-defined buffer referenced by**szName**.</para>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to an application-defined buffer used to return the name of the capture file as a null-terminated string.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>The default capture filename is C:\\CAPTURE.AVI.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_FILE_SAVEAS">
            <summary>The WM\_CAP\_FILE\_SAVEAS message copies the contents of the capture file to another file. You can send this message explicitly or by using the capFileSaveAs macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to the null-terminated string that contains the name of the destination file used to copy the file.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para>This message does not change the name or contents of the current capture file. If the copy operation is unsuccessful due to a disk full error, the destination file is automatically deleted. Typically, a capture file is preallocated for the largest capture segment anticipated and only a portion of it might be used to capture data. This message copies only the portion of the file containing the capture data.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-file-saveas#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_FILE_SAVEDIB">
            <summary>The WM\_CAP\_FILE\_SAVEDIB message copies the current frame to a DIB file. You can send this message explicitly or by using the capFileSaveDIB macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to the null-terminated string that contains the name of the destination DIB file.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>If the capture driver supplies frames in a compressed format, this call attempts to decompress the frame before writing the file.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_FILE_ALLOCATE">
            <summary>The WM\_CAP\_FILE\_ALLOCATE message creates (preallocates) a capture file of a specified size. You can send this message explicitly or by using the capFileAlloc macro.</summary>
            <returns>
            <para><span id="dwSize"></span><span id="dwsize"></span><span id="DWSIZE"></span>*dwSize* Size, in bytes, to create the capture file.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>You can improve streaming capture performance significantly by preallocating a capture file large enough to store an entire video clip and by defragmenting the capture file before capturing the clip.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_FILE_SET_INFOCHUNK">
            <summary>The WM\_CAP\_FILE\_SET\_INFOCHUNK message sets and clears information chunks.</summary>
            <returns>
            <para><span id="lpInfoChunk"></span><span id="lpinfochunk"></span><span id="LPINFOCHUNK"></span>*lpInfoChunk* Pointer to a [**CAPINFOCHUNK**](/windows/win32/api/vfw/ns-vfw-capinfochunk) structure defining the information chunk to be created or deleted.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>Multiple registered information chunks can be added to an AVI file. After an information chunk is set, it continues to be added to subsequent capture files until either the entry is cleared or all information chunk entries are cleared. To clear a single entry, specify the information chunk in the **fccInfoID** member and **NULL** in the **lpData** member of the [**CAPINFOCHUNK**](/windows/win32/api/vfw/ns-vfw-capinfochunk) structure. To clear all entries, specify **NULL** in **fccInfoID**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_EDIT_COPY">
            <summary>The WM\_CAP\_EDIT\_COPY message copies the contents of the video frame buffer and associated palette to the clipboard. You can send this message explicitly or by using the capEditCopy macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-edit-copy">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_AUDIOFORMAT">
            <summary>The WM\_CAP\_SET\_AUDIOFORMAT message sets the audio format to use when performing streaming or step capture. You can send this message explicitly or by using the capSetAudioFormat macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by **s**.</para>
            <para><span id="psAudioFormat"></span><span id="psaudioformat"></span><span id="PSAUDIOFORMAT"></span>*psAudioFormat* Pointer to a [**WAVEFORMATEX**](/windows/win32/api/mmeapi/ns-mmeapi-waveformatex) or [**PCMWAVEFORMAT**](/windows/win32/api/mmreg/ns-mmreg-pcmwaveformat) structure that defines the audio format.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-audioformat">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_GET_AUDIOFORMAT">
            <summary>The WM\_CAP\_GET\_AUDIOFORMAT message obtains the audio format or the size of the audio format. You can send this message explicitly or by using the capGetAudioFormat and capGetAudioFormatSize macros.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psAudioFormat"></span><span id="psaudioformat"></span><span id="PSAUDIOFORMAT"></span>*psAudioFormat* Pointer to a [**WAVEFORMATEX**](/windows/win32/api/mmeapi/ns-mmeapi-waveformatex) structure, or **NULL**. If the value is **NULL**, the size, in bytes, required to hold the structure is returned.</para>
            <para>Returns the size, in bytes, of the audio format.</para>
            </returns>
            <remarks>Because compressed audio formats vary in size requirements applications must first retrieve the size, then allocate memory, and finally request the audio format data.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_DLG_VIDEOFORMAT">
            <summary>The WM\_CAP\_DLG\_VIDEOFORMAT message displays a dialog box in which the user can select the video format.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>After this message returns, applications might need to update the [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure because the user might have changed the image dimensions. The Video Format dialog box is unique for each capture driver. Some capture drivers might not support a Video Format dialog box. Applications can determine if the capture driver supports this message by checking the **fHasDlgVideoFormat** member of [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-dlg-videoformat#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_DLG_VIDEOSOURCE">
            <summary>The WM\_CAP\_DLG\_VIDEOSOURCE message displays a dialog box in which the user can control the video source.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>The Video Source dialog box is unique for each capture driver. Some capture drivers might not support a Video Source dialog box. Applications can determine if the capture driver supports this message by checking the **fHasDlgVideoSource** member of the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_DLG_VIDEODISPLAY">
            <summary>The WM\_CAP\_DLG\_VIDEODISPLAY message displays a dialog box in which the user can set or adjust the video output.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>The controls in this dialog box do not affect digitized video data; they affect only the output or redisplay of the video signal. The Video Display dialog box is unique for each capture driver. Some capture drivers might not support a Video Display dialog box. Applications can determine if the capture driver supports this message by checking the **fHasDlgVideoDisplay** member of the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-dlg-videodisplay#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_GET_VIDEOFORMAT">
            <summary>The WM\_CAP\_GET\_VIDEOFORMAT message retrieves a copy of the video format in use or the size required for the video format. You can send this message explicitly or by using the capGetVideoFormat and capGetVideoFormatSize macros.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psVideoFormat"></span><span id="psvideoformat"></span><span id="PSVIDEOFORMAT"></span>*psVideoFormat* Pointer to a [**BITMAPINFO**](/windows/win32/api/wingdi/ns-wingdi-bitmapinfo) structure. You can also specify **NULL** to retrieve the number of bytes needed.</para>
            <para>Returns the size, in bytes, of the video format or zero if the capture window is not connected to a capture driver. For video formats that require a palette, the current palette is also returned.</para>
            </returns>
            <remarks>Because compressed video formats vary in size requirements applications must first retrieve the size, then allocate memory, and finally request the video format data.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_VIDEOFORMAT">
            <summary>The WM\_CAP\_SET\_VIDEOFORMAT message sets the format of captured video data. You can send this message explicitly or by using the capSetVideoFormat macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by **s**.</para>
            <para><span id="psVideoFormat"></span><span id="psvideoformat"></span><span id="PSVIDEOFORMAT"></span>*psVideoFormat* Pointer to a [**BITMAPINFO**](/windows/win32/api/wingdi/ns-wingdi-bitmapinfo) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>Because video formats are device-specific, applications should check the return value from this function to determine if the format is accepted by the driver.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_DLG_VIDEOCOMPRESSION">
            <summary>The WM\_CAP\_DLG\_VIDEOCOMPRESSION message displays a dialog box in which the user can select a compressor to use during the capture process.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>Use this message with capture drivers that provide frames only in the BI\_RGB format. This message is most useful in the step capture operation to combine capture and compression in a single operation. Compressing frames with a software compressor as part of a real-time capture operation is most likely too time-consuming to perform. Compression does not affect the frames copied to the clipboard.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-dlg-videocompression#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_PREVIEW">
            <summary>The WM\_CAP\_SET\_PREVIEW message enables or disables preview mode.</summary>
            <returns>
            <para><span id="f"></span><span id="F"></span>*f* Preview flag. Specify **TRUE** for this parameter to enable preview mode or **FALSE** to disable it.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para>The preview mode uses substantial CPU resources. Applications can disable preview or lower the preview rate when another application has the focus. The **fLiveWindow** member of the [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure indicates if preview mode is currently enabled. Enabling preview mode automatically disables overlay mode.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-preview#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_OVERLAY">
            <summary>The WM\_CAP\_SET\_OVERLAY message enables or disables overlay mode. In overlay mode, video is displayed using hardware overlay. You can send this message explicitly or by using the capOverlay macro.</summary>
            <returns>
            <para><span id="f"></span><span id="F"></span>*f* Overlay flag. Specify **TRUE** for this parameter to enable overlay mode or **FALSE** to disable it.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para>Using an overlay does not require CPU resources. The **fHasOverlay** member of the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure indicates whether the device is capable of overlay. The **fOverlayWindow** member of the [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure indicates whether overlay mode is currently enabled. Enabling overlay mode automatically disables preview mode.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-overlay#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_PREVIEWRATE">
            <summary>The WM\_CAP\_SET\_PREVIEWRATE message sets the frame display rate in preview mode. You can send this message explicitly or by using the capPreviewRate macro.</summary>
            <returns>
            <para><span id="wMS"></span><span id="wms"></span><span id="WMS"></span>*wMS* Rate, in milliseconds, at which new frames are captured and displayed.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The preview mode uses substantial CPU resources. Applications can disable preview or lower the preview rate when another application has the focus. During streaming video capture, the previewing task is lower priority than writing frames to disk, and preview frames are displayed only if no other buffers are available for writing.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_SCALE">
            <summary>The WM\_CAP\_SET\_SCALE message enables or disables scaling of the preview video images.</summary>
            <returns>
            <para><span id="f"></span><span id="F"></span>*f* Preview scaling flag. Specify **TRUE** for this parameter to stretch preview frames to the size of the capture window or **FALSE** to display them at their natural size.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para>Scaling preview images controls the immediate presentation of captured frames within the capture window. It has no effect on the size of the frames saved to file. Scaling has no effect when using overlay to display video in the frame buffer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-scale#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_GET_STATUS">
            <summary>The WM\_CAP\_GET\_STATUS message retrieves the status of the capture window. You can send this message explicitly or by using the capGetStatus macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="s"></span><span id="S"></span>*s* Pointer to a [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure contains the current state of the capture window. Since this state is dynamic and changes in response to various messages, the application should initialize this structure after sending the [**WM\_CAP\_DLG\_VIDEOFORMAT**](wm-cap-dlg-videoformat.md) message (or using the [**capDlgVideoFormat**](/windows/desktop/api/Vfw/nf-vfw-capdlgvideoformat) macro) and whenever it needs to enable menu items or determine the actual state of the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_SCROLL">
            <summary>The WM\_CAP\_SET\_SCROLL message defines the portion of the video frame to display in the capture window.</summary>
            <returns>
            <para><span id="lpP"></span><span id="lpp"></span><span id="LPP"></span>*lpP* Address to contain the desired scroll position.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>The scroll position affects the image in both preview and overlay modes.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_GRAB_FRAME">
            <summary>The WM\_CAP\_GRAB\_FRAME message retrieves and displays a single frame from the capture driver. After capture, overlay and preview are disabled. You can send this message explicitly or by using the capGrabFrame macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_GRAB_FRAME_NOSTOP">
            <summary>The WM\_CAP\_GRAB\_FRAME\_NOSTOP message fills the frame buffer with a single uncompressed frame from the capture device and displays it.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SEQUENCE">
            <summary>The WM\_CAP\_SEQUENCE message initiates streaming video and audio capture to a file. You can send this message explicitly or by using the capCaptureSequence macro.</summary>
            <returns>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para>If you want to alter the parameters controlling streaming capture, use the [**WM\_CAP\_SET\_SEQUENCE\_SETUP**](wm-cap-set-sequence-setup.md) message prior to starting the capture. By default, the capture window does not allow other applications to continue running during capture. To override this, either set the **fYield** member of the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure to **TRUE**, or install a yield callback function. During streaming capture, the capture window can optionally issue notifications to your application of specific types of conditions. To install callback procedures for these notifications, use the following messages: -   [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) -   [**WM\_CAP\_SET\_CALLBACK\_STATUS**](wm-cap-set-callback-status.md) -   [**WM\_CAP\_SET\_CALLBACK\_YIELD**](wm-cap-set-callback-yield.md) -   [**WM\_CAP\_SET\_CALLBACK\_VIDEOSTREAM**](wm-cap-set-callback-videostream.md) -   [**WM\_CAP\_SET\_CALLBACK\_WAVESTREAM**](wm-cap-set-callback-wavestream.md)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-sequence#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SEQUENCE_NOFILE">
            <summary>The WM\_CAP\_SEQUENCE\_NOFILE message initiates streaming video capture without writing data to a file. You can send this message explicitly or by using the capCaptureSequenceNoFile macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>This message is useful in conjunction with video stream or waveform-audio stream callback functions that let your application use the video and audio data directly. If you want to alter the parameters controlling streaming capture, use the [**WM\_CAP\_SET\_SEQUENCE\_SETUP**](wm-cap-set-sequence-setup.md) message prior to starting the capture. By default, the capture window does not allow other applications to continue running during capture. To override this, either set the **fYield** member of the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure to **TRUE**, or install a yield callback function. During streaming capture, the capture window can optionally issue notifications to your application of specific types of conditions. To install callback procedures for these notifications, use the following messages: -   [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) -   [**WM\_CAP\_SET\_CALLBACK\_STATUS**](wm-cap-set-callback-status.md) -   [**WM\_CAP\_SET\_CALLBACK\_YIELD**](wm-cap-set-callback-yield.md) -   [**WM\_CAP\_SET\_CALLBACK\_VIDEOSTREAM**](wm-cap-set-callback-videostream.md) -   [**WM\_CAP\_SET\_CALLBACK\_WAVESTREAM**](wm-cap-set-callback-wavestream.md)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-sequence-nofile#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_SEQUENCE_SETUP">
            <summary>The WM\_CAP\_SET\_SEQUENCE\_SETUP message sets the configuration parameters used with streaming capture. You can send this message explicitly or by using the capCaptureSetSetup macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psCapParms"></span><span id="pscapparms"></span><span id="PSCAPPARMS"></span>*psCapParms* Pointer to a [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>For information about the parameters used to control streaming capture, see the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_GET_SEQUENCE_SETUP">
            <summary>The WM\_CAP\_GET\_SEQUENCE\_SETUP message retrieves the current settings of the streaming capture parameters. You can send this message explicitly or by using the capCaptureGetSetup macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="s"></span><span id="S"></span>*s* Pointer to a [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>For information about the parameters used to control streaming capture, see the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_MCI_DEVICE">
            <summary>The WM\_CAP\_SET\_MCI\_DEVICE message specifies the name of the MCI video device to be used to capture data. You can send this message explicitly or by using the capSetMCIDeviceName macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string containing the name of the device.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>This message stores the MCI device name in an internal structure. It does not open or access the device. The default device name is **NULL**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_GET_MCI_DEVICE">
            <summary>The WM\_CAP\_GET\_MCI\_DEVICE message retrieves the name of an MCI device previously set with the WM\_CAP\_SET\_MCI\_DEVICE message. You can send this message explicitly or by using the capGetMCIDeviceName macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Length, in bytes, of the buffer referenced by**szName**.</para>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string that contains the MCI device name.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-get-mci-device">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_STOP">
            <summary>The WM\_CAP\_STOP message stops the capture operation. You can send this message explicitly or by using the capCaptureStop macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>The capture operation must yield to use this message. Use the [**WM\_CAP\_ABORT**](wm-cap-abort.md) message to abandon the current capture operation.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_ABORT">
            <summary>The WM\_CAP\_ABORT message stops the capture operation.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>The capture operation must yield to use this message. Use the [**WM\_CAP\_STOP**](wm-cap-stop.md) message to halt step capture at the current position, and then capture audio.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-abort#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SINGLE_FRAME_OPEN">
            <summary>The WM\_CAP\_SINGLE\_FRAME\_OPEN message opens the capture file for single-frame capturing. Any previous information in the capture file is overwritten. You can send this message explicitly or by using the capCaptureSingleFrameOpen macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SINGLE_FRAME_CLOSE">
            <summary>The WM\_CAP\_SINGLE\_FRAME\_CLOSE message closes the capture file opened by the WM\_CAP\_SINGLE\_FRAME\_OPEN message. You can send this message explicitly or by using the capCaptureSingleFrameClose macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SINGLE_FRAME">
            <summary>The WM\_CAP\_SINGLE\_FRAME message appends a single frame to a capture file that was opened using the WM\_CAP\_SINGLE\_FRAME\_OPEN message. You can send this message explicitly or by using the capCaptureSingleFrame macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-single-frame">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_PAL_OPEN">
            <summary>The WM\_CAP\_PAL\_OPEN message loads a new palette from a palette file and passes it to a capture driver.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string containing the palette filename.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-pal-open">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_PAL_SAVE">
            <summary>The WM\_CAP\_PAL\_SAVE message saves the current palette to a palette file. Palette files typically use the filename extension .PAL. You can send this message explicitly or by using the capPaletteSave macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string containing the palette filename.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-pal-save">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_PAL_PASTE">
            <summary>The WM\_CAP\_PAL\_PASTE message copies the palette from the clipboard and passes it to a capture driver. You can send this message explicitly or by using the capPalettePaste macro.</summary>
            <returns>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>A capture driver uses a palette when required by the specified digitized video format.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_PAL_AUTOCREATE">
            <summary>The WM\_CAP\_PAL\_AUTOCREATE message requests that the capture driver sample video frames and automatically create a new palette. You can send this message explicitly or by using the capPaletteAuto macro.</summary>
            <returns>
            <para><span id="iFrames"></span><span id="iframes"></span><span id="IFRAMES"></span>*iFrames* Number of frames to sample.</para>
            <para><span id="iColors"></span><span id="icolors"></span><span id="ICOLORS"></span>*iColors* Number of colors in the palette. The maximum value for this parameter is 256.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>The sampled video sequence should include all the colors you want in the palette. To obtain the best palette, you might have to sample the whole sequence rather than a portion of it.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_PAL_MANUALCREATE">
            <summary>The WM\_CAP\_PAL\_MANUALCREATE message requests that the capture driver manually sample video frames and create a new palette. You can send this message explicitly or by using the capPaletteManual macro.</summary>
            <returns>
            <para><span id="fGrab"></span><span id="fgrab"></span><span id="FGRAB"></span>*fGrab* Palette histogram flag. Set this parameter to **TRUE** for each frame included in creating the optimal palette. After the last frame has been collected, set this parameter to **FALSE** to calculate the optimal palette and send it to the capture driver.</para>
            <para><span id="iColors"></span><span id="icolors"></span><span id="ICOLORS"></span>*iColors* Number of colors in the palette. The maximum value for this parameter is 256. This value is used only during collection of the first frame in a sequence.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-pal-manualcreate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_CAP_SET_CALLBACK_CAPCONTROL">
            <summary>The WM\_CAP\_SET\_CALLBACK\_CAPCONTROL message sets a callback function in the application giving it precise recording control. You can send this message explicitly or by using the capSetCallbackOnCapControl macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the callback function, of type [**capControlCallback**](/windows/desktop/api/Vfw/nc-vfw-capcontrolcallback). Specify **NULL** for this parameter to disable a previously installed callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if a streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>A single callback function is used to give the application precise control over the moments that streaming capture begins and completes. The capture window first calls the procedure with *nState* set to CONTROLCALLBACK\_PREROLL after all buffers have been allocated and all other capture preparations have finished. This gives the application the ability to preroll video sources, returning from the callback function at the exact moment recording is to begin. A return value of **TRUE** from the callback function continues capture, and a return value of **FALSE** aborts capture. After capture begins, this callback function will be called frequently with *nState* set to CONTROLCALLBACK\_CAPTURING to allow the application to end capture by returning **FALSE**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ADSPROP_NOTIFY_PAGEINIT">
            <summary>An Active Directory property sheet extension calls the ADsPropGetInitInfo to obtain data about regarding the directory object that the property sheet extension applies to.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-pageinit">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ADSPROP_NOTIFY_PAGEHWND">
            <summary>An Active Directory directory service property sheet extension calls the ADsPropSetHwnd to inform the notification object of the property page window handle.</summary>
            <returns>This message has no return value.</returns>
            <remarks>An Active Directory property sheet extension normally calls the [**ADsPropSetHwnd**](/windows/desktop/api/Adsprop/nf-adsprop-adspropsethwnd) function while processing the [**WM\_INITDIALOG**](../dlgbox/wm-initdialog.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ADSPROP_NOTIFY_CHANGE">
            <summary>The WM\_ADSPROP\_NOTIFY\_CHANGE message is used internally by the notification object.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-change">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ADSPROP_NOTIFY_APPLY">
            <summary>An Active Directory directory service property sheet extension sends the WM\_ADSPROP\_NOTIFY\_APPLY message to the notification object if the property page PSN\_APPLY handler succeeds.</summary>
            <returns>This message has no return value.</returns>
            <remarks>When adding pages to the Active Directory Manager MMC snap-in, Active Directory MMC property sheets create the notification objects by a call to the [**ADsPropCreateNotifyObj**](/windows/desktop/api/Adsprop/nf-adsprop-adspropcreatenotifyobj) function, and then passes the notification object handle to each property page.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ADSPROP_NOTIFY_SETFOCUS">
            <summary>The WM\_ADSPROP\_NOTIFY\_SETFOCUS message is used internally by the notification object.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-setfocus">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ADSPROP_NOTIFY_FOREGROUND">
            <summary>The WM\_ADSPROP\_NOTIFY\_FOREGROUND message is used internally by the notification object.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-foreground">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ADSPROP_NOTIFY_EXIT">
            <summary>An Active Directory property sheet extension sends the WM\_ADSPROP\_NOTIFY\_EXIT message to the notification object when the notification object is no longer required.</summary>
            <returns>This message has no return value.</returns>
            <remarks>The notification object will delete itself in response to this message. When this message has been sent, the notification object handle should be considered invalid.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_ADSPROP_NOTIFY_ERROR">
            <summary>The WM\_ADSPROP\_NOTIFY\_ERROR message adds an error message to a list of error messages that are displayed by calling the ADsPropShowErrorDialog function.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>The [**ADsPropSendErrorMessage**](/windows/desktop/api/Adsprop/nf-adsprop-adspropsenderrormessage) function is the preferred method of sending this message. The error messages added by the **WM\_ADSPROP\_NOTIFY\_ERROR** message are accumulated until [**ADsPropShowErrorDialog**](/windows/desktop/api/Adsprop/nf-adsprop-adspropshowerrordialog) is called. **ADsPropShowErrorDialog** combines and displays the accumulated error messages. When the error dialog is dismissed, the accumulated error messages are deleted.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-error#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvokeCore.WM_RASDIALEVENT">
            <summary>The operating system sends a WM\_RASDIALEVENT message to a window procedure when a change of state event occurs during a RAS connection process.</summary>
            <returns>If an application processes this message, it should return **TRUE**.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/RRAS/wm-rasdialevent">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.BitBlt(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,Windows.Win32.Graphics.Gdi.ROP_CODE)">
            <summary>The BitBlt function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.</summary>
            <param name="hdc">A handle to the destination device context.</param>
            <param name="x">The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.</param>
            <param name="y">The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.</param>
            <param name="cx">The width, in logical units, of the source and destination rectangles.</param>
            <param name="cy">The height, in logical units, of the source and the destination rectangles.</param>
            <param name="hdcSrc">A handle to the source device context.</param>
            <param name="x1">The x-coordinate, in logical units, of the upper-left corner of the source rectangle.</param>
            <param name="y1">The y-coordinate, in logical units, of the upper-left corner of the source rectangle.</param>
            <param name="rop">
            <para>A raster-operation code. These codes define how the color data for the source rectangle is to be combined with the color data for the destination rectangle to achieve the final color. The following list shows some common raster operation codes. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-bitblt#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><b>BitBlt</b> only does clipping on the destination DC. If a rotation or shear transformation is in effect in the source device context, <b>BitBlt</b> returns an error. If other transformations exist in the source device context (and a matching transformation is not in effect in the destination device context), the rectangle in the destination device context is stretched, compressed, or rotated, as necessary. If the color formats of the source and destination device contexts do not match, the <b>BitBlt</b> function converts the source color format to match the destination format. When an enhanced metafile is being recorded, an error occurs if the source device context identifies an enhanced-metafile device context. Not all devices support the <b>BitBlt</b> function. For more information, see the RC_BITBLT raster capability entry in the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps">GetDeviceCaps</a> function as well as the following functions: <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-maskblt">MaskBlt</a>, <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-plgblt">PlgBlt</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-stretchblt">StretchBlt</a>. <b>BitBlt</b> returns an error if the source and destination device contexts represent different devices. To transfer data between DCs for different devices, convert the memory bitmap to a DIB by calling <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdibits">GetDIBits</a>. To display the DIB to the second device, call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setdibits">SetDIBits</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-stretchdibits">StretchDIBits</a>. <b>ICM:</b> No color management is performed when blits occur.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-bitblt#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DeleteEnhMetaFile(Windows.Win32.Graphics.Gdi.HENHMETAFILE)">
            <summary>The DeleteEnhMetaFile function deletes an enhanced-format metafile or an enhanced-format metafile handle.</summary>
            <param name="hmf">A handle to an enhanced metafile.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>If the <i>hemf</i> parameter identifies an enhanced metafile stored in memory, the <b>DeleteEnhMetaFile</b> function deletes the metafile. If <i>hemf</i> identifies a metafile stored on a disk, the function deletes the metafile handle but does not destroy the actual metafile. An application can retrieve the file by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getenhmetafilea">GetEnhMetaFile</a> function.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CloseEnhMetaFile(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The CloseEnhMetaFile function closes an enhanced-metafile device context and returns a handle that identifies an enhanced-format metafile.</summary>
            <param name="hdc">Handle to an enhanced-metafile device context.</param>
            <returns>
            <para>If the function succeeds, the return value is a handle to an enhanced metafile. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>An application can use the enhanced-metafile handle returned by the <b>CloseEnhMetaFile</b> function to perform the following tasks: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-closeenhmetafile#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DeleteObject(Windows.Win32.Graphics.Gdi.HGDIOBJ)">
            <summary>The DeleteObject function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid.</summary>
            <param name="ho">A handle to a logical pen, brush, font, bitmap, region, or palette.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the specified handle is not valid or is currently selected into a DC, the return value is zero.</para>
            </returns>
            <remarks>
            <para>Do not delete a drawing object (pen or brush) while it is still selected into a DC. When a pattern brush is deleted, the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-deleteobject#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CombineRgn(Windows.Win32.Graphics.Gdi.HRGN,Windows.Win32.Graphics.Gdi.HRGN,Windows.Win32.Graphics.Gdi.HRGN,Windows.Win32.Graphics.Gdi.RGN_COMBINE_MODE)">
            <summary>The CombineRgn function combines two regions and stores the result in a third region. The two regions are combined according to the specified mode.</summary>
            <param name="hrgnDst">A handle to a new region with dimensions defined by combining two other regions. (This region must exist before <b>CombineRgn</b> is called.)</param>
            <param name="hrgnSrc1">A handle to the first of two regions to be combined.</param>
            <param name="hrgnSrc2">A handle to the second of two regions to be combined.</param>
            <param name="iMode"></param>
            <returns>
            <para>The return value specifies the type of the resulting region. It can be one of the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>The three regions need not be distinct. For example, the <i>hrgnSrc1</i> parameter can equal the <i>hrgnDest</i> parameter.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateBitmap(System.Int32,System.Int32,System.UInt32,System.UInt32,System.Void*)">
            <summary>The CreateBitmap function creates a bitmap with the specified width, height, and color format (color planes and bits-per-pixel).</summary>
            <param name="nWidth">The bitmap width, in pixels.</param>
            <param name="nHeight">The bitmap height, in pixels.</param>
            <param name="nPlanes">The number of color planes used by the device.</param>
            <param name="nBitCount">The number of bits required to identify the color of a single pixel.</param>
            <param name="lpBits">
            <para>A pointer to an array of color data used to set the colors in a rectangle of pixels. Each scan line in the rectangle must be word aligned (scan lines that are not word aligned must be padded with zeros). The buffer size expected, *cj*, can be calculated using the formula: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createbitmap#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to a bitmap. If the function fails, the return value is <b>NULL</b>. This function can return the following value. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The <b>CreateBitmap</b> function creates a device-dependent bitmap. After a bitmap is created, it can be selected into a device context by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-selectobject">SelectObject</a> function. However, the bitmap can only be selected into a device context if the bitmap and the DC have the same format. The <b>CreateBitmap</b> function can be used to create color bitmaps. However, for performance reasons applications should use <b>CreateBitmap</b> to create monochrome bitmaps and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createcompatiblebitmap">CreateCompatibleBitmap</a> to create color bitmaps. Whenever a color bitmap returned from <b>CreateBitmap</b> is selected into a device context, the system checks that the bitmap matches the format of the device context it is being selected into. Because <b>CreateCompatibleBitmap</b> takes a device context, it returns a bitmap that has the same format as the specified device context. Thus, subsequent calls to <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-selectobject">SelectObject</a> are faster with a color bitmap from <b>CreateCompatibleBitmap</b> than with a color bitmap returned from <b>CreateBitmap</b>. If the bitmap is monochrome, zeros represent the foreground color and ones represent the background color for the destination device context. If an application sets the <i>nWidth</i> or <i>nHeight</i> parameters to zero, <b>CreateBitmap</b> returns the handle to a 1-by-1 pixel, monochrome bitmap. When you no longer need the bitmap, call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a> function to delete it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createbitmap#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateCompatibleBitmap(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32)">
            <summary>The CreateCompatibleBitmap function creates a bitmap compatible with the device that is associated with the specified device context.</summary>
            <param name="hdc">A handle to a device context.</param>
            <param name="cx">The bitmap width, in pixels.</param>
            <param name="cy">The bitmap height, in pixels.</param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the compatible bitmap (DDB). If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>The color format of the bitmap created by the <b>CreateCompatibleBitmap</b> function matches the color format of the device identified by the <i>hdc</i> parameter. This bitmap can be selected into any memory device context that is compatible with the original device. Because memory device contexts allow both color and monochrome bitmaps, the format of the bitmap returned by the <b>CreateCompatibleBitmap</b> function differs when the specified device context is a memory device context. However, a compatible bitmap that was created for a nonmemory device context always possesses the same color format and uses the same color palette as the specified device context. Note: When a memory device context is created, it initially has a 1-by-1 monochrome bitmap selected into it. If this memory device context is used in <b>CreateCompatibleBitmap</b>, the bitmap that is created is a <i>monochrome</i> bitmap. To create a color bitmap, use the <b>HDC</b> that was used to create the memory device context, as shown in the following code:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createcompatiblebitmap#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateCompatibleDC(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The CreateCompatibleDC function creates a memory device context (DC) compatible with the specified device.</summary>
            <param name="hdc">A handle to an existing DC. If this handle is <b>NULL</b>, the function creates a memory DC compatible with the application's current screen.</param>
            <returns>
            <para>If the function succeeds, the return value is the handle to a memory DC. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>A memory DC exists only in memory. When the memory DC is created, its display surface is exactly one monochrome pixel wide and one monochrome pixel high. Before an application can use a memory DC for drawing operations, it must select a bitmap of the correct width and height into the DC. To select a bitmap into a DC, use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createcompatiblebitmap">CreateCompatibleBitmap</a> function, specifying the height, width, and color organization required. When a memory DC is created, all attributes are set to normal default values. The memory DC can be used as a normal DC. You can set the attributes; obtain the current settings of its attributes; and select pens, brushes, and regions. The <b>CreateCompatibleDC</b> function can only be used with devices that support raster operations. An application can determine whether a device supports these operations by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps">GetDeviceCaps</a> function. When you no longer need the memory DC, call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deletedc">DeleteDC</a> function. We recommend that you call <b>DeleteDC</b> to delete the DC.  However, you can also call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a> with the HDC to delete the DC. If <i>hdc</i> is <b>NULL</b>, the thread that calls <b>CreateCompatibleDC</b> owns the HDC that is created. When this thread is destroyed, the HDC is no longer valid. Thus, if you create the HDC and pass it to another thread, then exit the first thread, the second thread will not be able to use the HDC. <b>ICM:</b> If the DC that is passed to this function is enabled for Image Color Management (ICM), the DC created by the function is ICM-enabled. The source and destination color spaces are specified in the DC.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createcompatibledc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateDCW(System.String,System.String,System.String,System.Nullable{Windows.Win32.Graphics.Gdi.DEVMODEW})">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.CreateDCW(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Graphics.Gdi.DEVMODEW*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateDCW(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Graphics.Gdi.DEVMODEW*)">
            <summary>The CreateDC function creates a device context (DC) for a device using the specified name. (Unicode)</summary>
            <param name="pwszDriver">A pointer to a null-terminated character string that specifies either DISPLAY or the name of a specific display device. For printing, we recommend that you pass <b>NULL</b> to <i>lpszDriver</i> because GDI ignores <i>lpszDriver</i> for printer devices.</param>
            <param name="pwszDevice">
            <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used. To obtain valid names for displays, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumdisplaydevicesw">EnumDisplayDevices</a>. If <i>lpszDriver</i> is DISPLAY or the device name of a specific display device, then <i>lpszDevice</i> must be <b>NULL</b> or that same device name. If <i>lpszDevice</i> is <b>NULL</b>, then a DC is created for the primary display device. If there are multiple monitors on the system, calling <c>CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL)</c> will create a DC covering all the monitors.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createdcw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pszPort">This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</param>
            <param name="pdm">
            <para>A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew">DEVMODE</a> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com/windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>pdm</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user. If <i>lpszDriver</i> is DISPLAY, <i>pdm</i> must be <b>NULL</b>; GDI then uses the display device's current <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createdcw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is the handle to a DC for the specified device. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>Note that the handle to the DC can only be used by a single thread at any one time. For parameters <i>lpszDriver</i> and <i>lpszDevice</i>, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumdisplaydevicesw">EnumDisplayDevices</a> to obtain valid names for displays. When you no longer need the DC, call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deletedc">DeleteDC</a> function. If <i>lpszDriver</i> or <i>lpszDevice</i> is DISPLAY, the thread that calls <b>CreateDC</b> owns the <b>HDC</b> that is created. When this thread is destroyed, the <b>HDC</b> is no longer valid. Thus, if you create the <b>HDC</b> and pass it to another thread, then exit the first thread, the second thread will not be able to use the <b>HDC</b>. When you call <b>CreateDC</b> to create the <b>HDC</b> for a display device, you must pass to <i>pdm</i> either <b>NULL</b> or a pointer to <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew">DEVMODE</a> that matches the current <b>DEVMODE</b> of the display device that <i>lpszDevice</i> specifies. We recommend to pass <b>NULL</b> and not to try to exactly match the <b>DEVMODE</b> for the current display device. When you call <b>CreateDC</b> to create the <b>HDC</b> for a printer device, the printer driver validates the <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew">DEVMODE</a>. If the printer driver determines that the <b>DEVMODE</b> is invalid (that is, printer driver can’t convert or consume the DEVMODE), the printer driver provides a default <b>DEVMODE</b> to create the HDC for the printer device. <b>ICM:</b> To enable ICM, set the <b>dmICMMethod</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew">DEVMODE</a> structure (pointed to by the <i>pInitData</i> parameter) to the appropriate value.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createdcw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateDIBSection(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.BITMAPINFO*,Windows.Win32.Graphics.Gdi.DIB_USAGE,System.Void*@,Windows.Win32.Foundation.HANDLE,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.CreateDIBSection(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.BITMAPINFO*,Windows.Win32.Graphics.Gdi.DIB_USAGE,System.Void**,Windows.Win32.Foundation.HANDLE,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateDIBSection(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.BITMAPINFO*,Windows.Win32.Graphics.Gdi.DIB_USAGE,System.Void**,Windows.Win32.Foundation.HANDLE,System.UInt32)">
            <summary>The CreateDIBSection function creates a DIB that applications can write to directly.</summary>
            <param name="hdc">A handle to a device context. If the value of <i>iUsage</i> is DIB_PAL_COLORS, the function uses this device context's logical palette to initialize the DIB colors.</param>
            <param name="pbmi">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-bitmapinfo">BITMAPINFO</a> structure that specifies various attributes of the DIB, including the bitmap dimensions and colors.</param>
            <param name="usage">
            <para>The type of data contained in the <b>bmiColors</b> array member of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-bitmapinfo">BITMAPINFO</a> structure pointed to by <i>pbmi</i> (either logical palette indexes or literal RGB values). The following values are defined. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createdibsection#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="ppvBits">A pointer to a variable that receives a pointer to the location of the DIB bit values.</param>
            <param name="hSection">
            <para>A handle to a file-mapping object that the function will use to create the DIB. This parameter can be <b>NULL</b>. If <i>hSection</i> is not <b>NULL</b>, it must be a handle to a file-mapping object created by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping</a> function with the PAGE_READWRITE or PAGE_WRITECOPY flag. Read-only DIB sections are not supported. Handles created by other means will cause <b>CreateDIBSection</b> to fail. If <i>hSection</i> is not <b>NULL</b>, the <b>CreateDIBSection</b> function locates the bitmap bit values at offset <i>dwOffset</i> in the file-mapping object referred to by <i>hSection</i>. An application can later retrieve the <i>hSection</i> handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getobject">GetObject</a> function with the <b>HBITMAP</b> returned by <b>CreateDIBSection</b>. If <i>hSection</i> is <b>NULL</b>, the system allocates memory for the DIB. In this case, the <b>CreateDIBSection</b> function ignores the <i>dwOffset</i> parameter. An application cannot later obtain a handle to this memory. The <b>dshSection</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-dibsection">DIBSECTION</a> structure filled in by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getobject">GetObject</a> function will be <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createdibsection#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="offset">The offset from the beginning of the file-mapping object referenced by <i>hSection</i> where storage for the bitmap bit values is to begin. This value is ignored if <i>hSection</i> is <b>NULL</b>. The bitmap bit values are aligned on doubleword boundaries, so <i>dwOffset</i> must be a multiple of the size of a <b>DWORD</b>.</param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the newly created DIB, and *<i>ppvBits</i> points to the bitmap bit values. If the function fails, the return value is <b>NULL</b>, and *<i>ppvBits</i> is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> can return the following value: </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>As noted above, if <i>hSection</i> is <b>NULL</b>, the system allocates memory for the DIB. The system closes the handle to that memory when you later delete the DIB by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a> function. If <i>hSection</i> is not <b>NULL</b>, you must close the <i>hSection</i> memory handle yourself after calling <b>DeleteObject</b> to delete the bitmap. You cannot paste a DIB section from one application into another application. <b>CreateDIBSection</b> does not use the <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader">BITMAPINFOHEADER</a> parameters <i>biXPelsPerMeter</i> or <i>biYPelsPerMeter</i> and will not provide resolution information in the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-bitmapinfo">BITMAPINFO</a> structure. You need to guarantee that the GDI subsystem has completed any drawing to a bitmap created by <b>CreateDIBSection</b> before you draw to the bitmap yourself. Access to the bitmap must be synchronized. Do this by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-gdiflush">GdiFlush</a> function. This applies to any use of the pointer to the bitmap bit values, including passing the pointer in calls to functions such as <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setdibits">SetDIBits</a>. <b>ICM:</b> No color management is done.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createdibsection#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateEnhMetaFile(Windows.Win32.Graphics.Gdi.HDC,System.String,System.Nullable{Windows.Win32.Foundation.RECT},System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.CreateEnhMetaFile(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.RECT*,Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateEnhMetaFile(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.RECT*,Windows.Win32.Foundation.PCWSTR)">
            <summary>The CreateEnhMetaFile function creates a device context for an enhanced-format metafile. This device context can be used to store a device-independent picture. (Unicode)</summary>
            <param name="hdc">A handle to a reference device for the enhanced metafile. This parameter can be <b>NULL</b>; for more information, see Remarks.</param>
            <param name="lpFilename">A pointer to the file name for the enhanced metafile to be created. If this parameter is <b>NULL</b>, the enhanced metafile is memory based and its contents are lost when it is deleted by using the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteenhmetafile">DeleteEnhMetaFile</a> function.</param>
            <param name="lprc">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the dimensions (in .01-millimeter units) of the picture to be stored in the enhanced metafile.</param>
            <param name="lpDesc">A pointer to a string that specifies the name of the application that created the picture, as well as the picture's title. This parameter can be <b>NULL</b>; for more information, see Remarks.</param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the device context for the enhanced metafile. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>Where text arguments must use Unicode characters, use the <b>CreateEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function. The system uses the reference device identified by the <i>hdcRef</i> parameter to record the resolution and units of the device on which a picture originally appeared. If the <i>hdcRef</i> parameter is <b>NULL</b>, it uses the current display device for reference. The <b>left</b> and <b>top</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure pointed to by the <i>lpRect</i> parameter must be less than the <b>right</b> and <b>bottom</b> members, respectively. Points along the edges of the rectangle are included in the picture. If <i>lpRect</i> is <b>NULL</b>, the graphics device interface (GDI) computes the dimensions of the smallest rectangle that surrounds the picture drawn by the application. The <i>lpRect</i> parameter should be provided where possible. The string pointed to by the <i>lpDescription</i> parameter must contain a null character between the application name and the picture name and must terminate with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0", where \0 represents the null character. If <i>lpDescription</i> is <b>NULL</b>, there is no corresponding entry in the enhanced-metafile header. Applications use the device context created by this function to store a graphics picture in an enhanced metafile. The handle identifying this device context can be passed to any GDI function. After an application stores a picture in an enhanced metafile, it can display the picture on any output device by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-playenhmetafile">PlayEnhMetaFile</a> function. When displaying the picture, the system uses the rectangle pointed to by the <i>lpRect</i> parameter and the resolution data from the reference device to position and scale the picture. The device context returned by this function contains the same default attributes associated with any new device context. Applications must use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getwinmetafilebits">GetWinMetaFileBits</a> function to convert an enhanced metafile to the older Windows metafile format. The file name for the enhanced metafile should use the .emf extension.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createenhmetafilew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateFontIndirect(Windows.Win32.Graphics.Gdi.LOGFONTW@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.CreateFontIndirect(Windows.Win32.Graphics.Gdi.LOGFONTW*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateFontIndirect(Windows.Win32.Graphics.Gdi.LOGFONTW*)">
            <summary>The CreateFontIndirect function creates a logical font that has the specified characteristics. The font can subsequently be selected as the current font for any device context. (Unicode)</summary>
            <param name="lplf">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure that defines the characteristics of the logical font.</param>
            <returns>
            <para>If the function succeeds, the return value is a handle to a logical font. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>The <b>CreateFontIndirect</b> function creates a logical font with the characteristics specified in the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure. When this font is selected by using the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-selectobject">SelectObject</a> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible. To get the appropriate font on different language versions of the OS, call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesexa">EnumFontFamiliesEx</a> with the desired font characteristics in the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure, retrieve the appropriate typeface name, and create the font using <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createfonta">CreateFont</a> or <b>CreateFontIndirect</b>. When you no longer need the font, call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a> function to delete it. The fonts for many East Asian languages have two typeface names: an English name and a localized name. <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createfonta">CreateFont</a> and <b>CreateFontIndirect</b> take the localized typeface name only on a system locale that matches the language, while they take the English typeface name on all other system locales. The best method is to try one name and, on failure, try the other. Note that <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-enumfontsa">EnumFonts</a>, <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesa">EnumFontFamilies</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesexa">EnumFontFamiliesEx</a> return the English typeface name if the system locale does not match the language of the font. The font mapper for <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createfonta">CreateFont</a>, <b>CreateFontIndirect</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createfontindirectexa">CreateFontIndirectEx</a> recognizes both the English and the localized typeface name, regardless of locale.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createfontindirectw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateICW(System.String,System.String,System.String,System.Nullable{Windows.Win32.Graphics.Gdi.DEVMODEW})">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.CreateICW(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Graphics.Gdi.DEVMODEW*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateICW(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Graphics.Gdi.DEVMODEW*)">
            <summary>The CreateIC function creates an information context for the specified device. (Unicode)</summary>
            <param name="pszDriver">A pointer to a null-terminated character string that specifies the name of the device driver (for example, Epson).</param>
            <param name="pszDevice">A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</param>
            <param name="pszPort">This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</param>
            <param name="pdm">A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com/windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>lpdvmInit</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</param>
            <returns>
            <para>If the function succeeds, the return value is the handle to an information context. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>When you no longer need the information DC, call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deletedc">DeleteDC</a> function.</para>
            <para>> [!NOTE] > The wingdi.h header defines CreateIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createicw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreatePen(Windows.Win32.Graphics.Gdi.PEN_STYLE,System.Int32,Windows.Win32.Foundation.COLORREF)">
            <summary>The CreatePen function creates a logical pen that has the specified style, width, and color. The pen can subsequently be selected into a device context and used to draw lines and curves.</summary>
            <param name="iStyle"></param>
            <param name="cWidth">
            <para>The width of the pen, in logical units. If <i>nWidth</i> is zero, the pen is a single pixel wide, regardless of the current transformation. <b>CreatePen</b> returns a pen with the specified width but with the PS_SOLID style if you specify a width greater than one for the following styles: PS_DASH, PS_DOT, PS_DASHDOT, PS_DASHDOTDOT.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createpen#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="color">A color reference for the pen color. To generate a <a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a> structure, use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-rgb">RGB</a> macro.</param>
            <returns>
            <para>If the function succeeds, the return value is a handle that identifies a logical pen. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>After an application creates a logical pen, it can select that pen into a device context by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-selectobject">SelectObject</a> function. After a pen is selected into a device context, it can be used to draw lines and curves. If the value specified by the <i>nWidth</i> parameter is zero, a line drawn with the created pen always is a single pixel wide regardless of the current transformation. If the value specified by <i>nWidth</i> is greater than 1, the <i>fnPenStyle</i> parameter must be PS_NULL, PS_SOLID, or PS_INSIDEFRAME. If the value specified by <i>nWidth</i> is greater than 1 and <i>fnPenStyle</i> is PS_INSIDEFRAME, the line associated with the pen is drawn inside the frame of all primitives except polygons and polylines. If the value specified by <i>nWidth</i> is greater than 1, <i>fnPenStyle</i> is PS_INSIDEFRAME, and the color specified by the <i>crColor</i> parameter does not match one of the entries in the logical palette, the system draws lines by using a dithered color. Dithered colors are not available with solid pens. When using an <i>iStyle</i> parameter of PS_DASH, PS_DOT, PS_DASHDOT or PS_DASHDOTDOT, in order to make the gaps between the dashes or dots transparent, use <a href="https://docs.microsoft.com/windows/win32/api/wingdi/nf-wingdi-setbkmode">SetBkMode</a> to set the mode to TRANSPARENT. When you no longer need the pen, call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a> function to delete it. <b>ICM:</b> No color management is done at creation. However, color management is performed when the pen is selected into an ICM-enabled device context.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createpen#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CreateRectRgn(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>The CreateRectRgn function creates a rectangular region.</summary>
            <param name="x1">Specifies the x-coordinate of the upper-left corner of the region in logical units.</param>
            <param name="y1">Specifies the y-coordinate of the upper-left corner of the region in logical units.</param>
            <param name="x2">Specifies the x-coordinate of the lower-right corner of the region in logical units.</param>
            <param name="y2">Specifies the y-coordinate of the lower-right corner of the region in logical units.</param>
            <returns>
            <para>If the function succeeds, the return value is the handle to the region. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>When you no longer need the <b>HRGN</b> object, call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a> function to delete it. Region coordinates are represented as 27-bit signed integers. Regions created by the Create&lt;shape&gt;Rgn methods (such as <b>CreateRectRgn</b> and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createpolygonrgn">CreatePolygonRgn</a>) only include the interior of the shape; the shape's outline is excluded from the region. This means that any point on a line between two sequential vertices is not included in the region. If you were to call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-ptinregion">PtInRegion</a> for such a point, it would return zero as the result.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-createrectrgn#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Windows.Win32.PInvokeCore.CreateSolidBrush(Windows.Win32.Foundation.COLORREF)" -->
        <member name="M:Windows.Win32.PInvokeCore.DeleteDC(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The DeleteDC function deletes the specified device context (DC).</summary>
            <param name="hdc">A handle to the device context.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>An application must not delete a DC whose handle was obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdc">GetDC</a> function. Instead, it must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-releasedc">ReleaseDC</a> function to free the DC.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.EnumEnhMetaFile(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HENHMETAFILE,,System.Void*,System.Nullable{Windows.Win32.Foundation.RECT})">
            <inheritdoc cref="!:EnumEnhMetaFile(winmdroot.Graphics.Gdi.HDC, winmdroot.Graphics.Gdi.HENHMETAFILE, delegate *unmanaged[Stdcall]&lt;global::Windows.Win32.Graphics.Gdi.HDC,global::Windows.Win32.Graphics.Gdi.HANDLETABLE*,global::Windows.Win32.Graphics.Gdi.ENHMETARECORD*,int,global::Windows.Win32.Foundation.LPARAM,int&gt;, void*, winmdroot.Foundation.RECT*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.EnumEnhMetaFile(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HENHMETAFILE,,System.Void*,Windows.Win32.Foundation.RECT*)">
            <summary>The EnumEnhMetaFile function enumerates the records within an enhanced-format metafile by retrieving each record and passing it to the specified callback function.</summary>
            <param name="hdc">A handle to a device context. This handle is passed to the callback function.</param>
            <param name="hmf">A handle to an enhanced metafile.</param>
            <param name="proc">A pointer to the application-supplied callback function. For more information, see the <a href="https://docs.microsoft.com/previous-versions/dd162606(v=vs.85)">EnhMetaFileProc</a> function.</param>
            <param name="lpRect">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the coordinates, in logical units, of the picture's upper-left and lower-right corners.</param>
            <returns>
            <para>If the callback function successfully enumerates all the records in the enhanced metafile, the return value is nonzero. If the callback function does not successfully enumerate all the records in the enhanced metafile, the return value is zero.</para>
            </returns>
            <remarks>
            <para>Points along the edge of the rectangle pointed to by the <i>lpRect</i> parameter are included in the picture. If the <i>hdc</i> parameter is <b>NULL</b>, the system ignores <i>lpRect</i>. If the callback function calls the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-playenhmetafilerecord">PlayEnhMetaFileRecord</a> function, <i>hdc</i> must identify a valid device context. The system uses the device context's transformation and mapping mode to transform the picture displayed by the <b>PlayEnhMetaFileRecord</b> function. You can use the <b>EnumEnhMetaFile</b> function to embed one enhanced-metafile within another.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-enumenhmetafile#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetClipRgn(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HRGN)">
            <summary>The GetClipRgn function retrieves a handle identifying the current application-defined clipping region for the specified device context.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="hrgn">A handle to an existing region before the function is called. After the function returns, this parameter is a handle to a copy of the current clipping region.</param>
            <returns>If the function succeeds and there is no clipping region for the given device context, the return value is zero. If the function succeeds and there is a clipping region for the given device context, the return value is 1. If an error occurs, the return value is -1.</returns>
            <remarks>
            <para>An application-defined clipping region is a clipping region identified by the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-selectcliprgn">SelectClipRgn</a> function. It is not a clipping region created when the application calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-beginpaint">BeginPaint</a> function. If the function succeeds, the <i>hrgn</i> parameter is a handle to a copy of the current clipping region. Subsequent changes to this copy will not affect the current clipping region.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getcliprgn#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetDeviceCaps(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.GET_DEVICE_CAPS_INDEX)">
            <summary>The GetDeviceCaps function retrieves device-specific information for the specified device.</summary>
            <param name="hdc">A handle to the DC.</param>
            <param name="index"></param>
            <returns>
            <para>The return value specifies the value of the desired item. When <i>nIndex</i> is BITSPIXEL and the device has 15bpp or 16bpp, the return value is 16.</para>
            </returns>
            <remarks>
            <para>When <i>nIndex</i> is SHADEBLENDCAPS: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getdevicecaps#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetEnhMetaFileBits(Windows.Win32.Graphics.Gdi.HENHMETAFILE,System.Span{System.Byte})">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetEnhMetaFileBits(Windows.Win32.Graphics.Gdi.HENHMETAFILE,System.UInt32,System.Byte*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetEnhMetaFileBits(Windows.Win32.Graphics.Gdi.HENHMETAFILE,System.UInt32,System.Byte*)">
            <summary>The GetEnhMetaFileBits function retrieves the contents of the specified enhanced-format metafile and copies them into a buffer.</summary>
            <param name="hEMF">A handle to the enhanced metafile.</param>
            <param name="nSize">The size, in bytes, of the buffer to receive the data.</param>
            <param name="lpData">A pointer to a buffer that receives the metafile data. The buffer must be sufficiently large to contain the data. If <i>lpbBuffer</i> is <b>NULL</b>, the function returns the size necessary to hold the data.</param>
            <returns>
            <para>If the function succeeds and the buffer pointer is <b>NULL</b>, the return value is the size of the enhanced metafile, in bytes. If the function succeeds and the buffer pointer is a valid pointer, the return value is the number of bytes copied to the buffer. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>After the enhanced-metafile bits are retrieved, they can be used to create a memory-based metafile by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setenhmetafilebits">SetEnhMetaFileBits</a> function. The <b>GetEnhMetaFileBits</b> function does not invalidate the enhanced-metafile handle. The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteenhmetafile">DeleteEnhMetaFile</a> function to delete the handle when it is no longer needed. The metafile contents retrieved by this function are in the enhanced format. To retrieve the metafile contents in the Windows format, use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getwinmetafilebits">GetWinMetaFileBits</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getenhmetafilebits#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetObject(Windows.Win32.Graphics.Gdi.HGDIOBJ,System.Int32,System.Void*)">
            <summary>The GetObjectW (Unicode) function (wingdi.h) retrieves information for the specified graphics object.</summary>
            <returns>
            <para>If the function succeeds, and <i>lpvObject</i> is a valid pointer, the return value is the number of bytes stored into the buffer. If the function succeeds, and <i>lpvObject</i> is <b>NULL</b>, the return value is the number of bytes required to hold the information the function would store into the buffer. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The buffer pointed to by the <i>lpvObject</i> parameter must be sufficiently large to receive the information about the graphics object. Depending on the graphics object, the function uses a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-bitmap">BITMAP</a>, <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-dibsection">DIBSECTION</a>, <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-extlogpen">EXTLOGPEN</a>, <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logbrush">LOGBRUSH</a>, <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logpen">LOGPEN</a> structure, or a count of table entries (for a logical palette). If <i>hgdiobj</i> is a handle to a bitmap created by calling <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createdibsection">CreateDIBSection</a>, and the specified buffer is large enough, the <b>GetObject</b> function returns a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-dibsection">DIBSECTION</a> structure. In addition, the <b>bmBits</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-bitmap">BITMAP</a> structure contained within the <b>DIBSECTION</b> will contain a pointer to the bitmap's bit values. If <i>hgdiobj</i> is a handle to a bitmap created by any other means, <b>GetObject</b> returns only the width, height, and color format information of the bitmap. You can obtain the bitmap's bit values by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdibits">GetDIBits</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getbitmapbits">GetBitmapBits</a> function. If <i>hgdiobj</i> is a handle to a logical palette, <b>GetObject</b> retrieves a 2-byte integer that specifies the number of entries in the palette. The function does not retrieve the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logpalette">LOGPALETTE</a> structure defining the palette. To retrieve information about palette entries, an application can call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getpaletteentries">GetPaletteEntries</a> function. If <i>hgdiobj</i> is a handle to a font, the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> that is returned is the <b>LOGFONT</b> used to create the font. If Windows had to make some interpolation of the font because the precise <b>LOGFONT</b> could not be represented, the interpolation will not be reflected in the <b>LOGFONT</b>. For example, if you ask for a vertical version of a font that doesn't support vertical painting, the <b>LOGFONT</b> indicates the font is vertical, but Windows will paint it horizontally.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getobjectw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetObjectType(Windows.Win32.Graphics.Gdi.HGDIOBJ)">
            <summary>The GetObjectType retrieves the type of the specified object.</summary>
            <param name="h">A handle to the graphics object.</param>
            <returns>
            <para>If the function succeeds, the return value identifies the object. This value can be one of the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getobjecttype">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetPaletteEntries(Windows.Win32.Graphics.Gdi.HPALETTE,System.UInt32,System.Span{Windows.Win32.Graphics.Gdi.PALETTEENTRY})">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetPaletteEntries(Windows.Win32.Graphics.Gdi.HPALETTE,System.UInt32,System.UInt32,Windows.Win32.Graphics.Gdi.PALETTEENTRY*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetPaletteEntries(Windows.Win32.Graphics.Gdi.HPALETTE,System.UInt32,System.UInt32,Windows.Win32.Graphics.Gdi.PALETTEENTRY*)">
            <summary>The GetPaletteEntries function retrieves a specified range of palette entries from the given logical palette.</summary>
            <param name="hpal">A handle to the logical palette.</param>
            <param name="iStart">The first entry in the logical palette to be retrieved.</param>
            <param name="cEntries">The number of entries in the logical palette to be retrieved.</param>
            <param name="pPalEntries">A pointer to an array of <a href="https://docs.microsoft.com/previous-versions/dd162769(v=vs.85)">PALETTEENTRY</a> structures to receive the palette entries. The array must contain at least as many structures as specified by the <i>nEntries</i> parameter.</param>
            <returns>
            <para>If the function succeeds and the handle to the logical palette is a valid pointer (not <b>NULL</b>), the return value is the number of entries retrieved from the logical palette. If the function succeeds and handle to the logical palette is <b>NULL</b>, the return value is the number of entries in the given palette. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>An application can determine whether a device supports palette operations by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps">GetDeviceCaps</a> function and specifying the RASTERCAPS constant. If the <i>nEntries</i> parameter specifies more entries than exist in the palette, the remaining members of the <a href="https://docs.microsoft.com/previous-versions/dd162769(v=vs.85)">PALETTEENTRY</a> structure are not altered.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getpaletteentries#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetRegionData(Windows.Win32.Graphics.Gdi.HRGN,System.UInt32,Windows.Win32.Graphics.Gdi.RGNDATA*)">
            <summary>The GetRegionData function fills the specified buffer with data describing a region. This data includes the dimensions of the rectangles that make up the region.</summary>
            <param name="hrgn">A handle to the region.</param>
            <param name="nCount">The size, in bytes, of the <i>lpRgnData</i> buffer.</param>
            <param name="lpRgnData">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-rgndata">RGNDATA</a> structure that receives the information. The dimensions of the region are in logical units. If this parameter is <b>NULL</b>, the return value contains the number of bytes needed for the region data.</param>
            <returns>
            <para>If the function succeeds and <i>dwCount</i> specifies an adequate number of bytes, the return value is always <i>dwCount</i>. If <i>dwCount</i> is too small or the function fails, the return value is 0. If <i>lpRgnData</i> is <b>NULL</b>, the return value is the required number of bytes. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>The <b>GetRegionData</b> function is used in conjunction with the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-extcreateregion">ExtCreateRegion</a> function.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetStockObject(Windows.Win32.Graphics.Gdi.GET_STOCK_OBJECT_FLAGS)">
            <summary>The GetStockObject function retrieves a handle to one of the stock pens, brushes, fonts, or palettes.</summary>
            <param name="i"></param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the requested logical object. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>It is not recommended that you employ this method to obtain the current font used by dialogs and windows. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a> function with the SPI_GETNONCLIENTMETRICS parameter to retrieve the current font. <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a> will take into account the current theme and provides font information for captions, menus, and message dialogs. Use the DKGRAY_BRUSH, GRAY_BRUSH, and LTGRAY_BRUSH stock objects only in windows with the CS_HREDRAW and CS_VREDRAW styles. Using a gray stock brush in any other style of window can lead to misalignment of brush patterns after a window is moved or sized. The origins of stock brushes cannot be adjusted. The HOLLOW_BRUSH and NULL_BRUSH stock objects are equivalent. It is not necessary (but it is not harmful) to delete stock objects by calling <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a>. Both DC_BRUSH and DC_PEN can be used interchangeably with other stock objects like BLACK_BRUSH and BLACK_PEN. For information on retrieving the current pen or brush color, see <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdcbrushcolor">GetDCBrushColor</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdcpencolor">GetDCPenColor</a>. See <a href="https://docs.microsoft.com/windows/desktop/gdi/setting-the-pen-or-brush-color">Setting the Pen or Brush Color</a> for an example of setting colors. The <b>GetStockObject</b> function with an argument of DC_BRUSH or DC_PEN can be used interchangeably with the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setdcpencolor">SetDCPenColor</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setdcbrushcolor">SetDCBrushColor</a> functions.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getstockobject#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetViewportExtEx(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.SIZE@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetViewportExtEx(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.SIZE*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetViewportExtEx(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.SIZE*)">
            <summary>The GetViewportExtEx function retrieves the x-extent and y-extent of the current viewport for the specified device context.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="lpsize">A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-size">SIZE</a> structure that receives the x- and y-extents, in device units.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getviewportextex">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetViewportOrgEx(Windows.Win32.Graphics.Gdi.HDC,System.Drawing.Point@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetViewportOrgEx(Windows.Win32.Graphics.Gdi.HDC,System.Drawing.Point*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetViewportOrgEx(Windows.Win32.Graphics.Gdi.HDC,System.Drawing.Point*)">
            <summary>The GetViewportOrgEx function retrieves the x-coordinates and y-coordinates of the viewport origin for the specified device context.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="lppoint">A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that receives the coordinates of the origin, in device units.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getviewportorgex">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.IntersectClipRect(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>The IntersectClipRect function creates a new clipping region from the intersection of the current clipping region and the specified rectangle.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="left">The x-coordinate, in logical units, of the upper-left corner of the rectangle.</param>
            <param name="top">The y-coordinate, in logical units, of the upper-left corner of the rectangle.</param>
            <param name="right">The x-coordinate, in logical units, of the lower-right corner of the rectangle.</param>
            <param name="bottom">The y-coordinate, in logical units, of the lower-right corner of the rectangle.</param>
            <returns>
            <para>The return value specifies the new clipping region's type and can be one of the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The lower and right-most edges of the given rectangle are excluded from the clipping region. If a clipping region does not already exist then the system may apply a default clipping region to the specified HDC. A clipping region is then created from the intersection of that default clipping region and the rectangle specified in the function parameters.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-intersectcliprect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.OffsetViewportOrgEx(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Drawing.Point*)">
            <summary>The OffsetViewportOrgEx function modifies the viewport origin for a device context using the specified horizontal and vertical offsets.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="x">The horizontal offset, in device units.</param>
            <param name="y">The vertical offset, in device units.</param>
            <param name="lppt">A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure. The previous viewport origin, in device units, is placed in this structure. If <i>lpPoint</i> is <b>NULL</b>, the previous viewport origin is not returned.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>The new origin is the sum of the current origin and the horizontal and vertical offsets.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DeleteMetaFile(Windows.Win32.Graphics.Gdi.HMETAFILE)">
            <summary>The DeleteMetaFile function deletes a Windows-format metafile or Windows-format metafile handle.</summary>
            <param name="hmf">A handle to a Windows-format metafile.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>If the metafile identified by the <i>hmf</i> parameter is stored in memory (rather than on a disk), its content is lost when it is deleted by using the <b>DeleteMetaFile</b> function.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.RealizePalette(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The RealizePalette function maps palette entries from the current logical palette to the system palette.</summary>
            <param name="hdc">A handle to the device context into which a logical palette has been selected.</param>
            <returns>
            <para>If the function succeeds, the return value is the number of entries in the logical palette mapped to the system palette. If the function fails, the return value is GDI_ERROR.</para>
            </returns>
            <remarks>
            <para>An application can determine whether a device supports palette operations by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps">GetDeviceCaps</a> function and specifying the RASTERCAPS constant. The <b>RealizePalette</b> function modifies the palette for the device associated with the specified device context. If the device context is a memory DC, the color table for the bitmap selected into the DC is modified. If the device context is a display DC, the physical palette for that device is modified. A logical palette is a buffer between color-intensive applications and the system, allowing these applications to use as many colors as needed without interfering with colors displayed by other windows. When an application's window has the focus and it calls the <b>RealizePalette</b> function, the system attempts to realize as many of the requested colors as possible. The same is also true for applications with inactive windows.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-realizepalette#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.Rectangle(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>The Rectangle function draws a rectangle. The rectangle is outlined by using the current pen and filled by using the current brush.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="left">The x-coordinate, in logical coordinates, of the upper-left corner of the rectangle.</param>
            <param name="top">The y-coordinate, in logical coordinates, of the upper-left corner of the rectangle.</param>
            <param name="right">The x-coordinate, in logical coordinates, of the lower-right corner of the rectangle.</param>
            <param name="bottom">The y-coordinate, in logical coordinates, of the lower-right corner of the rectangle.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The current position is neither used nor updated by <b>Rectangle</b>. The rectangle that is drawn excludes the bottom and right edges. If a PS_NULL pen is used, the dimensions of the rectangle are 1 pixel less in height and 1 pixel less in width.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-rectangle#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.RestoreDC(Windows.Win32.Graphics.Gdi.HDC,System.Int32)">
            <summary>The RestoreDC function restores a device context (DC) to the specified state. The DC is restored by popping state information off a stack created by earlier calls to the SaveDC function.</summary>
            <param name="hdc">A handle to the DC.</param>
            <param name="nSavedDC">The saved state to be restored. If this parameter is positive, <i>nSavedDC</i> represents a specific instance of the state to be restored. If this parameter is negative, <i>nSavedDC</i> represents an instance relative to the current state. For example, -1 restores the most recently saved state.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>Each DC maintains a stack of saved states. The <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-savedc">SaveDC</a> function pushes the current state of the DC onto its stack of saved states. That state can be restored only to the same DC from which it was created. After a state is restored, the saved state is destroyed and cannot be reused. Furthermore, any states saved after the restored state was created are also destroyed and cannot be used. In other words, the <b>RestoreDC</b> function pops the restored state (and any subsequent states) from the state information stack.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SaveDC(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The SaveDC function saves the current state of the specified device context (DC) by copying data describing selected objects and graphic modes (such as the bitmap, brush, palette, font, pen, region, drawing mode, and mapping mode) to a context stack.</summary>
            <param name="hdc">A handle to the DC whose state is to be saved.</param>
            <returns>
            <para>If the function succeeds, the return value identifies the saved state. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The <b>SaveDC</b> function can be used any number of times to save any number of instances of the DC state. A saved state can be restored by using the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-restoredc">RestoreDC</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-savedc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SelectClipRgn(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HRGN)">
            <summary>The SelectClipRgn function selects a region as the current clipping region for the specified device context.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="hrgn">A handle to the region to be selected.</param>
            <returns>
            <para>The return value specifies the region's complexity and can be one of the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>Only a copy of the selected region is used. The region itself can be selected for any number of other device contexts or it can be deleted. The <b>SelectClipRgn</b> function assumes that the coordinates for a region are specified in device units. To remove a device-context's clipping region, specify a <b>NULL</b> region handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-selectcliprgn#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SelectObject(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HGDIOBJ)">
            <summary>The SelectObject function selects an object into the specified device context (DC). The new object replaces the previous object of the same type.</summary>
            <param name="hdc">A handle to the DC.</param>
            <param name="h">
            <para>A handle to the object to be selected. The specified object must have been created by using one of the following functions. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-selectobject#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the selected object is not a region and the function succeeds, the return value is a handle to the object being replaced. If the selected object is a region and the function succeeds, the return value is one of the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>This function returns the previously selected object of the specified type. An application should always replace a new object with the original, default object after it has finished drawing with the new object. An application cannot select a single bitmap into more than one DC at a time. <b>ICM:</b> If the object being selected is a brush or a pen, color management is performed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-selectobject#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SelectPalette(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HPALETTE,Windows.Win32.Foundation.BOOL)">
            <summary>The SelectPalette function selects the specified logical palette into a device context.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="hPal">A handle to the logical palette to be selected.</param>
            <param name="bForceBkgd">
            <para>Specifies whether the logical palette is forced to be a background palette. If this value is <b>TRUE</b>, the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-realizepalette">RealizePalette</a> function causes the logical palette to be mapped to the colors already in the physical palette in the best possible way. This is always done, even if the window for which the palette is realized belongs to a thread without active focus. If this value is <b>FALSE</b>, <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-realizepalette">RealizePalette</a> causes the logical palette to be copied into the device palette when the application is in the foreground. (If the <i>hdc</i> parameter is a memory device context, this parameter is ignored.)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-selectpalette#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the device context's previous logical palette. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>An application can determine whether a device supports palette operations by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps">GetDeviceCaps</a> function and specifying the RASTERCAPS constant. An application can select a logical palette into more than one device context only if device contexts are compatible. Otherwise <b>SelectPalette</b> fails. To create a device context that is compatible with another device context, call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createcompatibledc">CreateCompatibleDC</a> with the first device context as the parameter. If a logical palette is selected into more than one device context, changes to the logical palette will affect all device contexts for which it is selected. An application might call the <b>SelectPalette</b> function with the <i>bForceBackground</i> parameter set to <b>TRUE</b> if the child windows of a top-level window each realize their own palettes. However, only the child window that needs to realize its palette must set <i>bForceBackground</i> to <b>TRUE</b>; other child windows must set this value to <b>FALSE</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-selectpalette#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SetBkColor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.COLORREF)">
            <summary>The SetBkColor function sets the current background color to the specified color value, or to the nearest physical color if the device cannot represent the specified color value.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="color">The new background color. To make a <a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a> value, use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-rgb">RGB</a> macro.</param>
            <returns>
            <para>If the function succeeds, the return value specifies the previous background color as a <a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a> value. If the function fails, the return value is CLR_INVALID.</para>
            </returns>
            <remarks>
            <para>This function fills the gaps between styled lines drawn using a pen created by the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createpen">CreatePen</a> function; it does not fill the gaps between styled lines drawn using a pen created by the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-extcreatepen">ExtCreatePen</a> function. The <b>SetBkColor</b> function also sets the background colors for <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-textouta">TextOut</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a>. If the background mode is OPAQUE, the background color is used to fill gaps between styled lines, gaps between hatched lines in brushes, and character cells. The background color is also used when converting bitmaps from color to monochrome and vice versa.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-setbkcolor#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SetBkMode(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.BACKGROUND_MODE)">
            <summary>The SetBkMode function sets the background mix mode of the specified device context. The background mix mode is used with text, hatched brushes, and pen styles that are not solid lines.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="mode"></param>
            <returns>
            <para>If the function succeeds, the return value specifies the previous background mode. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>The <b>SetBkMode</b> function affects the line styles for lines drawn using a pen created by the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createpen">CreatePen</a> function. <b>SetBkMode</b> does not affect lines drawn using a pen created by the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-extcreatepen">ExtCreatePen</a> function.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SetMapMode(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HDC_MAP_MODE)">
            <summary>The SetMapMode function sets the mapping mode of the specified device context. The mapping mode defines the unit of measure used to transform page-space units into device-space units, and also defines the orientation of the device's x and y axes.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="iMode"></param>
            <returns>
            <para>If the function succeeds, the return value identifies the previous mapping mode. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The MM_TEXT mode allows applications to work in device pixels, whose size varies from device to device. The MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC, and MM_TWIPS modes are useful for applications drawing in physically meaningful units (such as inches or millimeters). The MM_ISOTROPIC mode ensures a 1:1 aspect ratio. The MM_ANISOTROPIC mode allows the x-coordinates and y-coordinates to be adjusted independently.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-setmapmode#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SetROP2(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.R2_MODE)">
            <summary>The SetROP2 function sets the current foreground mix mode.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="rop2"></param>
            <returns>
            <para>If the function succeeds, the return value specifies the previous mix mode. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>Mix modes define how GDI combines source and destination colors when drawing with the current pen. The mix modes are binary raster operation codes, representing all possible Boolean functions of two variables, using the binary operations AND, OR, and XOR (exclusive OR), and the unary operation NOT. The mix mode is for raster devices only; it is not available for vector devices.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SetTextAlign(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.TEXT_ALIGN_OPTIONS)">
            <summary>The SetTextAlign function sets the text-alignment flags for the specified device context.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="align">
            <para>The text alignment by using a mask of the values in the following list. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-settextalign#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is the previous text-alignment setting. If the function fails, the return value is GDI_ERROR.</para>
            </returns>
            <remarks>
            <para>The <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-textouta">TextOut</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a> functions use the text-alignment flags to position a string of text on a display or other device. The flags specify the relationship between a reference point and a rectangle that bounds the text. The reference point is either the current position or a point passed to a text output function. The rectangle that bounds the text is formed by the character cells in the text string. The best way to get left-aligned text is to use either</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-settextalign#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SetTextColor(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.COLORREF)">
            <summary>The SetTextColor function sets the text color for the specified device context to the specified color.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="color">The color of the text.</param>
            <returns>
            <para>If the function succeeds, the return value is a color reference for the previous text color as a <a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a> value. If the function fails, the return value is CLR_INVALID.</para>
            </returns>
            <remarks>The text color is used to draw the face of each character written by the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-textouta">TextOut</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a> functions. The text color is also used in converting bitmaps from color to monochrome and vice versa.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GdiplusStartup(System.UIntPtr@,Windows.Win32.Graphics.GdiPlus.GdiplusStartupInput@,Windows.Win32.Graphics.GdiPlus.GdiplusStartupOutput@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GdiplusStartup(System.UIntPtr*,Windows.Win32.Graphics.GdiPlus.GdiplusStartupInput*,Windows.Win32.Graphics.GdiPlus.GdiplusStartupOutput*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CloseHandle(Windows.Win32.Foundation.HANDLE)">
            <summary>Closes an open object handle.</summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
            </returns>
            <remarks>
            <para>The <b>CloseHandle</b> function closes handles to the following objects: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/handleapi/nf-handleapi-closehandle#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GlobalFree(Windows.Win32.Foundation.HGLOBAL)">
            <summary>Frees the specified global memory object and invalidates its handle.</summary>
            <param name="hMem">
            <para>A handle to the global memory object. This handle is returned by either the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function. It is not safe to free memory allocated with <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globalfree#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is <b>NULL</b>. If the function fails, the return value is equal to a handle to the global memory object. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>If the process examines or modifies the memory after it has been freed, heap corruption may occur or an access violation exception (EXCEPTION_ACCESS_VIOLATION) may be generated. The <b>GlobalFree</b> function will free a locked memory object. A locked memory object has a lock count greater than zero. The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globallock">GlobalLock</a> function locks a global memory object and increments the lock count by one. The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalunlock">GlobalUnlock</a> function unlocks it and decrements the lock count by one. To get the lock count of a global memory object, use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalflags">GlobalFlags</a> function. If an application is running under a debug version of the system, <b>GlobalFree</b> will issue a message that tells you that a locked object is being freed. If you are debugging the application, <b>GlobalFree</b> will enter a breakpoint just before freeing a locked object. This allows you to verify the intended behavior, then continue execution.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globalfree#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetCurrentThreadId">
            <summary>Retrieves the thread identifier of the calling thread.</summary>
            <returns>The return value is the thread identifier of the calling thread.</returns>
            <remarks>Until the thread terminates, the thread identifier uniquely identifies the thread throughout the system.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetSystemDefaultLCID">
            <summary>Returns the locale identifier for the system locale.Note  Any application that runs only on Windows Vista and later should use GetSystemDefaultLocaleName in preference to this function.</summary>
            <returns>Returns the locale identifier for the system default locale, identified by <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>.</returns>
            <remarks>This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetThreadLocale">
            <summary>Returns the locale identifier of the current locale for the calling thread.Note  This function can retrieve data that changes between releases, for example, due to a custom locale.</summary>
            <returns>
            <para>Returns the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale associated with the current thread. <b>Windows Vista</b>: This function can return the identifier of a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locale</a>. If the current thread locale is a custom locale, the function returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>. If the current thread locale is a supplemental custom locale, the function can return <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>. All supplemental locales share this locale identifier.</para>
            </returns>
            <remarks>
            <para>When an application process launches, it uses the Standards and Formats variable for the locale. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/nls-terminology">NLS Terminology</a>. When a new thread is created in a process, it inherits the locale of the creating thread. This locale can be either the default Standards and Formats locale or a different locale set for the creating thread in a call to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreadlocale">SetThreadLocale</a>. <b>GetThreadLocale</b> and <b>SetThreadLocale</b> can be used to modify the locale of the new thread.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getthreadlocale#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GlobalAlloc(Windows.Win32.System.Memory.GLOBAL_ALLOC_FLAGS,System.UIntPtr)">
            <summary>Allocates the specified number of bytes from the heap. (GlobalAlloc)</summary>
            <param name="uFlags"></param>
            <param name="dwBytes">The number of bytes to allocate. If this parameter is zero and the <i>uFlags</i> parameter specifies <b>GMEM_MOVEABLE</b>, the function returns a handle to a memory object that is marked as discarded.</param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the newly allocated memory object. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>Windows memory management does not provide a separate local heap and global heap. Therefore, the <b>GlobalAlloc</b> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> functions are essentially the same. The movable-memory flags <b>GHND</b> and <b>GMEM_MOVABLE</b> add unnecessary overhead and require locking to be used safely. They should be avoided unless documentation specifically states that they should be used. New applications should use the <a href="https://docs.microsoft.com/windows/desktop/Memory/heap-functions">heap functions</a> to allocate and manage memory unless the documentation specifically states that a global function should be used. For example, the global functions are still used with Dynamic Data Exchange (DDE), the clipboard functions, and OLE data objects. If the <b>GlobalAlloc</b> function succeeds, it allocates at least the amount of memory requested. If the actual amount allocated is greater than the amount requested, the process can use the entire amount. To determine the actual number of bytes allocated, use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalsize">GlobalSize</a> function. If the heap does not contain sufficient free space to satisfy the request, <b>GlobalAlloc</b> returns <b>NULL</b>. Because <b>NULL</b> is used to indicate an error, virtual address zero is never allocated. It is, therefore, easy to detect the use of a <b>NULL</b> pointer. Memory allocated with this function is guaranteed to be aligned on an 8-byte boundary. To execute dynamically generated code, use the <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> function to allocate memory and the <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect">VirtualProtect</a> function to grant  <b>PAGE_EXECUTE</b> access. To free the memory, use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalfree">GlobalFree</a> function. It is not safe to free memory allocated with <b>GlobalAlloc</b> using <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globalalloc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GlobalLock(Windows.Win32.Foundation.HGLOBAL)">
            <summary>Locks a global memory object and returns a pointer to the first byte of the object's memory block.</summary>
            <param name="hMem">
            <para>A handle to the global memory object. This handle is returned by either the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globallock#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a pointer to the first byte of the memory block. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects, <b>GlobalLock</b> increments the count by one, and the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalunlock">GlobalUnlock</a> function decrements the count by one. Each successful call that a process makes to <b>GlobalLock</b> for an object must be matched by a corresponding call to <b>GlobalUnlock</b>. Locked memory will not be moved or discarded, unless the memory object is reallocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function. The memory block of a locked memory object remains locked until its lock count is decremented to zero, at which time it can be moved or discarded. Memory objects allocated with <b>GMEM_FIXED</b> always have a lock count of zero. For these objects, the value of the returned pointer is equal to the value of the specified handle. If the specified memory block has been discarded or if the memory block has a zero-byte size, this function returns <b>NULL</b>. Discarded objects always have a lock count of zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globallock#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GlobalReAlloc(Windows.Win32.Foundation.HGLOBAL,System.UIntPtr,System.UInt32)">
            <summary>Changes the size or attributes of a specified global memory object. The size can increase or decrease.</summary>
            <param name="hMem">
            <para>A handle to the global memory object to be reallocated. This handle is returned by either the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <b>GlobalReAlloc</b> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globalrealloc#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwBytes">The new size of the memory block, in bytes. If <i>uFlags</i> specifies <b>GMEM_MODIFY</b>, this parameter is ignored.</param>
            <param name="uFlags">
            <para>The reallocation options. If <b>GMEM_MODIFY</b> is specified, the function modifies the attributes of the memory object only (the <i>dwBytes</i> parameter is ignored.) Otherwise, the function reallocates the memory object. You can optionally combine <b>GMEM_MODIFY</b> with the following value. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globalrealloc#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the reallocated memory object. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>If <b>GlobalReAlloc</b> reallocates a movable object, the return value is a handle to the memory object. To convert the handle to a pointer, use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globallock">GlobalLock</a> function. If <b>GlobalReAlloc</b> reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer. If <b>GlobalReAlloc</b> fails, the original memory is not freed, and the original handle and pointer are still valid.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globalrealloc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GlobalSize(Windows.Win32.Foundation.HGLOBAL)">
            <summary>Retrieves the current size of the specified global memory object, in bytes.</summary>
            <param name="hMem">
            <para>A handle to the global memory object. This handle is returned by either the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globalsize#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is the size of the specified global memory object, in bytes. If the specified handle is not valid or if the object has been discarded, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The size of a memory block may be larger than the size requested when the memory was allocated. To verify that the specified object's memory block has not been discarded, use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalflags">GlobalFlags</a> function before calling <b>GlobalSize</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globalsize#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GlobalUnlock(Windows.Win32.Foundation.HGLOBAL)">
            <summary>Decrements the lock count associated with a memory object that was allocated with GMEM_MOVEABLE.</summary>
            <param name="hMem">
            <para>A handle to the global memory object. This handle is returned by either the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globalunlock#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the memory object is still locked after decrementing the lock count, the return value is a nonzero value. If the memory object is unlocked after decrementing the lock count, the function returns zero and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>NO_ERROR</b>. If the function fails, the return value is zero and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns a value other than <b>NO_ERROR</b>.</para>
            </returns>
            <remarks>
            <para>The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects, the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globallock">GlobalLock</a> function increments the count by one, and <b>GlobalUnlock</b> decrements the count by one. For each call that a process makes to <b>GlobalLock</b> for an object, it must eventually call <b>GlobalUnlock</b>. Locked memory will not be moved or discarded, unless the memory object is reallocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalrealloc">GlobalReAlloc</a> function. The memory block of a locked memory object remains locked until its lock count is decremented to zero, at which time it can be moved or discarded. Memory objects allocated with <b>GMEM_FIXED</b> always have a lock count of zero. If the specified memory block is fixed memory, this function returns <b>TRUE</b>. If the memory object is already unlocked, <b>GlobalUnlock</b> returns <b>FALSE</b> and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> reports <b>ERROR_NOT_LOCKED</b>. A process should not rely on the return value to determine the number of times it must subsequently call <b>GlobalUnlock</b> for a memory object.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-globalunlock#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.FreeLibrary(Windows.Win32.Foundation.HMODULE)">
            <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
            <param name="hLibModule">
            <para>A handle to the loaded library module. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
            </returns>
            <remarks>
            <para>The system maintains a per-process reference count for each loaded module. A  module that was loaded at process initialization due to load-time dynamic linking has a reference count of one. The reference count for a module is incremented each time the  module is loaded by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>. The reference count is also incremented by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a> unless the  module  is being loaded for the first time and is being loaded as   a data or image file. The reference count is decremented each time the <b>FreeLibrary</b> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function is called for the module. When a  module's reference count reaches zero or the process terminates, the system unloads the module from the address space of the  process. Before unloading a library module, the system enables the module to detach from the process by calling the module's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function, if it has one, with the DLL_PROCESS_DETACH value. Doing so gives the library module an opportunity to clean up resources allocated on behalf of the current process. After the entry-point function returns, the library module is removed from the address space of the current process. It is not safe to call <b>FreeLibrary</b> from <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. Calling <b>FreeLibrary</b> does not affect other processes that are using the same module. Use caution when calling <b>FreeLibrary</b> with a handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. The <b>GetModuleHandle</b> function does not increment a module's reference count, so passing this handle to <b>FreeLibrary</b> can cause a module to be unloaded prematurely. A thread that must unload the DLL in which it is executing and then terminate itself should call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> instead of calling <b>FreeLibrary</b> and <b>ExitThread</b> separately. Otherwise, a race condition can occur. For details, see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.MultiByteToWideChar(System.UInt32,Windows.Win32.Globalization.MULTI_BYTE_TO_WIDE_CHAR_FLAGS,System.String,System.Int32,Windows.Win32.Foundation.PWSTR,System.Int32)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.MultiByteToWideChar(System.UInt32,Windows.Win32.Globalization.MULTI_BYTE_TO_WIDE_CHAR_FLAGS,Windows.Win32.Foundation.PCSTR,System.Int32,Windows.Win32.Foundation.PWSTR,System.Int32)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.MultiByteToWideChar(System.UInt32,Windows.Win32.Globalization.MULTI_BYTE_TO_WIDE_CHAR_FLAGS,Windows.Win32.Foundation.PCSTR,System.Int32,Windows.Win32.Foundation.PWSTR,System.Int32)">
            <summary>Maps a character string to a UTF-16 (wide character) string.</summary>
            <param name="CodePage">
            <para>Code page to use in performing the conversion. This parameter can be set to the value of any code page that is installed or available in the operating system. For a list of code pages, see <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>. Your application can also specify one of the values shown in the following table. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwFlags"></param>
            <param name="lpMultiByteStr">Pointer to the character string to convert.</param>
            <param name="cbMultiByte">
            <para>Size, in bytes, of the string indicated by the <i>lpMultiByteStr</i> parameter. Alternatively, this parameter can be set to -1 if the string is null-terminated. Note that, if <i>cbMultiByte</i> is 0, the function fails. If this parameter is -1, the function processes the entire input string, including the terminating null character. Therefore, the resulting Unicode string has a terminating null character, and the length returned by the function includes this character. If this parameter is set to a positive integer, the function processes exactly the specified number of bytes. If the provided size does not include a terminating null character, the resulting Unicode string is not null-terminated, and the returned length does not include this character.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpWideCharStr">Pointer to a buffer that receives the converted string.</param>
            <param name="cchWideChar">Size, in characters, of the buffer indicated by <i>lpWideCharStr</i>. If this value is 0, the function returns the required buffer size, in characters, including any terminating null character, and makes no use of the <i>lpWideCharStr</i> buffer.</param>
            <returns>
            <para>Returns the number of characters written to the buffer indicated by <i>lpWideCharStr</i> if successful. If the function succeeds and <i>cchWideChar</i> is 0, the return value is the required size, in characters, for the buffer indicated by <i>lpWideCharStr</i>. Also see <i>dwFlags</i> for info about how the MB_ERR_INVALID_CHARS flag affects the return value when invalid sequences are input. The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes: </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The default behavior of this function is to translate to a precomposed form of the input character string. If a precomposed form does not exist, the function attempts to translate to a composite form. The use of the MB_PRECOMPOSED flag has very little effect on most code pages because most input data is composed already. Consider calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a> after converting with <b>MultiByteToWideChar</b>. <b>NormalizeString</b> provides more accurate, standard, and consistent data, and can also be faster. Note that for the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> enumeration being passed to <b>NormalizeString</b>, NormalizationC corresponds to MB_PRECOMPOSED and NormalizationD corresponds to MB_COMPOSITE. As mentioned in the caution above, the output buffer can easily be overrun if this function is not first called with <i>cchWideChar</i> set to 0 in order to obtain the required size. If the MB_COMPOSITE flag is used, the output can be three or more characters long for each input character. The <i>lpMultiByteStr</i> and <i>lpWideCharStr</i> pointers must not be the same. If they are the same, the function fails, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the value ERROR_INVALID_PARAMETER. <b>MultiByteToWideChar</b> does not null-terminate an output string if the input string length is explicitly specified without a terminating null character. To null-terminate an output string for this function, the application should pass in -1 or explicitly count the terminating null character for the input string. The function fails if MB_ERR_INVALID_CHARS is set and an invalid character is encountered in the source string. An invalid character is one of the following: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.WideCharToMultiByte(System.UInt32,System.UInt32,System.String,System.Int32,Windows.Win32.Foundation.PSTR,System.Int32,System.String,Windows.Win32.Foundation.BOOL*)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.WideCharToMultiByte(System.UInt32,System.UInt32,Windows.Win32.Foundation.PCWSTR,System.Int32,Windows.Win32.Foundation.PSTR,System.Int32,Windows.Win32.Foundation.PCSTR,Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.WideCharToMultiByte(System.UInt32,System.UInt32,Windows.Win32.Foundation.PCWSTR,System.Int32,Windows.Win32.Foundation.PSTR,System.Int32,Windows.Win32.Foundation.PCSTR,Windows.Win32.Foundation.BOOL*)">
            <summary>Maps a UTF-16 (wide character) string to a new character string.</summary>
            <param name="CodePage">
            <para>Code page to use in performing the conversion. This parameter can be set to the value of any code page that is installed or available in the operating system. For a list of code pages, see <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>. Your application can also specify one of the values shown in the following table. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwFlags"></param>
            <param name="lpWideCharStr">Pointer to the Unicode string to convert.</param>
            <param name="cchWideChar">
            <para>Size, in characters, of the string indicated by <i>lpWideCharStr</i>. Alternatively, this parameter can be set to -1 if the string is null-terminated. If <i>cchWideChar</i> is set to 0, the function fails. If this parameter is -1, the function processes the entire input string, including the terminating null character. Therefore, the resulting character string has a terminating null character, and the length returned by the function includes this character. If this parameter is set to a positive integer, the function processes exactly the specified number of characters. If the provided size does not include a terminating null character, the resulting character string is not null-terminated, and the returned length does not include this character.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpMultiByteStr">Pointer to a buffer that receives the converted string.</param>
            <param name="cbMultiByte">Size, in bytes, of the buffer indicated by <i>lpMultiByteStr</i>. If this value is 0, the function returns the required buffer size, in bytes, including any terminating null character, and makes no use of the <i>lpMultiByteStr</i> buffer.</param>
            <param name="lpDefaultChar">
            <para>Pointer to the character to use if a character cannot be represented in the specified code page. The application sets this parameter to <b>NULL</b> if the function is to use a system default value. To obtain the system default character, the application can call the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfo">GetCPInfo</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a> function. For the CP_UTF7 and CP_UTF8 settings for <i>CodePage</i>, this parameter must be set to <b>NULL</b>. Otherwise, the function fails with ERROR_INVALID_PARAMETER.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpUsedDefaultChar">
            <para>Pointer to a flag that indicates if the function has used a default character in the conversion. The flag is set to <b>TRUE</b> if one or more characters in the source string cannot be represented in the specified code page. Otherwise, the flag is set to <b>FALSE</b>. This parameter can be set to <b>NULL</b>. For the CP_UTF7 and CP_UTF8 settings for <i>CodePage</i>, this parameter must be set to <b>NULL</b>. Otherwise, the function fails with ERROR_INVALID_PARAMETER.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If successful, returns the number of bytes written to the buffer pointed to by <i>lpMultiByteStr</i>. If the function succeeds and <i>cbMultiByte</i> is 0, the return value is the required size, in bytes, for the buffer indicated by <i>lpMultiByteStr</i>. Also see <i>dwFlags</i> for info about how the WC_ERR_INVALID_CHARS flag affects the return value when invalid sequences are input. The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes: </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The <i>lpMultiByteStr</i> and <i>lpWideCharStr</i> pointers must not be the same. If they are the same, the function fails, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_PARAMETER. <b>WideCharToMultiByte</b> does not null-terminate an output string if the input string length is explicitly specified without a terminating null character. To null-terminate an output string for this function, the application should pass in -1 or explicitly count the terminating null character for the input string. If <i>cbMultiByte</i> is less than <i>cchWideChar</i>, this function writes the number of characters specified by <i>cbMultiByte</i> to the buffer indicated by <i>lpMultiByteStr</i>. However, if <i>CodePage</i> is set to CP_SYMBOL and <i>cbMultiByte</i> is less than <i>cchWideChar,</i> the function writes no characters to <i>lpMultiByteStr</i>. The <b>WideCharToMultiByte</b> function operates most efficiently when both <i>lpDefaultChar</i> and <i>lpUsedDefaultChar</i> are set to <b>NULL</b>. The following table shows the behavior of the function for the four possible combinations of these parameters. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CoCreateInstance``1(System.Guid@,Windows.Win32.System.Com.IUnknown*,Windows.Win32.System.Com.CLSCTX,``0*@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.CoCreateInstance(System.Guid*,Windows.Win32.System.Com.IUnknown*,Windows.Win32.System.Com.CLSCTX,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CoCreateInstance(System.Guid@,Windows.Win32.System.Com.IUnknown*,Windows.Win32.System.Com.CLSCTX,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.CoCreateInstance(System.Guid*,Windows.Win32.System.Com.IUnknown*,Windows.Win32.System.Com.CLSCTX,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CoCreateInstance(System.Guid*,Windows.Win32.System.Com.IUnknown*,Windows.Win32.System.Com.CLSCTX,System.Guid*,System.Void**)">
            <summary>Creates a single uninitialized object of the class associated with a specified CLSID.</summary>
            <param name="rclsid">The CLSID associated with the data and code that will be used to create the object.</param>
            <param name="pUnkOuter">If <b>NULL</b>, indicates that the object is not being created as part of an aggregate. If non-<b>NULL</b>, pointer to the aggregate object's <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface (the controlling <b>IUnknown</b>).</param>
            <param name="dwClsContext">Context in which the code that manages the newly created object will run. The values are taken from the enumeration <a href="https://docs.microsoft.com/windows/desktop/api/wtypesbase/ne-wtypesbase-clsctx">CLSCTX</a>.</param>
            <param name="riid">A reference to the identifier of the interface to be used to communicate with the object.</param>
            <param name="ppv">Address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful return, *<i>ppv</i> contains the requested interface pointer. Upon failure, *<i>ppv</i> contains <b>NULL</b>.</param>
            <returns>
            <para>This function can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The <b>CoCreateInstance</b> function provides a convenient shortcut by connecting to the class object associated with the specified CLSID, creating a default-initialized instance, and releasing the class object. As such, it encapsulates the following functionality:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DoDragDrop(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.Ole.IDropSource*,Windows.Win32.System.Ole.DROPEFFECT,Windows.Win32.System.Ole.DROPEFFECT@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.DoDragDrop(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.Ole.IDropSource*,Windows.Win32.System.Ole.DROPEFFECT,Windows.Win32.System.Ole.DROPEFFECT*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DoDragDrop(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.Ole.IDropSource*,Windows.Win32.System.Ole.DROPEFFECT,Windows.Win32.System.Ole.DROPEFFECT*)">
            <summary>Carries out an OLE drag and drop operation.</summary>
            <param name="pDataObj">Pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface on a data object that contains the data being dragged.</param>
            <param name="pDropSource">Pointer to an implementation of the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-idropsource">IDropSource</a> interface, which is used to communicate with the source during the drag operation.</param>
            <param name="dwOKEffects">Effects the source allows in the OLE drag-and-drop operation. Most significant is whether it permits a move. The <i>dwOKEffect</i> and <i>pdwEffect</i> parameters obtain values from the <a href="https://docs.microsoft.com/windows/desktop/com/dropeffect-constants">DROPEFFECT</a> enumeration. For a list of values, see <b>DROPEFFECT</b>.</param>
            <param name="pdwEffect">Pointer to a value that indicates how the OLE drag-and-drop operation affected the source data. The <i>pdwEffect</i> parameter is set only if the operation is not canceled.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>If you are developing an application that can act as a data source for an OLE drag-and-drop operation, you must call <b>DoDragDrop</b> when you detect that the user has started an OLE drag-and-drop operation.</para>
            <para>The <b>DoDragDrop</b> function enters a loop in which it calls various methods in the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-idropsource">IDropSource</a> and <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-idroptarget">IDropTarget</a> interfaces. (For a successful drag-and-drop operation, the application acting as the data source must also implement <b>IDropSource</b>, while the target application must implement <b>IDropTarget</b>.) </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-dodragdrop#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.OleDuplicateData(Windows.Win32.Foundation.HANDLE,Windows.Win32.System.Ole.CLIPBOARD_FORMAT,Windows.Win32.System.Memory.GLOBAL_ALLOC_FLAGS)">
            <summary>Duplicates the data found in the specified handle and returns a handle to the duplicated data. The source data is in a clipboard format. Use this function to help implement some of the data transfer interfaces such as IDataObject.</summary>
            <param name="hSrc">Handle of the source data.</param>
            <param name="cfFormat">Clipboard format of the source data.</param>
            <param name="uiFlags">Flags to be used to allocate global memory for the copied data. These flags are passed to GlobalAlloc. If the value of <i>uiFlags</i> is <b>NULL</b>, GMEM_MOVEABLE is used as a default flag.</param>
            <returns>On success the HANDLE to the source data is returned; on failure a  <b>NULL</b> value is returned.</returns>
            <remarks>The CF_METAFILEPICT, CF_PALETTE, or CF_BITMAP formats receive special handling. They are GDI handles and a new GDI object must be created instead of just copying the bytes. All other formats are duplicated byte-wise.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.OleFlushClipboard">
            <summary>Carries out the clipboard shutdown sequence. It also releases the IDataObject pointer that was placed on the clipboard by the OleSetClipboard function.</summary>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><b>OleFlushClipboard</b> renders the data from a data object onto the clipboard and releases the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> pointer to the data object. While the application that put the data object on the clipboard is running, the clipboard holds only a pointer to the data object, thus saving memory. If you are writing an application that acts as the source of a clipboard operation, you can call the <b>OleFlushClipboard</b> function when your application is closed, such as when the user exits from your application. Calling <b>OleFlushClipboard</b> enables pasting and paste-linking of OLE objects after application shutdown. Before calling <b>OleFlushClipboard</b>, you can easily determine if your data is still on the clipboard with a call to the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleiscurrentclipboard">OleIsCurrentClipboard</a> function. <b>OleFlushClipboard</b> leaves all formats offered by the data transfer object, including the OLE 1 compatibility formats, on the clipboard so they are available after application shutdown. In addition to OLE 1 compatibility formats, these include all formats offered on a global handle medium (all except for TYMED_FILE) and formatted with a <b>NULL</b> target device. For example, if a data-source application offers a particular clipboard format (say cfFOO) on an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> object, and calls the <b>OleFlushClipboard</b> function, the storage object is copied into memory and the hglobal memory handle is put on the clipboard. To retrieve the information on the clipboard, you can call the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-olegetclipboard">OleGetClipboard</a> function from another application, which creates a default data object, and the hglobal from the clipboard again becomes a storage object. Furthermore, the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> enumerator and the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-querygetdata">IDataObject::QueryGetData</a> method would all correctly indicate that the original clipboard format (cfFOO) is again available on a TYMED_ISTORAGE. To empty the clipboard, call the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-olesetclipboard">OleSetClipboard</a> function specifying a <b>NULL</b> value for its parameter. The application should call this when it closes if there is no need to leave data on the clipboard after shutdown, or if data will be placed on the clipboard using the standard Windows clipboard functions.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-oleflushclipboard#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.OleGetClipboard(Windows.Win32.System.Com.IDataObject**)">
            <summary>Retrieves a data object that you can use to access the contents of the clipboard.</summary>
            <param name="ppDataObj">Address of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> pointer variable that receives the interface pointer to the clipboard data object.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><div class="alert"><b>Caution</b>  Clipboard data is not trusted. Parse the data carefully before using it in your application.</div> <div> </div> If you are writing an application that can accept data from the clipboard, call the <b>OleGetClipboard</b> function to get a pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface that you can use to retrieve the contents of the clipboard. <b>OleGetClipboard</b> handles three cases:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-olegetclipboard#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.OleInitialize">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.OleInitialize(System.Void*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.OleInitialize(System.Void*)">
            <summary>Initializes the COM library on the current apartment, identifies the concurrency model as single-thread apartment (STA), and enables additional functionality described in the Remarks section below.</summary>
            <param name="pvReserved">This parameter is reserved and must be <b>NULL</b>.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>Applications that use the following functionality must call <b>OleInitialize</b> before calling any other function in the COM library:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-oleinitialize#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.OleSetClipboard(Windows.Win32.System.Com.IDataObject*)">
            <summary>Places a pointer to a specific data object onto the clipboard. This makes the data object accessible to the OleGetClipboard function.</summary>
            <param name="pDataObj">Pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface on the data object from which the data to be placed on the clipboard can be obtained. This parameter can be <b>NULL</b>; in which case the clipboard is emptied.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>If you are writing an application that can act as the source of a clipboard operation, you must do the following: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-olesetclipboard#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.OleUninitialize">
            <summary>Closes the COM library on the apartment, releases any class factories, other COM objects, or servers held by the apartment, disables RPC on the apartment, and frees any resources the apartment maintains.</summary>
            <remarks>
            <para>Call <b>OleUninitialize</b> on application shutdown, as the last COM library call, if the apartment was initialized with a call to <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleinitialize">OleInitialize</a>. <b>OleUninitialize</b> calls the <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize">CoUninitialize</a> function internally to shut down the OLE Component Object(COM) Library. If the COM library was initialized on the apartment with a call to <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-coinitialize">CoInitialize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a>, it must be closed with a call to <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize">CoUninitialize</a>. The <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleinitialize">OleInitialize</a> and <b>OleUninitialize</b> calls must be balanced. If there are multiple calls to the <b>OleInitialize</b> function, there must be the same number of calls to <b>OleUninitialize</b>; only the <b>OleUninitialize</b> call corresponding to the <b>OleInitialize</b> call that actually initialized the library can close it. Because there is no way to control the order in which in-process servers are loaded or unloaded, do not call <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleinitialize">OleInitialize</a> or <b>OleUninitialize</b> from the <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-oleuninitialize#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.PropVariantClear(Windows.Win32.System.Com.StructuredStorage.PROPVARIANT@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.PropVariantClear(Windows.Win32.System.Com.StructuredStorage.PROPVARIANT*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.PropVariantClear(Windows.Win32.System.Com.StructuredStorage.PROPVARIANT*)">
            <summary>Frees all elements that can be freed in a given PROPVARIANT structure.</summary>
            <param name="pvar">
            <para>A pointer to an initialized <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> structure for which any deallocatable elements are to be freed. On return, all zeroes are written to the <b>PROPVARIANT</b> structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>This function returns HRESULT.</returns>
            <remarks>
            <para>At any level of indirection, <b>NULL</b> pointers are ignored. For example, the <i>pvar</i> parameter  points to a <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> structure of type <b>VT_CF</b>. The  <b>pclipdata</b> member of the <b>PROPVARIANT</b> structure points to a <b>CLIPDATA</b> structure. The <i>pClipData</i> pointer in the <b>CLIPDATA</b> structure is  <b>NULL</b>.  In this example, the <i>pClipData</i> pointer is ignored.  However, the <b>CLIPDATA</b> structure pointed to by the <b>pclipdata</b> member of the <b>PROPVARIANT</b> structure is freed. On return, this function writes zeroes to the specified <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> structure, so the VT-type is <b>VT_EMPTY</b>. Passing <b>NULL</b> as the <i>pvar</i> parameter produces a return code of S_OK. <div class="alert"><b>Note</b>  Do not use this function to initialize <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> structures. Instead, initialize these structures using the <a href="https://docs.microsoft.com/windows/desktop/api/propidl/nf-propidl-propvariantinit">PropVariantInit</a> macro (defined in Propidl.h).</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.RegisterDragDrop(Windows.Win32.Foundation.HWND,Windows.Win32.System.Ole.IDropTarget*)">
            <summary>Registers the specified window as one that can be the target of an OLE drag-and-drop operation and specifies the IDropTarget instance to use for drop operations.</summary>
            <param name="hwnd">Handle to a window that can be a target for an OLE drag-and-drop operation.</param>
            <param name="pDropTarget">Pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-idroptarget">IDropTarget</a> interface on the object that is to be the target of a drag-and-drop operation in a specified window. This interface is used to communicate OLE drag-and-drop information for that window.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>If your application can accept dropped objects during OLE drag-and-drop operations, you must call the <b>RegisterDragDrop</b> function. Do this whenever one of your application windows is available as a potential drop target, i.e., when the window appears unobscured on the screen. The application thread that calls the <b>RegisterDragDrop</b> function must be pumping messages, presumably by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/fax/-mfax-faxaccountincomingarchive-getmessage-vb">GetMessage</a> function with a <b>NULL</b><i>hWnd</i> parameter, because OLE creates windows on the thread that need messages processed. If this requirement is not met, any application that drags an object over the window that is registered as a drop target will hang until the target application closes. The <b>RegisterDragDrop</b> function only registers one window at a time, so you must call it for each application window capable of accepting dropped objects. As the mouse passes over unobscured portions of the target window during an OLE drag-and-drop operation, the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> function calls the specified <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragover">IDropTarget::DragOver</a> method for the current window. When a drop operation actually occurs in a given window, the <b>DoDragDrop</b> function calls <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-drop">IDropTarget::Drop</a>. The <b>RegisterDragDrop</b> function also calls the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">IUnknown::AddRef</a> method on the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-idroptarget">IDropTarget</a> pointer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-registerdragdrop#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.ReleaseStgMedium(Windows.Win32.System.Com.STGMEDIUM@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.ReleaseStgMedium(Windows.Win32.System.Com.STGMEDIUM*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.ReleaseStgMedium(Windows.Win32.System.Com.STGMEDIUM*)">
            <summary>Frees the specified storage medium.</summary>
            <remarks>
            <para>The <b>ReleaseStgMedium</b> function calls the appropriate method or function to release the specified storage medium. Use this function during data transfer operations where storage medium structures are parameters, such as <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">IDataObject::GetData</a> or <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-setdata">IDataObject::SetData</a>. In addition to identifying the type of the storage medium, this structure specifies the appropriate <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> method for releasing the storage medium when it is no longer needed. It is common to pass a <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> from one body of code to another, such as in <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">IDataObject::GetData</a>, in which the one called can allocate a medium and return it to the caller. <b>ReleaseStgMedium</b> permits flexibility in whether the receiving body of code owns the medium, or whether the original provider of the medium still owns it, in which case the receiving code needs to inform the provider that it can free the medium. When the original provider of the medium is responsible for freeing the medium, the provider calls <b>ReleaseStgMedium</b>, specifying the medium and the appropriate <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> pointer as the <b>punkForRelease</b> structure member. Depending on the type of storage medium being freed, one of the following actions is taken, followed by a call to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> method on the specified <b>IUnknown</b> pointer. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-releasestgmedium#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.RevokeDragDrop(Windows.Win32.Foundation.HWND)">
            <summary>Revokes the registration of the specified application window as a potential target for OLE drag-and-drop operations.</summary>
            <param name="hwnd">Handle to a window previously registered as a target for an OLE drag-and-drop operation.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>When your application window is no longer available as a potential target for an OLE drag-and-drop operation, you must call <b>RevokeDragDrop</b>. This function calls the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> method for your drop target interface.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-revokedragdrop#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SysFreeString(Windows.Win32.Foundation.BSTR)">
            <summary>Deallocates a string allocated previously by SysAllocString, SysAllocStringByteLen, SysReAllocString, SysAllocStringLen, or SysReAllocStringLen.</summary>
            <param name="bstrString">The previously allocated string. If this parameter is <b>NULL</b>, the function simply returns.</param>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleauto/nf-oleauto-sysfreestring">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.LoadRegTypeLib(System.Guid@,System.UInt16,System.UInt16,System.UInt32,Windows.Win32.System.Com.ITypeLib**)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.LoadRegTypeLib(System.Guid*,System.UInt16,System.UInt16,System.UInt32,Windows.Win32.System.Com.ITypeLib**)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.LoadRegTypeLib(System.Guid*,System.UInt16,System.UInt16,System.UInt32,Windows.Win32.System.Com.ITypeLib**)">
            <summary>Uses registry information to load a type library.</summary>
            <param name="rguid">The GUID of the library.</param>
            <param name="wVerMajor">The major version of the library.</param>
            <param name="wVerMinor">The minor version of the library.</param>
            <param name="lcid">The national language code of the library.</param>
            <param name="pptlib">The loaded type library.</param>
            <returns>
            <para>This function can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The function <b>LoadRegTypeLib</b> defers to <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-loadtypelib">LoadTypeLib</a> to load the file.</para>
            <para><b>LoadRegTypeLib</b> compares the requested version numbers against those found in the system registry, and takes one of the following actions:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleauto/nf-oleauto-loadregtypelib#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.OleCreatePictureIndirect(Windows.Win32.System.Ole.PICTDESC@,System.Guid@,Windows.Win32.Foundation.BOOL,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.OleCreatePictureIndirect(Windows.Win32.System.Ole.PICTDESC*,System.Guid*,Windows.Win32.Foundation.BOOL,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.OleCreatePictureIndirect(Windows.Win32.System.Ole.PICTDESC*,System.Guid*,Windows.Win32.Foundation.BOOL,System.Void**)">
            <summary>Creates a new picture object initialized according to a PICTDESC structure.</summary>
            <param name="lpPictDesc">Pointer to a caller-allocated structure containing the initial state of the picture. The specified structure can be <b>NULL</b> to create an uninitialized object, in the event the picture needs to initialize via <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersiststream-load">IPersistStream::Load</a>.</param>
            <param name="riid">Reference to the identifier of the interface describing the type of interface pointer to return in <i>lplpvObj</i>.</param>
            <param name="fOwn">If <b>TRUE</b>, the picture object is to destroy its picture when the object is destroyed. If <b>FALSE</b>, the caller is responsible for destroying the picture.</param>
            <param name="lplpvObj">Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, this parameter contains the requested interface pointer on the newly created object. If the call is successful, the caller is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> through this interface pointer when the new object is no longer needed. If the call fails, the value is set to <b>NULL</b>.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>The <i>fOwn</i> parameter indicates whether the picture is to own the GDI picture handle for the picture it contains, so that the picture object will destroy its picture when the object itself is destroyed. The function returns an interface pointer to the new picture object specified by the caller in the <i>riid</i> parameter. A <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)">QueryInterface</a> is built into this call. The caller is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> through the interface pointer returned.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayCreate(Windows.Win32.System.Variant.VARENUM,System.UInt32,Windows.Win32.System.Com.SAFEARRAYBOUND@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SafeArrayCreate(Windows.Win32.System.Variant.VARENUM,System.UInt32,Windows.Win32.System.Com.SAFEARRAYBOUND*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayCreate(Windows.Win32.System.Variant.VARENUM,System.UInt32,Windows.Win32.System.Com.SAFEARRAYBOUND*)">
            <summary>Creates a new array descriptor, allocates and initializes the data for the array, and returns a pointer to the new array descriptor.</summary>
            <param name="vt">The base type of the array (the VARTYPE of each element of the array). The VARTYPE is restricted to a subset of the variant types. Neither the VT_ARRAY nor the VT_BYREF flag can be set. VT_EMPTY and VT_NULL are not valid base types for the array. All other types are legal.</param>
            <param name="cDims">The number of dimensions in the array. The number cannot be changed after the array is created.</param>
            <param name="rgsabound">A vector of bounds (one for each dimension) to allocate for the array.</param>
            <returns>A safe array descriptor, or null if the array could not be created.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleauto/nf-oleauto-safearraycreate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayCreateEx(Windows.Win32.System.Variant.VARENUM,System.UInt32,Windows.Win32.System.Com.SAFEARRAYBOUND@,System.Void*)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SafeArrayCreateEx(Windows.Win32.System.Variant.VARENUM,System.UInt32,Windows.Win32.System.Com.SAFEARRAYBOUND*,System.Void*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayCreateEx(Windows.Win32.System.Variant.VARENUM,System.UInt32,Windows.Win32.System.Com.SAFEARRAYBOUND*,System.Void*)">
            <summary>Creates and returns a safe array descriptor from the specified VARTYPE, number of dimensions and bounds.</summary>
            <param name="vt">The base type or the VARTYPE of each element of the array. The FADF_RECORD flag can be set for a variant type VT_RECORD, The FADF_HAVEIID flag can be set for VT_DISPATCH or VT_UNKNOWN, and FADF_HAVEVARTYPE can be set for all other VARTYPEs.</param>
            <param name="cDims">The number of dimensions in the array.</param>
            <param name="rgsabound">A vector of bounds (one for each dimension) to allocate for the array.</param>
            <param name="pvExtra">the type information of the user-defined type, if you are creating a safe array of user-defined types. If the vt parameter is VT_RECORD, then <i>pvExtra</i> will be a pointer to an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-irecordinfo">IRecordInfo</a> describing the record. If the <i>vt</i> parameter is VT_DISPATCH or VT_UNKNOWN, then <i>pvExtra</i> will contain a pointer to a GUID representing the type of interface being passed to the array.</param>
            <returns>A safe array descriptor, or null if the array could not be created.</returns>
            <remarks>If the VARTYPE is VT_RECORD then <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearraysetrecordinfo">SafeArraySetRecordInfo</a> is called. If the VARTYPE is VT_DISPATCH or VT_UNKNOWN then the elements of the array must contain interfaces of the same type. Part of the process of marshaling this array to other processes does include generating the proxy/stub code of the IID pointed to by the <i>pvExtra</i> parameter. To actually pass heterogeneous interfaces one will need to specify either IID_IUnknown or IID_IDispatch in <i>pvExtra</i> and provide some other means for the caller to identify how to query for the actual interface.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayDestroy(Windows.Win32.System.Com.SAFEARRAY*)">
            <summary>Destroys an existing array descriptor and all of the data in the array.</summary>
            <param name="psa">An array descriptor created by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearraycreate">SafeArrayCreate</a>.</param>
            <returns>
            <para>This function can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>Safe arrays of variant will have the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-variantclear">VariantClear</a> function called on each member and safe arrays of BSTR will have the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-sysfreestring">SysFreeString</a> function called on each element. <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-irecordinfo-recordclear">IRecordInfo::RecordClear</a> will be called to release object references and other values of a record without deallocating the record.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayGetElement(Windows.Win32.System.Com.SAFEARRAY*,System.Int32@,System.Void*)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SafeArrayGetElement(Windows.Win32.System.Com.SAFEARRAY*,System.Int32*,System.Void*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayGetElement(Windows.Win32.System.Com.SAFEARRAY*,System.Int32*,System.Void*)">
            <summary>Retrieves a single element of the array.</summary>
            <param name="psa">An array descriptor created by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearraycreate">SafeArrayCreate</a>.</param>
            <param name="rgIndices">A vector of indexes for each dimension of the array. The right-most (least significant) dimension is rgIndices[0]. The left-most dimension is stored at <c>rgIndices[psa-&gt;cDims – 1]</c>.</param>
            <param name="pv">The element of the array.</param>
            <returns>
            <para>This function can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>This function calls <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearraylock">SafeArrayLock</a> and <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearrayunlock">SafeArrayUnlock</a> automatically, before and after retrieving the element. The caller must provide a storage area of the correct size to receive the data. If the data element is a string, object, or variant, the function copies the element in the correct way.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayGetRecordInfo(Windows.Win32.System.Com.SAFEARRAY*,Windows.Win32.System.Ole.IRecordInfo**)">
            <summary>Retrieves the IRecordInfo interface of the UDT contained in the specified safe array.</summary>
            <param name="psa">An array descriptor created by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearraycreate">SafeArrayCreate</a>.</param>
            <param name="prinfo">The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-irecordinfo">IRecordInfo</a> interface.</param>
            <returns>
            <para>This function can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleauto/nf-oleauto-safearraygetrecordinfo">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayGetVartype(Windows.Win32.System.Com.SAFEARRAY*,Windows.Win32.System.Variant.VARENUM@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SafeArrayGetVartype(Windows.Win32.System.Com.SAFEARRAY*,Windows.Win32.System.Variant.VARENUM*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayGetVartype(Windows.Win32.System.Com.SAFEARRAY*,Windows.Win32.System.Variant.VARENUM*)">
            <summary>Gets the VARTYPE stored in the specified safe array.</summary>
            <param name="psa">An array descriptor created by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearraycreate">SafeArrayCreate</a>.</param>
            <param name="pvt">The VARTYPE.</param>
            <returns>
            <para>This function can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>If FADF_HAVEVARTYPE is set, <b>SafeArrayGetVartype</b> returns the VARTYPE stored in the array descriptor. If FADF_RECORD is set, it returns VT_RECORD; if FADF_DISPATCH is set, it returns VT_DISPATCH; and if FADF_UNKNOWN is set, it returns VT_UNKNOWN. <b>SafeArrayGetVartype</b> can fail to return VT_UNKNOWN for SAFEARRAY types that are based on <b>IUnknown</b>. Callers should additionally check whether the SAFEARRAY type's <b>fFeatures</b> field has the FADF_UNKNOWN flag set.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleauto/nf-oleauto-safearraygetvartype#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayLock(Windows.Win32.System.Com.SAFEARRAY*)">
            <summary>Increments the lock count of an array, and places a pointer to the array data in pvData of the array descriptor.</summary>
            <param name="psa">An array descriptor created by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearraycreate">SafeArrayCreate</a>.</param>
            <returns>
            <para>This function can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The pointer in the array descriptor is valid until the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearrayunlock">SafeArrayUnlock</a> function is called. Calls to <b>SafeArrayLock</b> can be nested, in which case an equal number of calls to <b>SafeArrayUnlock</b> are required. An array cannot be deleted while it is locked.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleauto/nf-oleauto-safearraylock#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayPutElement(Windows.Win32.System.Com.SAFEARRAY*,System.Int32@,System.Void*)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.SafeArrayPutElement(Windows.Win32.System.Com.SAFEARRAY*,System.Int32*,System.Void*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayPutElement(Windows.Win32.System.Com.SAFEARRAY*,System.Int32*,System.Void*)">
            <summary>Stores the data element at the specified location in the array.</summary>
            <param name="psa">An array descriptor created by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearraycreate">SafeArrayCreate</a>.</param>
            <param name="rgIndices">A vector of indexes for each dimension of the array. The right-most (least significant) dimension is rgIndices[0]. The left-most dimension is stored at <c>rgIndices[psa-&gt;cDims – 1]</c>.</param>
            <param name="pv">The data to assign to the array. The variant types VT_DISPATCH, VT_UNKNOWN, and VT_BSTR are pointers, and do not require another level of indirection.</param>
            <returns>
            <para>This function can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>This function automatically calls <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearraylock">SafeArrayLock</a> and <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearrayunlock">SafeArrayUnlock</a> before and after assigning the element. If the data element is a string, object, or variant, the function copies it correctly when the safe array is destroyed. If the existing element is a string, object, or variant, it is cleared correctly.  If the data element is a VT_DISPATCH or VT_UNKNOWN, <b>AddRef</b> is called to increment the object's reference count. <div class="alert"><b>Note</b>  Multiple locks can be on an array. Elements can be put into an array while the array is locked by other operations.</div> <div> </div> For an example that demonstrates calling <b>SafeArrayPutElement</b>, see the COM Fundamentals Lines sample (CLines::Add in Lines.cpp).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleauto/nf-oleauto-safearrayputelement#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SafeArrayUnlock(Windows.Win32.System.Com.SAFEARRAY*)">
            <summary>Decrements the lock count of an array so it can be freed or resized.</summary>
            <param name="psa">An array descriptor created by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-safearraycreate">SafeArrayCreate</a>.</param>
            <returns>
            <para>This function can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>This function is called after access to the data in an array is finished.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DragAcceptFiles(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.BOOL)">
            <summary>Registers whether a window accepts dropped files.</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> The identifier of the window that is registering whether it will accept dropped files.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragacceptfiles#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="fAccept">
            <para>Type: <b>BOOL</b> A value that indicates if the window identified by the <i>hWnd</i> parameter accepts dropped files. This value is <b>TRUE</b> to accept dropped files or <b>FALSE</b> to discontinue accepting dropped files.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragacceptfiles#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <remarks>An application that calls <b>DragAcceptFiles</b> with the <i>fAccept</i> parameter set to <b>TRUE</b> has identified itself as able to process the <a href="https://docs.microsoft.com/windows/desktop/shell/wm-dropfiles">WM_DROPFILES</a> message from File Manager.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DragQueryFile(Windows.Win32.UI.Shell.HDROP,System.UInt32,Windows.Win32.Foundation.PWSTR,System.UInt32)">
            <summary>Retrieves the names of dropped files that result from a successful drag-and-drop operation. (Unicode)</summary>
            <param name="hDrop">
            <para>Type: <b>HDROP</b> Identifier of the structure that contains the file names of the dropped files.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragqueryfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="iFile">
            <para>Type: <b>UINT</b> Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragqueryfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpszFile">
            <para>Type: <b>LPTSTR</b> The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragqueryfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="cch">
            <para>Type: <b>UINT</b> The size, in characters, of the <i>lpszFile</i> buffer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragqueryfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>UINT</b> A nonzero value indicates a successful call. When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character. If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF. If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.</para>
            </returns>
            <remarks>
            <para>> [!NOTE] > The shellapi.h header defines DragQueryFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragqueryfilew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.BeginPaint(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.PAINTSTRUCT@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.BeginPaint(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.PAINTSTRUCT*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.BeginPaint(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.PAINTSTRUCT*)">
            <summary>The BeginPaint function prepares the specified window for painting and fills a PAINTSTRUCT structure with information about the painting.</summary>
            <param name="hWnd">Handle to the window to be repainted.</param>
            <param name="lpPaint">Pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-paintstruct">PAINTSTRUCT</a> structure that will receive painting information.</param>
            <returns>
            <para>If the function succeeds, the return value is the handle to a display device context for the specified window. If the function fails, the return value is <b>NULL</b>, indicating that no display device context is available.</para>
            </returns>
            <remarks>
            <para>The <b>BeginPaint</b> function automatically sets the clipping region of the device context to exclude any area outside the update region. The update region is set by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-invalidaterect">InvalidateRect</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-invalidatergn">InvalidateRgn</a> function and by the system after sizing, moving, creating, scrolling, or any other operation that affects the client area. If the update region is marked for erasing, <b>BeginPaint</b> sends a <b>WM_ERASEBKGND</b> message to the window. An application should not call <b>BeginPaint</b> except in response to a <b>WM_PAINT</b> message. Each call to <b>BeginPaint</b> must have a corresponding call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-endpaint">EndPaint</a> function. If the caret is in the area to be painted, <b>BeginPaint</b> automatically hides the caret to prevent it from being erased. If the window's class has a background brush, <b>BeginPaint</b> uses that brush to erase the background of the update region before returning. <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3> This API does not participate in DPI virtualization. The output returned is always in terms of physical pixels.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-beginpaint#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CallWindowProc(,Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)">
            <summary>Passes message information to the specified window procedure. (Unicode)</summary>
            <param name="lpPrevWndFunc">
            <para>Type: <b>WNDPROC</b> The previous window procedure. If this value is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowlonga">GetWindowLong</a> function with the <i>nIndex</i> parameter set to <b>GWL_WNDPROC</b> or <b>DWL_DLGPROC</b>, it is actually either the address of a window or dialog box procedure, or a special internal value meaningful only to <b>CallWindowProc</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window procedure to receive the message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Msg">
            <para>Type: <b>UINT</b> The message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wParam">
            <para>Type: <b>WPARAM</b> Additional message-specific information. The contents of this parameter depend on the value of the <i>Msg</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> Additional message-specific information. The contents of this parameter depend on the value of the <i>Msg</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>LRESULT</b> The return value specifies the result of the message processing and depends on the message sent.</para>
            </returns>
            <remarks>
            <para>Use the <b>CallWindowProc</b> function for window subclassing. Usually, all windows with the same class share one window procedure. A subclass is a window or set of windows with the same class whose messages are intercepted and processed by another window procedure (or procedures) before being passed to the window procedure of the class. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> function creates the subclass by changing the window procedure associated with a particular window, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling <b>CallWindowProc</b>. This allows the application to create a chain of window procedures. If <b>STRICT</b> is defined, the <i>lpPrevWndFunc</i> parameter has the data type <b>WNDPROC</b>. The <b>WNDPROC</b> type is declared as follows:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callwindowprocw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.CopyImage(Windows.Win32.Foundation.HANDLE,Windows.Win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.IMAGE_FLAGS)">
            <summary>Creates a new image (icon, cursor, or bitmap) and copies the attributes of the specified image to the new one. If necessary, the function stretches the bits to fit the desired size of the new image.</summary>
            <param name="h">
            <para>Type: <b>HANDLE</b> A handle to the image to be copied.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-copyimage#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="type">Type: <b>UINT</b></param>
            <param name="cx">
            <para>Type: <b>int</b> The desired width, in pixels, of the image. If this is zero, then the returned image will have the same width as the original <i>hImage</i>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-copyimage#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="cy">
            <para>Type: <b>int</b> The desired height, in pixels, of the image. If this is zero, then the returned image will have the same height as the original <i>hImage</i>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-copyimage#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="flags">Type: <b>UINT</b></param>
            <returns>
            <para>Type: <b>HANDLE</b> If the function succeeds, the return value is the handle to the newly created image. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>When you are finished using the resource, you can release its associated memory by calling one of the functions in the following table. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-copyimage#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DefWindowProc(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)">
            <summary>Calls the default window procedure to provide default processing for any window messages that an application does not process. (Unicode)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window procedure that received the message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Msg">
            <para>Type: <b>UINT</b> The message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wParam">
            <para>Type: <b>WPARAM</b> Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>LRESULT</b> The return value is the result of the message processing and depends on the message.</para>
            </returns>
            <remarks>
            <para>> [!NOTE] > The winuser.h header defines DefWindowProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DestroyIcon(Windows.Win32.UI.WindowsAndMessaging.HICON)">
            <summary>Destroys an icon and frees any memory the icon occupied.</summary>
            <param name="hIcon">
            <para>Type: <b>HICON</b> A handle to the icon to be destroyed. The icon must not be in use.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>It is only necessary to call <b>DestroyIcon</b> for icons and cursors created with the following functions: <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a> (if called without the <b>LR_SHARED</b> flag), <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copyicon">CopyIcon</a>. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DrawIconEx(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.HICON,System.Int32,System.Int32,System.UInt32,Windows.Win32.Graphics.Gdi.HBRUSH,Windows.Win32.UI.WindowsAndMessaging.DI_FLAGS)">
            <summary>Draws an icon or cursor into the specified device context, performing the specified raster operations, and stretching or compressing the icon or cursor as specified.</summary>
            <param name="hdc">
            <para>Type: <b>HDC</b> A handle to the device context into which the icon or cursor will be drawn.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="xLeft">
            <para>Type: <b>int</b> The logical x-coordinate of the upper-left corner of the icon or cursor.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="yTop">
            <para>Type: <b>int</b> The logical y-coordinate of the upper-left corner of the icon or cursor.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hIcon">
            <para>Type: <b>HICON</b> A handle to the icon or cursor to be drawn. This parameter can identify an animated cursor.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="cxWidth">
            <para>Type: <b>int</b> The logical width of the icon or cursor. If this parameter is zero and the <i>diFlags</i> parameter is <b>DI_DEFAULTSIZE</b>, the function uses the <b>SM_CXICON</b> system metric value to set the width. If this parameter is zero and <b>DI_DEFAULTSIZE</b> is not used, the function uses the actual resource width.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="cyWidth">
            <para>Type: <b>int</b> The logical height of the icon or cursor. If this parameter is zero and the <i>diFlags</i> parameter is <b>DI_DEFAULTSIZE</b>, the function uses the <b>SM_CYICON</b> system metric value to set the width. If this parameter is zero and <b>DI_DEFAULTSIZE</b> is not used, the function uses the actual resource height.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="istepIfAniCur">
            <para>Type: <b>UINT</b> The index of the frame to draw, if <i>hIcon</i> identifies an animated cursor. This parameter is ignored if <i>hIcon</i> does not identify an animated cursor.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hbrFlickerFreeDraw">
            <para>Type: <b>HBRUSH</b> A handle to a brush that the system uses for flicker-free drawing. If <i>hbrFlickerFreeDraw</i> is a valid brush handle, the system creates an offscreen bitmap using the specified brush for the background color, draws the icon or cursor into the bitmap, and then copies the bitmap into the device context identified by <i>hdc</i>. If <i>hbrFlickerFreeDraw</i> is <b>NULL</b>, the system draws the icon or cursor directly into the device context.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="diFlags">Type: <b>UINT</b></param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The <b>DrawIconEx</b> function places the icon's upper-left corner at the location specified by the <i>xLeft</i> and <i>yTop</i> parameters. The location is subject to the current mapping mode of the device context. If only one of the <b>DI_IMAGE</b> and <b>DI_MASK</b> flags is set, then the corresponding bitmap is drawn with the <b>SRCCOPY</b> <a href="https://docs.microsoft.com/windows/win32/api/wingdi/nf-wingdi-bitblt">raster operation code</a>. If both the <b>DI_IMAGE</b> and <b>DI_MASK</b> flags are set: * If the icon or cursor is a 32-bit alpha-blended icon or cursor, then the image is drawn with <b>AC_SRC_OVER</b> <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-blendfunction">blend function</a> and the mask is ignored. * For all other icons or cursors, the mask is drawn with the <b>SRCAND</b> <a href="https://docs.microsoft.com/windows/win32/api/wingdi/nf-wingdi-bitblt">raster operation code</a>, and the image is drawn with the <b>SRCINVERT</b> <a href="https://docs.microsoft.com/windows/win32/api/wingdi/nf-wingdi-bitblt">raster operation code</a> To duplicate <c>DrawIcon (hDC, X, Y, hIcon)</c>, call <b>DrawIconEx</b> as follows: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.EndPaint(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.PAINTSTRUCT@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.EndPaint(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.PAINTSTRUCT*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.EndPaint(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.PAINTSTRUCT*)">
            <summary>The EndPaint function marks the end of painting in the specified window. This function is required for each call to the BeginPaint function, but only after painting is complete.</summary>
            <param name="hWnd">Handle to the window that has been repainted.</param>
            <param name="lpPaint">Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-paintstruct">PAINTSTRUCT</a> structure that contains the painting information retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-beginpaint">BeginPaint</a>.</param>
            <returns>The return value is always nonzero.</returns>
            <remarks>
            <para>If the caret was hidden by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-beginpaint">BeginPaint</a>, <b>EndPaint</b> restores the caret to the screen. <b>EndPaint</b> releases the display device context that <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-beginpaint">BeginPaint</a> retrieved.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-endpaint#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.EnumChildWindows(Windows.Win32.Foundation.HWND,,Windows.Win32.Foundation.LPARAM)">
            <summary>Enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to an application-defined callback function.</summary>
            <param name="hWndParent">
            <para>Type: <b>HWND</b> A handle to the parent window whose child windows are to be enumerated. If this parameter is <b>NULL</b>, this function is equivalent to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumwindows">EnumWindows</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumchildwindows#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpEnumFunc">
            <para>Type: <b>WNDENUMPROC</b> A pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633493(v=vs.85)">EnumChildProc</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumchildwindows#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> An application-defined value to be passed to the callback function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumchildwindows#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> The return value is not used.</para>
            </returns>
            <remarks>
            <para>If a child window has created child windows of its own, <b>EnumChildWindows</b> enumerates those windows as well. A child window that is moved or repositioned in the Z order during the enumeration process will be properly enumerated. The function does not enumerate a child window that is destroyed before being enumerated or that is created during the enumeration process.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumchildwindows#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.EnumDisplayMonitors(Windows.Win32.Graphics.Gdi.HDC,System.Nullable{Windows.Win32.Foundation.RECT},,Windows.Win32.Foundation.LPARAM)">
            <inheritdoc cref="!:EnumDisplayMonitors(winmdroot.Graphics.Gdi.HDC, winmdroot.Foundation.RECT*, delegate *unmanaged[Stdcall]&lt;global::Windows.Win32.Graphics.Gdi.HMONITOR,global::Windows.Win32.Graphics.Gdi.HDC,global::Windows.Win32.Foundation.RECT*,global::Windows.Win32.Foundation.LPARAM,global::Windows.Win32.Foundation.BOOL&gt;, winmdroot.Foundation.LPARAM)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.EnumDisplayMonitors(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Foundation.RECT*,,Windows.Win32.Foundation.LPARAM)">
            <summary>The EnumDisplayMonitors function enumerates display monitors (including invisible pseudo-monitors associated with the mirroring drivers) that intersect a region formed by the intersection of a specified clipping rectangle and the visible region of a device context. EnumDisplayMonitors calls an application-defined MonitorEnumProc callback function once for each monitor that is enumerated. Note that GetSystemMetrics (SM_CMONITORS) counts only the display monitors.</summary>
            <param name="hdc">
            <para>A handle to a display device context that defines the visible region of interest. If this parameter is <b>NULL</b>, the <i>hdcMonitor</i> parameter passed to the callback function will be <b>NULL</b>, and the visible region of interest is the virtual screen that encompasses all the displays on the desktop.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumdisplaymonitors#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lprcClip">
            <para>A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies a clipping rectangle. The region of interest is the intersection of the clipping rectangle with the visible region specified by <i>hdc</i>. If <i>hdc</i> is non-<b>NULL</b>, the coordinates of the clipping rectangle are relative to the origin of the <i>hdc</i>. If <i>hdc</i> is <b>NULL</b>, the coordinates are virtual-screen coordinates. This parameter can be <b>NULL</b> if you don't want to clip the region specified by <i>hdc</i>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumdisplaymonitors#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpfnEnum">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-monitorenumproc">MonitorEnumProc</a> application-defined callback function.</param>
            <param name="dwData">Application-defined data that <b>EnumDisplayMonitors</b> passes directly to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-monitorenumproc">MonitorEnumProc</a> function.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>There are two reasons to call the <b>EnumDisplayMonitors</b> function: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumdisplaymonitors#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.EnumThreadWindows(System.UInt32,,Windows.Win32.Foundation.LPARAM)">
            <summary>Enumerates all nonchild windows associated with a thread by passing the handle to each window, in turn, to an application-defined callback function.</summary>
            <param name="dwThreadId">
            <para>Type: <b>DWORD</b> The identifier of the thread whose windows are to be enumerated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumthreadwindows#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpfn">
            <para>Type: <b>WNDENUMPROC</b> A pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633496(v=vs.85)">EnumThreadWndProc</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumthreadwindows#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> An application-defined value to be passed to the callback function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumthreadwindows#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the callback function returns <b>TRUE</b> for all windows in the thread specified by <i>dwThreadId</i>, the return value is <b>TRUE</b>. If the callback function returns <b>FALSE</b> on any enumerated window, or if there are no windows found in the thread specified by <i>dwThreadId</i>, the return value is <b>FALSE</b>.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumthreadwindows">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.EnumWindows(,Windows.Win32.Foundation.LPARAM)">
            <summary>Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE.</summary>
            <param name="lpEnumFunc">
            <para>Type: <b>WNDENUMPROC</b> A pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633498(v=vs.85)">EnumWindowsProc</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumwindows#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> An application-defined value to be passed to the callback function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumwindows#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633498(v=vs.85)">EnumWindowsProc</a> returns zero, the return value is also zero. In this case, the callback function should call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> to obtain a meaningful error code to be returned to the caller of <b>EnumWindows</b>.</para>
            </returns>
            <remarks>
            <para>The <b>EnumWindows</b> function does not enumerate child windows, with the exception of a few top-level windows owned by the system that have the <b>WS_CHILD</b> style. This function is more reliable than calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindow">GetWindow</a> function in a loop. An application that calls <b>GetWindow</b> to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed. <div class="alert"><b>Note</b>  For Windows 8 and later, <b>EnumWindows</b> enumerates only top-level windows of desktop apps.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumwindows#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetClientRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetClientRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetClientRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT*)">
            <summary>Retrieves the coordinates of a window's client area.</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window whose client coordinates are to be retrieved.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclientrect#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpRect">
            <para>Type: <b>LPRECT</b> A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the client coordinates. The <b>left</b> and <b>top</b> members are zero. The <b>right</b> and <b>bottom</b> members contain the width and height of the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclientrect#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>In conformance with conventions for the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure, the bottom-right coordinates of the returned rectangle are exclusive. In other words, the pixel at (<b>right</b>, <b>bottom</b>) lies immediately outside the rectangle.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetClipboardFormatName(System.UInt32,Windows.Win32.Foundation.PWSTR,System.Int32)">
            <summary>Retrieves from the clipboard the name of the specified registered format. The function copies the name to the specified buffer. (Unicode)</summary>
            <param name="format">
            <para>Type: <b>UINT</b> The type of format to be retrieved. This parameter must not specify any of the predefined clipboard formats.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpszFormatName">
            <para>Type: <b>LPTSTR</b> The buffer that is to receive the format name.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="cchMaxCount">
            <para>Type: <b>int</b> The maximum length, in characters, of the string to be copied to the buffer. If the name exceeds this limit, it is truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>int</b> If the function succeeds, the return value is the length, in characters, of the string copied to the buffer. If the function fails, the return value is zero, indicating that the requested format does not exist or is predefined. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><h3><a id="Security_Considerations"></a><a id="security_considerations"></a><a id="SECURITY_CONSIDERATIONS"></a>Security Considerations</h3> Using this function incorrectly might compromise the security of your program. For example, miscalculating the proper size of the <i>lpszFormatName</i> buffer, especially when the application is used in both ANSI and Unicode versions, can cause a buffer overflow. Also, note that the string is truncated if it is longer than the <i>cchMaxCount</i> parameter, which can lead to loss of information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetDC(Windows.Win32.Foundation.HWND)">
            <summary>The GetDC function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen.</summary>
            <param name="hWnd">A handle to the window whose DC is to be retrieved. If this value is <b>NULL</b>, <b>GetDC</b> retrieves the DC for the entire screen.</param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the DC for the specified window's client area. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>The <b>GetDC</b> function retrieves a common, class, or private DC depending on the class style of the specified window. For class and private DCs, <b>GetDC</b> leaves the previously assigned attributes unchanged. However, for common DCs, <b>GetDC</b> assigns default attributes to the DC each time it is retrieved. For example, the default font is System, which is a bitmap font. Because of this, the handle to a common DC returned by <b>GetDC</b> does not tell you what font, color, or brush was used when the window was drawn. To determine the font, call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-gettextfacea">GetTextFace</a>. Note that the handle to the DC can only be used by a single thread at any one time. After painting with a common DC, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-releasedc">ReleaseDC</a> function must be called to release the DC. Class and private DCs do not have to be released. <b>ReleaseDC</b> must be called from the same thread that called <b>GetDC</b>. The number of DCs is limited only by available memory.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetDCEx(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.HRGN,Windows.Win32.Graphics.Gdi.GET_DCX_FLAGS)">
            <summary>The GetDCEx function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen.</summary>
            <param name="hWnd">A handle to the window whose DC is to be retrieved. If this value is <b>NULL</b>, <b>GetDCEx</b> retrieves the DC for the entire screen.</param>
            <param name="hrgnClip">A clipping region that may be combined with the visible region of the DC. If the value of <i>flags</i> is DCX_INTERSECTRGN or DCX_EXCLUDERGN, then the operating system assumes ownership of the region and will automatically delete it when it is no longer needed. In this case, the application should not use or delete the region after a successful call to <b>GetDCEx</b>.</param>
            <param name="flags"></param>
            <returns>
            <para>If the function succeeds, the return value is the handle to the DC for the specified window. If the function fails, the return value is <b>NULL</b>. An invalid value for the <i>hWnd</i> parameter will cause the function to fail.</para>
            </returns>
            <remarks>
            <para>Unless the display DC belongs to a window class, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-releasedc">ReleaseDC</a> function must be called to release the DC after painting. Also, <b>ReleaseDC</b> must be called from the same thread that called <b>GetDCEx</b>. The number of DCs is limited only by available memory. The function returns a handle to a DC that belongs to the window's class if CS_CLASSDC, CS_OWNDC or CS_PARENTDC was specified as a style in the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure when the class was registered.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdcex#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetDesktopWindow">
            <summary>Retrieves a handle to the desktop window. The desktop window covers the entire screen. The desktop window is the area on top of which other windows are painted.</summary>
            <returns>
            <para>Type: <b>HWND</b> The return value is a handle to the desktop window.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdesktopwindow">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetForegroundWindow">
            <summary>Retrieves a handle to the foreground window (the window with which the user is currently working). The system assigns a slightly higher priority to the thread that creates the foreground window than it does to other threads.</summary>
            <returns>
            <para>Type: <b>HWND</b> The return value is a handle to the foreground window. The foreground window can be <b>NULL</b> in certain circumstances, such as when a window is losing activation.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getforegroundwindow">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetGuiResources(Windows.Win32.Foundation.HANDLE,Windows.Win32.System.Threading.GET_GUI_RESOURCES_FLAGS)">
            <summary>Retrieves the count of handles to graphical user interface (GUI) objects in use by the specified process.</summary>
            <param name="hProcess">
            <para>A handle to the process. The handle must refer to a process in the current session, and must have the **PROCESS_QUERY_LIMITED_INFORMATION** access right (see [Process security and access rights](/windows/win32/procthread/process-security-and-access-rights)). If this parameter is the special value **GR_GLOBAL**, then the resource usage is reported across all processes in the current session. **Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP:** The **GR_GLOBAL** value is not supported until Windows 7 and Windows Server 2008 R2. **Windows Server 2003 and Windows XP:** The handle must have the **PROCESS_QUERY_INFORMATION** access right.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getguiresources#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="uiFlags"></param>
            <returns>
            <para>If the function succeeds, the return value is the count of handles to GUI objects in use by the process. If no GUI objects are in use, the return value is zero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>A process without a graphical user interface does not use GUI resources, therefore, <b>GetGuiResources</b> will return zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getguiresources#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetIconInfo(Windows.Win32.UI.WindowsAndMessaging.HICON,Windows.Win32.UI.WindowsAndMessaging.ICONINFO@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetIconInfo(Windows.Win32.UI.WindowsAndMessaging.HICON,Windows.Win32.UI.WindowsAndMessaging.ICONINFO*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetIconInfo(Windows.Win32.UI.WindowsAndMessaging.HICON,Windows.Win32.UI.WindowsAndMessaging.ICONINFO*)">
            <summary>Retrieves information about the specified icon or cursor.</summary>
            <param name="hIcon">Type: <b>HICON</b></param>
            <param name="piconinfo">
            <para>Type: <b>PICONINFO</b> A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a> structure. The function fills in the structure's members.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfo#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero and the function fills in the members of the specified <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a> structure. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><b>GetIconInfo</b> creates bitmaps for the <b>hbmMask</b> and <b>hbmColor</b> or members of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a>. The calling application must manage these bitmaps and delete them when they are no longer necessary. <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3> This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfo#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetMonitorInfo(Windows.Win32.Graphics.Gdi.HMONITOR,Windows.Win32.Graphics.Gdi.MONITORINFO@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetMonitorInfo(Windows.Win32.Graphics.Gdi.HMONITOR,Windows.Win32.Graphics.Gdi.MONITORINFO*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetMonitorInfo(Windows.Win32.Graphics.Gdi.HMONITOR,Windows.Win32.Graphics.Gdi.MONITORINFO*)">
            <summary>The GetMonitorInfo function retrieves information about a display monitor. (Unicode)</summary>
            <param name="hMonitor">A handle to the display monitor of interest.</param>
            <param name="lpmi">
            <para>A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfo">MONITORINFO</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfoexa">MONITORINFOEX</a> structure that receives information about the specified display monitor. You must set the <b>cbSize</b> member of the structure to sizeof(MONITORINFO) or sizeof(MONITORINFOEX) before calling the <b>GetMonitorInfo</b> function. Doing so lets the function determine the type of structure you are passing to it. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfoexa">MONITORINFOEX</a> structure is a superset of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfo">MONITORINFO</a> structure. It has one additional member: a string that contains a name for the display monitor. Most applications have no use for a display monitor name, and so can save some bytes by using a <b>MONITORINFO</b> structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmonitorinfow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>> [!NOTE] > The winuser.h header defines GetMonitorInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmonitorinfow#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Windows.Win32.PInvokeCore.GetSysColor(Windows.Win32.Graphics.Gdi.SYS_COLOR_INDEX)" -->
        <member name="M:Windows.Win32.PInvokeCore.GetSysColorBrush(Windows.Win32.Graphics.Gdi.SYS_COLOR_INDEX)">
            <summary>The GetSysColorBrush function retrieves a handle identifying a logical brush that corresponds to the specified color index.</summary>
            <param name="nIndex">A color index. This value corresponds to the color used to paint one of the window elements. See <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsyscolor">GetSysColor</a> for system color index values.</param>
            <returns>The return value identifies a logical brush if the <i>nIndex</i> parameter is supported by the current platform. Otherwise, it returns <b>NULL</b>.</returns>
            <remarks>
            <para>A brush is a bitmap that the system uses to paint the interiors of filled shapes. An application can retrieve the current system colors by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsyscolor">GetSysColor</a> function. An application can set the current system colors by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setsyscolors">SetSysColors</a> function. An application must not register a window class for a window using a system brush. To register a window class with a system color, see the documentation of the <b>hbrBackground</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structures. System color brushes track changes in system colors. In other words, when the user changes a system color, the associated system color brush automatically changes to the new color. To paint with a system color brush, an application should use <b>GetSysColorBrush</b> (nIndex) instead of <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush">CreateSolidBrush</a> ( <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsyscolor">GetSysColor</a> (nIndex)), because <b>GetSysColorBrush</b> returns a cached brush instead of allocating a new one. System color brushes are owned by the system so you don't need to destroy them. Although you don't need to delete the logical brush that <b>GetSysColorBrush</b> returns, no harm occurs by calling <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getsyscolorbrush#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetSystemMetrics(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_METRICS_INDEX)">
            <summary>Retrieves the specified system metric or system configuration setting.</summary>
            <param name="nIndex">Type: <b>int</b></param>
            <returns>
            <para>Type: <b>int</b> If the function succeeds, the return value is the requested system metric or configuration setting. If the function fails, the return value is 0. <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not provide extended error information.</para>
            </returns>
            <remarks>
            <para>System metrics can vary from display to display. <b>GetSystemMetrics</b>(SM_CMONITORS) counts only visible display monitors. This is different from <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumdisplaymonitors">EnumDisplayMonitors</a>, which enumerates both visible display monitors and invisible  pseudo-monitors that are associated with mirroring drivers. An invisible pseudo-monitor is associated with a pseudo-device used to mirror application drawing for remoting or other purposes. The SM_ARRANGE setting specifies how the system arranges minimized windows, and consists of a starting position and a direction. The starting position can be one of the following values.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getsystemmetrics#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetWindowRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT@)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.GetWindowRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT*)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetWindowRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT*)">
            <summary>Retrieves the dimensions of the bounding rectangle of the specified window. The dimensions are given in screen coordinates that are relative to the upper-left corner of the screen.</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowrect#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpRect">
            <para>Type: <b>LPRECT</b> A pointer to a  <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the screen coordinates of the upper-left and lower-right corners of the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowrect#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>In conformance with conventions for the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure, the bottom-right coordinates of the returned rectangle are exclusive. In other words, the pixel at (<b>right</b>, <b>bottom</b>) lies immediately outside the rectangle. GetWindowRect is virtualized for DPI. In Windows Vista and later, the Window Rect now includes the area occupied by the drop shadow. Calling GetWindowRect will have different behavior depending on whether the window has ever been shown or not.  If the window has not been shown before, GetWindowRect will not include the area of the drop shadow. To get the window bounds excluding the drop shadow, use <a href="https://docs.microsoft.com/windows/win32/api/dwmapi/nf-dwmapi-dwmgetwindowattribute">DwmGetWindowAttribute</a>, specifying <b>DWMWA_EXTENDED_FRAME_BOUNDS</b>.  Note that unlike the Window Rect, the DWM Extended Frame Bounds are not adjusted for DPI.  Getting the extended frame bounds can only be done after the window has been shown at least once.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowrect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetWindowText(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.PWSTR,System.Int32)">
            <summary>Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application. (Unicode)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window or control containing the text.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtextw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpString">
            <para>Type: <b>LPTSTR</b> The buffer that will receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated with a null character.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtextw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nMaxCount">
            <para>Type: <b>int</b> The maximum number of characters to copy to the buffer, including the null character. If the text exceeds this limit, it is truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtextw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>int</b> If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This function cannot retrieve the text of an edit control in another application.</para>
            </returns>
            <remarks>
            <para>If the target window is owned by the current process, <b>GetWindowText</b> causes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a> message to be sent to the specified window or control. If the target window is owned by another process and has a caption, <b>GetWindowText</b> retrieves the window caption text. If the window does not have a caption, the return value is a null string. This behavior is by design. It allows applications to call <b>GetWindowText</b> without becoming unresponsive if the process that owns the target window is not responding. However, if the target window is not responding and it belongs to the calling application, <b>GetWindowText</b> will cause the calling application to become unresponsive. To retrieve the text of a control in another process, send a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a> message directly instead of calling <b>GetWindowText</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtextw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetWindowTextLength(Windows.Win32.Foundation.HWND)">
            <summary>Retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar). (Unicode)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window or control.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtextlengthw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>int</b> If the function succeeds, the return value is the length, in characters, of the text. Under certain conditions, this value might be greater than the length of the text (see Remarks). If the window has no text, the return value is zero. Function failure is indicated by a return value of zero and a <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero. > [!NOTE] > This function does not clear the most recent error information. To determine success or failure, clear the most recent error information by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0, then call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>If the target window is owned by the current process, <b>GetWindowTextLength</b> causes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettextlength">WM_GETTEXTLENGTH</a> message to be sent to the specified window or control. Under certain conditions, the <b>GetWindowTextLength</b> function may return a value that is larger than the actual length of the text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence of double-byte character set (DBCS) characters within the text. The return value, however, will always be at least as large as the actual length of the text; you can thus always use it to guide buffer allocation. This behavior can occur when an application uses both ANSI functions and common dialogs, which use Unicode. It can also occur when an application uses the ANSI version of <b>GetWindowTextLength</b> with a window whose window procedure is Unicode, or the Unicode version of <b>GetWindowTextLength</b> with a window whose window procedure is ANSI. For more information on ANSI and ANSI functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>. To obtain the exact length of the text, use the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a>, <a href="https://docs.microsoft.com/windows/desktop/Controls/lb-gettext">LB_GETTEXT</a>, or <a href="https://docs.microsoft.com/windows/desktop/Controls/cb-getlbtext">CB_GETLBTEXT</a> messages, or the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowtexta">GetWindowText</a> function.</para>
            <para>> [!NOTE] > The winuser.h header defines GetWindowTextLength as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtextlengthw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.GetWindowThreadProcessId(Windows.Win32.Foundation.HWND,System.UInt32*)">
            <summary>Retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that created the window.</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowthreadprocessid#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpdwProcessId">
            <para>Type: <b>LPDWORD</b> A pointer to a variable that receives the process identifier. If this parameter is not <b>NULL</b>, <b>GetWindowThreadProcessId</b> copies the identifier of the process to the variable; otherwise, it does not. If the function fails, the value of the variable is unchanged.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowthreadprocessid#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>DWORD</b> If the function succeeds, the return value is the identifier of the thread that created the window. If the window handle is invalid, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowthreadprocessid">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.DestroyCursor(Windows.Win32.UI.WindowsAndMessaging.HCURSOR)">
            <summary>Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.</summary>
            <param name="hCursor">
            <para>Type: <b>HCURSOR</b> A handle to the cursor to be destroyed. The cursor must not be in use.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The <b>DestroyCursor</b> function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared cursor: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.LoadIcon(Windows.Win32.Foundation.HINSTANCE,System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.LoadIcon(Windows.Win32.Foundation.HINSTANCE,Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.LoadIcon(Windows.Win32.Foundation.HINSTANCE,Windows.Win32.Foundation.PCWSTR)">
            <summary>Loads the specified icon resource from the executable (.exe) file associated with an application instance. (Unicode)</summary>
            <param name="hInstance">
            <para>Type: <b>HINSTANCE</b> A handle to an instance of the module whose executable file contains the icon to be loaded. This parameter must be <b>NULL</b> when a standard icon is being loaded.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpIconName">
            <para>Type: <b>LPCTSTR</b> The name of the icon resource to be loaded. Alternatively, this parameter can contain the resource identifier in the low-order word and zero in the high-order word. Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HICON</b> If the function succeeds, the return value is a handle to the newly loaded icon. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><b>LoadIcon</b> loads the icon resource only if it has not been loaded; otherwise, it retrieves a handle to the existing resource. The function searches the icon resource for the icon most appropriate for the current display. The icon resource can be a color or monochrome bitmap. <b>LoadIcon</b> can only load an icon whose size conforms to the <b>SM_CXICON</b> and <b>SM_CYICON</b> system metric values. Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> function to load icons of other sizes.</para>
            <para>> [!NOTE] > The winuser.h header defines LoadIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.MapWindowPoints(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.HWND,System.ReadOnlySpan{System.Drawing.Point})">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.MapWindowPoints(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.HWND,System.Drawing.Point*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.MapWindowPoints(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.HWND,System.Drawing.Point*,System.UInt32)">
            <summary>The MapWindowPoints function converts (maps) a set of points from a coordinate space relative to one window to a coordinate space relative to another window.</summary>
            <param name="hWndFrom">A handle to the window from which points are converted. If this parameter is <b>NULL</b> or HWND_DESKTOP, the points are presumed to be in screen coordinates.</param>
            <param name="hWndTo">A handle to the window to which points are converted. If this parameter is <b>NULL</b> or HWND_DESKTOP, the points are converted to screen coordinates.</param>
            <param name="lpPoints">A pointer to an array of <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structures that contain the set of points to be converted. The points are in device units. This parameter can also point to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure, in which case the <i>cPoints</i> parameter should be set to 2.</param>
            <param name="cPoints">The number of <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structures in the array pointed to by the <i>lpPoints</i> parameter.</param>
            <returns>
            <para>If the function succeeds, the low-order word of the return value is the number of pixels added to the horizontal coordinate of each source point in order to compute the horizontal coordinate of each destination point. (In addition to that, if precisely one of <i>hWndFrom</i> and <i>hWndTo</i> is mirrored, then each resulting horizontal coordinate is multiplied by -1.) The high-order word is the number of pixels added to the vertical coordinate of each source point in order to compute the vertical coordinate of each destination point. If the function fails, the return value is zero. Call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> prior to calling this method to differentiate an error return value from a legitimate "0" return value.</para>
            </returns>
            <remarks>
            <para>If <i>hWndFrom</i> or <i>hWndTo</i> (or both) are mirrored windows (that is, have <b>WS_EX_LAYOUTRTL</b> extended style) and precisely two points are passed in <i>lpPoints</i>, <b>MapWindowPoints</b> will interpret those two points as a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> and possibly automatically swap the left and right fields of that rectangle to ensure that left is not greater than right. If any number of points other than 2 is passed in <i>lpPoints</i>, then <b>MapWindowPoints</b> will correctly map the coordinates of each of those points separately, so if you pass in a pointer to an array of more than one rectangle in <i>lpPoints</i>, the new rectangles may get their left field greater than right. Thus, to guarantee the correct transformation of rectangle coordinates, you must call <b>MapWindowPoints</b> with one <b>RECT</b> pointer at a time, as shown in the following example:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-mapwindowpoints#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.MonitorFromPoint(System.Drawing.Point,Windows.Win32.Graphics.Gdi.MONITOR_FROM_FLAGS)">
            <summary>The MonitorFromPoint function retrieves a handle to the display monitor that contains a specified point.</summary>
            <param name="pt">A <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that specifies the point of interest in virtual-screen coordinates.</param>
            <param name="dwFlags">Determines the function's return value if the point is not contained within any display monitor.</param>
            <returns>
            <para>If the point is contained by a display monitor, the return value is an <b>HMONITOR</b> handle to that display monitor. If the point is not contained by a display monitor, the return value depends on the value of <i>dwFlags</i>.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-monitorfrompoint">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.MonitorFromRect(Windows.Win32.Foundation.RECT@,Windows.Win32.Graphics.Gdi.MONITOR_FROM_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.MonitorFromRect(Windows.Win32.Foundation.RECT*,Windows.Win32.Graphics.Gdi.MONITOR_FROM_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.MonitorFromRect(Windows.Win32.Foundation.RECT*,Windows.Win32.Graphics.Gdi.MONITOR_FROM_FLAGS)">
            <summary>The MonitorFromRect function retrieves a handle to the display monitor that has the largest area of intersection with a specified rectangle.</summary>
            <param name="lprc">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the rectangle of interest in virtual-screen coordinates.</param>
            <param name="dwFlags">Determines the function's return value if the rectangle does not intersect any display monitor.</param>
            <returns>
            <para>If the rectangle intersects one or more display monitor rectangles, the return value is an <b>HMONITOR</b> handle to the display monitor that has the largest area of intersection with the rectangle. If the rectangle does not intersect a display monitor, the return value depends on the value of <i>dwFlags</i>.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-monitorfromrect">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.MonitorFromWindow(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.MONITOR_FROM_FLAGS)">
            <summary>The MonitorFromWindow function retrieves a handle to the display monitor that has the largest area of intersection with the bounding rectangle of a specified window.</summary>
            <param name="hwnd">A handle to the window of interest.</param>
            <param name="dwFlags">Determines the function's return value if the window does not intersect any display monitor.</param>
            <returns>
            <para>If the window intersects one or more display monitor rectangles, the return value is an <b>HMONITOR</b> handle to the display monitor that has the largest area of intersection with the window. If the window does not intersect a display monitor, the return value depends on the value of <i>dwFlags</i>.</para>
            </returns>
            <remarks>If the window is currently minimized, <b>MonitorFromWindow</b> uses the rectangle of the window before it was minimized.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.PeekMessage(Windows.Win32.UI.WindowsAndMessaging.MSG@,Windows.Win32.Foundation.HWND,System.UInt32,System.UInt32,Windows.Win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.PeekMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*,Windows.Win32.Foundation.HWND,System.UInt32,System.UInt32,Windows.Win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.PeekMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*,Windows.Win32.Foundation.HWND,System.UInt32,System.UInt32,Windows.Win32.UI.WindowsAndMessaging.PEEK_MESSAGE_REMOVE_TYPE)">
            <summary>Dispatches incoming nonqueued messages, checks the thread message queue for a posted message, and retrieves the message (if any exist). (Unicode)</summary>
            <param name="lpMsg">
            <para>Type: <b>LPMSG</b> A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that receives message information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
            <para>If <i>hWnd</i> is <b>NULL</b>, <b>PeekMessage</b> retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b> (see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure). Therefore if hWnd is <b>NULL</b>, both window messages and thread messages are processed. If <i>hWnd</i> is -1, <b>PeekMessage</b> retrieves only messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b>, that is, thread messages as posted by  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a> (when the <i>hWnd</i> parameter is <b>NULL</b>) or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wMsgFilterMin">
            <para>Type: <b>UINT</b> The value of the first message in the range of messages to be examined. Use <b>WM_KEYFIRST</b> (0x0100) to specify the first keyboard message or <b>WM_MOUSEFIRST</b> (0x0200) to specify the first mouse message. If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>PeekMessage</b> returns all available messages (that is, no range filtering is performed).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wMsgFilterMax">
            <para>Type: <b>UINT</b> The value of the last message in the range of messages to be examined. Use <b>WM_KEYLAST</b> to specify the last keyboard message or <b>WM_MOUSELAST</b> to specify the last mouse message. If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>PeekMessage</b> returns all available messages (that is, no range filtering is performed).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wRemoveMsg">Type: <b>UINT</b></param>
            <returns>
            <para>Type: <b>BOOL</b> If a message is available, the return value is nonzero. If no messages are available, the return value is zero.</para>
            </returns>
            <remarks>
            <para><b>PeekMessage</b> retrieves messages associated with the window identified by the <i>hWnd</i> parameter or any of its children as specified by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-ischild">IsChild</a> function, and within the range of message values given by the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. Note that an application can only use the low word in the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters; the high word is reserved for the system. Note that <b>PeekMessage</b> always retrieves <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> messages, no matter which values you specify for <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i>. During this call, the system dispatches (<a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessage">DispatchMessage</a>) pending,  nonqueued messages, that is, messages sent to windows owned by the calling thread using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a> function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.PostMessage(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)">
            <summary>Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message. (Unicode)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window whose window procedure is to receive the message. The following values have special meanings. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Msg">
            <para>Type: <b>UINT</b> The message to be posted. For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wParam">
            <para>Type: <b>WPARAM</b> Additional message-specific information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> Additional message-specific information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, is set to 5 (access denied). Messages in a message queue are retrieved by calls to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function. Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication. The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling. If you send a message in the range below <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> to the asynchronous message functions (<b>PostMessage</b>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used. Do not post the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message using <b>PostMessage</b>; use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postquitmessage">PostQuitMessage</a> function. An accessibility application can use <b>PostMessage</b> to post <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-appcommand">WM_APPCOMMAND</a> messages  to the shell to launch applications. This  functionality is not guaranteed to work for other types of applications. There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large.  If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key. <pre><b>HKEY_LOCAL_MACHINE</b> <b>SOFTWARE</b> <b>Microsoft</b> <b>Windows NT</b> <b>CurrentVersion</b> <b>Windows</b> <b>USERPostMessageLimit</b></pre> If the function fails, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information. <b>GetLastError</b> returns <b>ERROR_NOT_ENOUGH_QUOTA</b> when the limit is hit. The minimum acceptable value is 4000.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.RegisterClipboardFormat(System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvokeCore.RegisterClipboardFormat(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.RegisterClipboardFormat(Windows.Win32.Foundation.PCWSTR)">
            <summary>Registers a new clipboard format. This format can then be used as a valid clipboard format. (Unicode)</summary>
            <param name="lpszFormat">
            <para>Type: <b>LPCTSTR</b> The name of the new format.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclipboardformatw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>UINT</b> If the function succeeds, the return value identifies the registered clipboard format. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>If a registered format with the specified name already exists, a new format is not registered and the return value identifies the existing format. This enables more than one application to copy and paste data using the same registered clipboard format. Note that the format name comparison is case-insensitive. Registered clipboard formats are identified by values in the range 0xC000 through 0xFFFF. When registered clipboard formats are placed on or retrieved from the clipboard, they must be in the form of an <b>HGLOBAL</b> value.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclipboardformatw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.ReleaseDC(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The ReleaseDC function releases a device context (DC), freeing it for use by other applications. The effect of the ReleaseDC function depends on the type of DC. It frees only common and window DCs. It has no effect on class or private DCs.</summary>
            <param name="hWnd">A handle to the window whose DC is to be released.</param>
            <param name="hDC">A handle to the DC to be released.</param>
            <returns>
            <para>The return value indicates whether the DC was released. If the DC was released, the return value is 1. If the DC was not released, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The application must call the <b>ReleaseDC</b> function for each call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowdc">GetWindowDC</a> function and for each call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdc">GetDC</a> function that retrieves a common DC. An application cannot use the <b>ReleaseDC</b> function to release a DC that was created by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createdca">CreateDC</a> function; instead, it must use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deletedc">DeleteDC</a> function. <b>ReleaseDC</b> must be called from the same thread that called <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdc">GetDC</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-releasedc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SendMessage(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)">
            <summary>Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message. (SendMessageW)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows. Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Msg">
            <para>Type: <b>UINT</b> The message to be sent. For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wParam">
            <para>Type: <b>WPARAM</b> Additional message-specific information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> Additional message-specific information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>LRESULT</b> The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, is set to 5 (access denied). Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication. The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling. If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to be processed. To prevent this, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a> with SMTO_BLOCK set. For more information on nonqueued messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">Nonqueued Messages</a>. An accessibility application can use <b>SendMessage</b> to send <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-appcommand">WM_APPCOMMAND</a> messages  to the shell to launch applications. This  functionality is not guaranteed to work for other types of applications.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SystemParametersInfo(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_ACTION,System.UInt32,System.Void*,Windows.Win32.UI.WindowsAndMessaging.SYSTEM_PARAMETERS_INFO_UPDATE_FLAGS)">
            <summary>Retrieves or sets the value of one of the system-wide parameters. (Unicode)</summary>
            <param name="uiAction">
            <para>Type: <b>UINT</b> The system-wide parameter to be retrieved or set. The possible values are organized in the following tables of related parameters: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-systemparametersinfow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="uiParam">
            <para>Type: <b>UINT</b> A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify zero for this parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-systemparametersinfow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pvParam">
            <para>Type: <b>PVOID</b> A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify <b>NULL</b> for this parameter. For information on the <b>PVOID</b> datatype, see <a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">Windows Data Types</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-systemparametersinfow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="fWinIni">
            <para>Type: <b>UINT</b> If a system parameter is being set, specifies whether the user profile is to be updated, and if so, whether the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message is to be broadcast to all top-level windows to notify them of the change.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-systemparametersinfow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>This function is intended for use with applications that allow the user to customize the environment. A keyboard layout name should be derived from the hexadecimal value of the language identifier corresponding to the layout. For example, U.S. English has a language identifier of 0x0409, so the primary U.S. English layout is named "00000409". Variants of U.S. English layout, such as the Dvorak layout, are named "00010409", "00020409" and so on. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <b>MAKELANGID</b> macro. There is a difference between the High Contrast color scheme and the High Contrast Mode. The High Contrast color scheme changes the system colors to colors that have obvious contrast; you switch to this color scheme by using the Display Options in the control panel. The High Contrast Mode, which uses <b>SPI_GETHIGHCONTRAST</b> and <b>SPI_SETHIGHCONTRAST</b>, advises applications to modify their appearance for visually-impaired users. It involves such things as audible warning to users and customized color scheme (using the Accessibility Options in the control panel). For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-highcontrasta">HIGHCONTRAST</a>. For more information on general accessibility features, see <a href="https://docs.microsoft.com/windows/desktop/accessibility">Accessibility</a>. During the time that the primary button is held down to activate the Mouse ClickLock feature, the user can move the mouse. After the primary button is locked down, releasing the primary button does not result in a <b>WM_LBUTTONUP</b> message. Thus, it will appear to an application that the primary button is still down. Any subsequent button message releases the primary button, sending a <b>WM_LBUTTONUP</b> message to the application, thus the button can be unlocked programmatically or through the user clicking any button. This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of this API, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfofordpi">SystemParametersInfoForDPI</a>. For more information on DPI awareness, see <a href="https://docs.microsoft.com/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows">the Windows High DPI documentation.</a></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-systemparametersinfow#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.SystemParametersInfoForDpi(System.UInt32,System.UInt32,System.Void*,System.UInt32,System.UInt32)">
            <summary>Retrieves the value of one of the system-wide parameters, taking into account the provided DPI value.</summary>
            <param name="uiAction">The system-wide parameter to be retrieved. This function is only intended for use with <b>SPI_GETICONTITLELOGFONT</b>, <b>SPI_GETICONMETRICS</b>, or <b>SPI_GETNONCLIENTMETRICS</b>. See <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a> for more information on these values.</param>
            <param name="uiParam">A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify zero for this parameter.</param>
            <param name="pvParam">A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify <b>NULL</b> for this parameter. For information on the <b>PVOID</b> datatype, see <a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">Windows Data Types</a>.</param>
            <param name="fWinIni">Has no effect for with this API. This parameter only has an effect if you're setting parameter.</param>
            <param name="dpi">The DPI to use for scaling the metric.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>This function returns a similar result as <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a>, but scales it according to an arbitrary DPI you provide (if appropriate). It only scales with the following possible values for <i>uiAction</i>: <b>SPI_GETICONTITLELOGFONT</b>, <b>SPI_GETICONMETRICS</b>, <b>SPI_GETNONCLIENTMETRICS</b>. Other possible <i>uiAction</i> values do not provide ForDPI behavior, and therefore this function returns 0 if called with them. For <i>uiAction</i> values that contain strings within their associated structures, only Unicode (<a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONTW</a>) strings are supported in this function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-systemparametersinfofordpi#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvokeCore.WindowFromDC(Windows.Win32.Graphics.Gdi.HDC)">
            <summary>The WindowFromDC function returns a handle to the window associated with the specified display device context (DC). Output functions that use the specified device context draw into this window.</summary>
            <param name="hDC">Handle to the device context from which a handle to the associated window is to be retrieved.</param>
            <returns>The return value is a handle to the window associated with the specified DC. If no window is associated with the specified DC, the return value is <b>NULL</b>.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-windowfromdc">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ComInterfaceTable.Create``1">
            <summary>
             Create an interface table for the given interface.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.ComInterfaceTable.Create``2">
            <summary>
             Create an interface table for the given interfaces.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.ComInterfaceTable.Create``3">
            <summary>
             Create an interface table for the given interfaces.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.ComInterfaceTable.Create``4">
            <summary>
             Create an interface table for the given interfaces.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.ComInterfaceTable.Create``5">
            <summary>
             Create an interface table for the given interfaces.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.ComInterfaceTable.Create``6">
            <summary>
             Create an interface table for the given interfaces.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.ComInterfaceTable.Create``10">
            <summary>
             Create an interface table for the given interfaces.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.ComInterfaceTable.Create``27">
            <summary>
             Create an interface table for the given interfaces.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.ComManagedStream.Windows#Win32#System#Com#IStream#Interface#LockRegion(System.UInt64,System.UInt64,System.UInt32)">
            Returns HRESULT.STG_E_INVALIDFUNCTION as a documented way to say we don't support locking
        </member>
        <member name="M:Windows.Win32.System.Com.ComManagedStream.Windows#Win32#System#Com#IStream#Interface#UnlockRegion(System.UInt64,System.UInt64,System.UInt32)">
            Returns HRESULT.STG_E_INVALIDFUNCTION as a documented way to say we don't support locking
        </member>
        <member name="T:Windows.Win32.System.Com.CY">
            <summary>The CY structure is useful for calculations involving money, or for any fixed-point calculation where accuracy is particularly important.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.CY.int64">
            <summary></summary>
        </member>
        <member name="T:Windows.Win32.System.Com.IComCallableWrapper">
            <inheritdoc cref="T:Windows.Win32.System.Com.IComCallableWrapper.Interface"/>
        </member>
        <member name="T:Windows.Win32.System.Com.IComCallableWrapper.Interface">
            <summary>
             Used to flag that the COM object is a <see cref="T:System.Runtime.InteropServices.ComWrappers"/> generated object.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.TryGetProperty(System.UInt32,Windows.Win32.System.Variant.VARIANT*,System.UInt32)">
            <summary>
             Get the specified <paramref name="dispId"/> property.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.TryGetProperty(System.Int32,Windows.Win32.System.Variant.VARIANT*,System.UInt32)">
            <summary>
             Get the specified <paramref name="dispId"/> property.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.GetProperty(System.UInt32,System.UInt32)">
            <summary>
             Get the specified <paramref name="dispId"/> property.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.GetProperty(System.Int32,System.UInt32)">
            <summary>
             Get the specified <paramref name="dispId"/> property.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.GetIDOfName(System.String,System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDispatch.GetIDsOfNames(System.Guid*,Windows.Win32.Foundation.PWSTR*,System.UInt32,System.UInt32,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDispatch.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.GetTypeInfoCount(System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDispatch.GetTypeInfoCount(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.GetTypeInfoCount(System.UInt32*)">
            <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
            <param name="pctinfo">The number of type information interfaces provided by the object. If the object provides type information, this number is 1; otherwise the number is 0.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>The method may return zero, which indicates that the object does not provide any type information. In this case, the object may still be programmable through <b>IDispatch</b> or a VTBL, but does not provide run-time type information for browsers, compilers, or other programming tools that access type information. This can be useful for hiding an object from browsers.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.GetTypeInfo(System.UInt32,System.UInt32,Windows.Win32.System.Com.ITypeInfo**)">
            <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
            <param name="iTInfo">The type information to return. Pass 0 to retrieve type information for the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch</a> implementation.</param>
            <param name="lcid">The locale identifier for the type information. An object may be able to return different type information for different languages. This is important for classes that support localized member names. For classes that do not support localized member names, this parameter can be ignored.</param>
            <param name="ppTInfo">The requested type information object.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfo">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.GetIDsOfNames(System.Guid@,System.ReadOnlySpan{Windows.Win32.Foundation.PWSTR},System.UInt32,System.Span{System.Int32})">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDispatch.GetIDsOfNames(System.Guid*,Windows.Win32.Foundation.PWSTR*,System.UInt32,System.UInt32,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.GetIDsOfNames(System.Guid*,Windows.Win32.Foundation.PWSTR*,System.UInt32,System.UInt32,System.Int32*)">
            <summary>Maps a single member and an optional set of argument names to a corresponding set of integer DISPIDs, which can be used on subsequent calls to Invoke.</summary>
            <param name="riid">Reserved for future use. Must be IID_NULL.</param>
            <param name="rgszNames">The array of names to be mapped.</param>
            <param name="cNames">The count of the names to be mapped.</param>
            <param name="lcid">The locale context in which to interpret the names.</param>
            <param name="rgDispId">Caller-allocated array, each element of which contains an identifier (ID) corresponding to one of the names passed in the rgszNames array. The first element represents the member name. The subsequent elements represent each of the member's parameters.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>An <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch</a> implementation can associate any positive integer ID value with a given name. Zero is reserved for the default, or <b>Value</b> property; –1 is reserved to indicate an unknown name; and other negative values are defined for other purposes. For example, if <b>GetIDsOfNames</b> is called, and the implementation does not recognize one or more of the names, it returns DISP_E_UNKNOWNNAME, and the <i>rgDispId</i> array contains DISPID_UNKNOWN for the entries that correspond to the unknown names. The member and parameter DISPIDs must remain constant for the lifetime of the object. This allows a client to obtain the DISPIDs once, and cache them for later use. When <b>GetIDsOfNames</b> is called with more than one name, the first name (<i>rgszNames</i>[0]) corresponds to the member name, and subsequent names correspond to the names of the member's parameters. The same name may map to different DISPIDs, depending on context. For example, a name may have a DISPID when it is used as a member name with a particular interface, a different ID as a member of a different interface, and different mapping for each time it appears as a parameter. <b>GetIDsOfNames</b> is used when an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch</a> client binds to names at run time. To bind at compile time instead, an <b>IDispatch</b> client can map names to DISPIDs by using the type information interfaces described in <a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/type-description-interfaces">Type Description Interfaces</a>. This allows a client to bind to members at compile time and avoid calling <b>GetIDsOfNames</b> at run time. For a description of binding at compile time, see Type Description Interfaces. The implementation of <b>GetIDsOfNames</b> is case insensitive. Users that need case-sensitive name mapping should use type information interfaces to map names to DISPIDs, rather than call <b>GetIDsOfNames</b>. <div class="alert"><b>Caution</b>  You cannot use this method to access values that have been added dynamically, such as values added through JavaScript. Instead, use the GetDispID of the IDispatchEx interface. For more information, see the <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/reference/idispatchex-interface">IDispatchEx interface</a>.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.Invoke(System.Int32,System.Guid@,System.UInt32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS@,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDispatch.Invoke(System.Int32,System.Guid*,System.UInt32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS*,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDispatch.Invoke(System.Int32,System.Guid*,System.UInt32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS*,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,System.UInt32*)">
            <summary>Provides access to properties and methods exposed by an object.</summary>
            <param name="dispIdMember">Identifies the member. Use <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-getidsofnames">GetIDsOfNames</a> or the object's documentation to obtain the dispatch identifier.</param>
            <param name="riid">Reserved for future use. Must be IID_NULL.</param>
            <param name="lcid">
            <para>The locale context in which to interpret arguments. The <i>lcid</i> is used by the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-getidsofnames">GetIDsOfNames</a> function, and is also passed to <b>Invoke</b> to allow the object to interpret its arguments specific to a locale. Applications that do not support multiple national languages can ignore this parameter. For more information, refer to <a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/supporting-multiple-national-languages">Supporting Multiple National Languages</a> and <a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/exposing-activex-objects">Exposing ActiveX Objects</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wFlags">
            <para>Flags describing the context of the <b>Invoke</b> call. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pDispParams">Pointer to a DISPPARAMS structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</param>
            <param name="pVarResult">Pointer to the location where the result is to be stored, or NULL if the caller expects no result. This argument is ignored if DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF is specified.</param>
            <param name="pExcepInfo">Pointer to a structure that contains exception information. This structure should be filled in if DISP_E_EXCEPTION is returned. Can be NULL.</param>
            <param name="puArgErr">The index within rgvarg of the first argument that has an error. Arguments are stored in pDispParams-&gt;rgvarg in reverse order, so the first argument is the one with the highest index in the array. This parameter is returned only when the resulting return value is DISP_E_TYPEMISMATCH or DISP_E_PARAMNOTFOUND. This argument can be set to null. For details, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/returning-errors">Returning Errors</a>.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>Generally, you should not implement <b>Invoke</b> directly. Instead, use the dispatch interface to create functions <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-createstddispatch">CreateStdDispatch</a> and <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-dispinvoke">DispInvoke</a>. For details, refer to <b>CreateStdDispatch</b>, <b>DispInvoke</b>, <a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/creating-the-idispatch-interface">Creating the IDispatch Interface</a> and <a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/exposing-activex-objects">Exposing ActiveX Objects</a>. If some application-specific processing needs to be performed before calling a member, the code should perform the necessary actions, and then call <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypeinfo-invoke">ITypeInfo::Invoke</a> to invoke the member. <b>ITypeInfo::Invoke</b> acts exactly like <b>Invoke</b>. The standard implementations of <b>Invoke</b> created by <b>CreateStdDispatch</b> and <b>DispInvoke</b> defer to <b>ITypeInfo::Invoke</b>. In an ActiveX client, <b>Invoke</b> should be used to get and set the values of properties, or to call a method of an ActiveX object. The <i>dispIdMember</i> argument identifies the member to invoke. The DISPIDs that identify members are defined by the implementer of the object and can be determined by using the object's documentation, the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-getidsofnames">IDispatch::GetIDsOfNames</a> function, or the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</a> interface. When you use <b>IDispatch::Invoke()</b> with DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF, you have to specially initialize the <b>cNamedArgs</b> and <b>rgdispidNamedArgs</b> elements of your DISPPARAMS structure with the following:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IDispatch.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00020400-0000-0000-c000-000000000046}</value>
        </member>
        <member name="T:Windows.Win32.System.Com.IManagedWrapper">
            <summary>
             An interface that provides a COM callable wrapper for the implementing class. The implementing class should not
             be public and unsealed as it can be derived from and COM interfaces can be added. This is meant to be a fixed
             set of interfaces.
            </summary>
            <remarks>
             <para>
              NET CCWs generated by built-in COM interop always support IMarshal, ISupportErrorInfo, IDispatchEx,
              IProvideClassInfo, and IConnectionPointContainer. They also usually expose IAgileObject. On Exception objects
              the CCW also supports IErrorInfo. These must explicitly be provided with this mechanism.
             </para>
             <para>
              .NET Framework also supported the following interfaces, which are not implemented on .NET Core:
             </para>
             <list type="bullet">
              <item><description>IManagedObject          - used .NET Remoting (not available on .NET Core)</description></item>
              <item><description>IObjectSafety           - for Code Access Security (not available on .NET Core)</description></item>
              <item><description>IWeakReferenceSource    - for WinRT</description></item>
              <item><description>ICustomPropertyProvider - for WinRT XAML (Jupiter)</description></item>
              <item><description>IReferenceTrackerTarget - for WinRT</description></item>
              <item><description>IStringable             - for WinRT</description></item>
             </list>
            </remarks>
        </member>
        <member name="T:Windows.Win32.System.Com.IManagedWrapper`1">
            <summary>
             Apply to a class to apply a COM callable wrapper of the given <typeparamref name="TComInterface"/>. The class
             must also derive from the given COM wrapper <see langword="struct"/>'s nested Interface.
            </summary>
        </member>
        <member name="T:Windows.Win32.System.Com.IManagedWrapper`2">
            <summary>
             Apply to a class to apply a COM callable wrapper of the given <typeparamref name="TComInterface1"/> and
             <typeparamref name="TComInterface2"/>. The class must also derive from both of the given COM wrapper
             <see langword="struct"/>'s nested Interface.
            </summary>
        </member>
        <member name="T:Windows.Win32.System.Com.IManagedWrapper`3">
            <summary>
             Apply to a class to apply a COM callable wrapper of the given interfaces. The class must also derive from the
             given COM wrapper structs' nested Interfaces.
            </summary>
        </member>
        <member name="T:Windows.Win32.System.Com.IManagedWrapper`4">
            <summary>
             Apply to a class to apply a COM callable wrapper of the given interfaces. The class must also derive from the
             given COM wrapper structs' nested Interfaces.
            </summary>
        </member>
        <member name="T:Windows.Win32.System.Com.IManagedWrapper`5">
            <summary>
             Apply to a class to apply a COM callable wrapper of the given interfaces. The class must also derive from the
             given COM wrapper structs' nested Interfaces.
            </summary>
        </member>
        <member name="T:Windows.Win32.System.Com.IManagedWrapper`6">
            <summary>
             Apply to a class to apply a COM callable wrapper of the given interfaces. The class must also derive from the
             given COM wrapper structs' nested Interfaces.
            </summary>
        </member>
        <member name="T:Windows.Win32.System.Com.IManagedWrapper`10">
            <summary>
             Apply to a class to apply a COM callable wrapper of the given interfaces. The class must also derive from the
             given COM wrapper structs' nested Interfaces.
            </summary>
        </member>
        <member name="T:Windows.Win32.System.Com.IManagedWrapper`27">
            <summary>
             Apply to a class to apply a COM callable wrapper of the given interfaces. The class must also derive from the
             given COM wrapper structs' nested Interfaces.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetIDOfName(System.String,System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetIDsOfNames(Windows.Win32.Foundation.PWSTR*,System.UInt32,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetTypeAttr(Windows.Win32.System.Com.TYPEATTR*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetTypeAttr(Windows.Win32.System.Com.TYPEATTR**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetTypeAttr(Windows.Win32.System.Com.TYPEATTR**)">
            <summary>Retrieves a TYPEATTR structure that contains the attributes of the type description.</summary>
            <param name="ppTypeAttr">The attributes of this type description.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>To free the TYPEATTR structure, use <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypeinfo-releasetypeattr">ITypeInfo::ReleaseTypeAttr</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetTypeComp(Windows.Win32.System.Com.ITypeComp**)">
            <summary>Retrieves the ITypeComp interface for the type description, which enables a client compiler to bind to the type description's members.</summary>
            <param name="ppTComp">The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> of the containing type library.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>A client compiler can use the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> interface to bind to members of the type.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetFuncDesc(System.UInt32,Windows.Win32.System.Com.FUNCDESC*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetFuncDesc(System.UInt32,Windows.Win32.System.Com.FUNCDESC**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetFuncDesc(System.UInt32,Windows.Win32.System.Com.FUNCDESC**)">
            <summary>Retrieves the FUNCDESC structure that contains information about a specified function.</summary>
            <param name="index">The index of the function whose description is to be returned. The <i>index</i> should be in the range of 0 to 1 less than the number of functions in this type.</param>
            <param name="ppFuncDesc">A FUNCDESC structure that describes the specified function.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>The function <b>ITypeInfo::GetFuncDesc</b> provides access to a FUNCDESC structure that describes the function with the specified <i>index</i>. The FUNCDESC structure should be freed with <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypeinfo-releasefuncdesc">ITypeInfo::ReleaseFuncDesc</a>. The number of functions in the type is one of the attributes contained in the TYPEATTR structure.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetVarDesc(System.UInt32,Windows.Win32.System.Com.VARDESC*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetVarDesc(System.UInt32,Windows.Win32.System.Com.VARDESC**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetVarDesc(System.UInt32,Windows.Win32.System.Com.VARDESC**)">
            <summary>Retrieves a VARDESC structure that describes the specified variable.</summary>
            <param name="index">The index of the variable whose description is to be returned. The index should be in the range of 0 to 1 less than the number of variables in this type.</param>
            <param name="ppVarDesc">A VARDESC that describes the specified variable.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>To free the VARDESC structure, use <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypeinfo-releasevardesc">ReleaseVarDesc</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetNames(System.Int32,Windows.Win32.Foundation.BSTR*,System.UInt32,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetNames(System.Int32,Windows.Win32.Foundation.BSTR*,System.UInt32,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetNames(System.Int32,Windows.Win32.Foundation.BSTR*,System.UInt32,System.UInt32*)">
            <summary>Retrieves the variable with the specified member ID or the name of the property or method and the parameters that correspond to the specified function ID.</summary>
            <param name="memid">The ID of the member whose name (or names) is to be returned.</param>
            <param name="rgBstrNames">The caller-allocated array. On return, each of the elements contains the name (or names) associated with the member.</param>
            <param name="cMaxNames">The length of the passed-in <i>rgBstrNames</i> array.</param>
            <param name="pcNames">The number of names in the <i>rgBstrNames</i> array.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The caller must release the returned BSTR array.</para>
            <para>If the member ID identifies a property that is implemented with property functions, the property name is returned. For property get functions, the names of the function and its parameters are always returned.</para>
            <para>For property put and put reference functions, the right side of the assignment is unnamed. If <i>cMaxNames</i> is less than is required to return all of the names of the parameters of a function, then only the names of the first <i>cMaxNames</i> - 1 parameters are returned. The names of the parameters are returned in the array in the same order that they appear elsewhere in the interface (for example, the same order in the parameter array associated with the FUNCDESC enumeration).</para>
            <para>If the type description inherits from another type description, this function is recursive to the base type description, if necessary, to find the item with the requested member ID.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-getnames#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetRefTypeOfImplType(System.UInt32,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetRefTypeOfImplType(System.UInt32,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetRefTypeOfImplType(System.UInt32,System.UInt32*)">
            <summary>If a type description describes a COM class, it retrieves the type description of the implemented interface types.</summary>
            <param name="index">The index of the implemented type whose handle is returned. The valid range is 0 to the <b>cImplTypes</b> field in the TYPEATTR structure.</param>
            <param name="pRefType">A handle for the implemented interface (if any). This handle can be passed to <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypeinfo-getreftypeinfo">ITypeInfo::GetRefTypeInfo</a> to get the type description.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>If the TKIND_DISPATCH type description is for a dual interface, the TKIND_INTERFACE type description can be obtained by calling <b>GetRefTypeOfImplType</b> with an <i>index</i> of –1, and by passing the returned <i>pRefTypehandle</i> to <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypeinfo-getreftypeinfo">GetRefTypeInfo</a> to retrieve the type information.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetImplTypeFlags(System.UInt32,Windows.Win32.System.Com.IMPLTYPEFLAGS@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetImplTypeFlags(System.UInt32,Windows.Win32.System.Com.IMPLTYPEFLAGS*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetImplTypeFlags(System.UInt32,Windows.Win32.System.Com.IMPLTYPEFLAGS*)">
            <summary>Retrieves the IMPLTYPEFLAGS enumeration for one implemented interface or base interface in a type description.</summary>
            <param name="index">The index of the implemented interface or base interface for which to get the flags.</param>
            <param name="pImplTypeFlags">The IMPLTYPEFLAGS enumeration value.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>The flags are associated with the act of inheritance, and not with the inherited interface.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetIDsOfNames(System.ReadOnlySpan{Windows.Win32.Foundation.PWSTR},System.Span{System.Int32})">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetIDsOfNames(Windows.Win32.Foundation.PWSTR*,System.UInt32,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetIDsOfNames(Windows.Win32.Foundation.PWSTR*,System.UInt32,System.Int32*)">
            <summary>Maps between member names and member IDs, and parameter names and parameter IDs.</summary>
            <param name="rgszNames">An array of names to be mapped.</param>
            <param name="cNames">The count of the names to be mapped.</param>
            <param name="pMemId">Caller-allocated array in which name mappings are placed.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The function <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-getidsofnames">GetIDsOfNames</a> maps the name of a member (<b>rgszNames</b>[0]) and its parameters (<b>rgszNames</b>[1] ...<b>rgszNames</b>[<b>cNames</b>- 1]) to the ID of the member (<b>pMemId</b>[0]), and to the IDs of the specified parameters (<b>pMemId</b>[1] ... <b>pMemId</b>[<b>cNames</b>- 1]). The IDs of parameters are 0 for the first parameter in the member function's argument list, 1 for the second, and so on.</para>
            <para>If the type description inherits from another type description, this function is recursive to the base type description, if necessary, to find the item with the requested member ID.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-getidsofnames#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.Invoke(System.Void*,System.Int32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS@,Windows.Win32.System.Variant.VARIANT@,Windows.Win32.System.Com.EXCEPINFO@,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Invoke(System.Void*,System.Int32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS*,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.Invoke(System.Void*,System.Int32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS*,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,System.UInt32*)">
            <summary>Invokes a method, or accesses a property of an object, that implements the interface described by the type description.</summary>
            <param name="pvInstance">An instance of the interface described by this type description.</param>
            <param name="memid">The interface member.</param>
            <param name="wFlags">
            <para>Flags describing the context of the invoke call. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-invoke#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pDispParams">An array of arguments, an array of DISPIDs for named arguments, and counts of the number of elements in each array.</param>
            <param name="pVarResult">The result. Should be null if the caller does not expect any result. If <i>wFlags</i> specifies DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF, <i>pVarResultis</i> is ignored.</param>
            <param name="pExcepInfo">An exception information structure, which is filled in only if DISP_E_EXCEPTION is returned. If <i>pExcepInfo</i> is null on input, only an HRESULT error will be returned.</param>
            <param name="puArgErr">If Invoke returns DISP_E_TYPEMISMATCH, <i>puArgErr</i> indicates the index (within <i>rgvarg</i>) of the argument with incorrect type. If more than one argument returns an error, <i>puArgErr</i> indicates only the first argument with an error. Arguments in pDispParams-&gt;rgvarg appear in reverse order, so the first argument is the one having the highest index in the array. This parameter cannot be null.</param>
            <returns>
            <para></para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>Use the function <b>ITypeInfo::Invoke</b> to access a member of an object or invoke a method that implements the interface described by this type description. For objects that support the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch</a> interface, you can use <b>Invoke</b> to implement <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-invoke">IDispatch::Invoke</a>.</para>
            <para><b>ITypeInfo::Invoke</b> takes a pointer to an instance of the class. Otherwise, its parameters are the same as <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-invoke">IDispatch::Invoke</a>, except that <b>ITypeInfo::Invoke</b> omits the <i>refiid</i> and <i>lcid</i> parameters. When called, <b>ITypeInfo::Invoke</b> performs the actions described by the <b>IDispatch::Invoke</b> parameters on the specified instance.</para>
            <para>For VTBL interface members, <b>ITypeInfo::Invoke</b> passes the LCID of the type information into parameters tagged with the lcid attribute, and the returned value into the retval attribute.</para>
            <para>If the type description inherits from another type description, this function recurses on the base type description to find the item with the requested member ID.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-invoke#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetDocumentation(System.Int32,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt32@,Windows.Win32.Foundation.BSTR*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetDocumentation(System.Int32,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt32*,Windows.Win32.Foundation.BSTR*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetDocumentation(System.Int32,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt32*,Windows.Win32.Foundation.BSTR*)">
            <summary>Retrieves the documentation string, the complete Help file name and path, and the context ID for the Help topic for a specified type description.</summary>
            <param name="memid">The ID of the member whose documentation is to be returned.</param>
            <param name="pBstrName">The name of the specified item. If the caller does not need the item name, <i>pBstrName</i> can be null.</param>
            <param name="pBstrDocString">The documentation string for the specified item. If the caller does not need the documentation string, <i>pBstrDocString</i> can be null.</param>
            <param name="pdwHelpContext">The Help localization context. If the caller does not need the Help context, it can be null.</param>
            <param name="pBstrHelpFile">The fully qualified name of the file containing the DLL used for Help file. If the caller does not need the file name, it can be null.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The function <b>GetDocumentation</b> provides access to the documentation for the member specified by the <i>memid</i> parameter. If the passed-in <i>memid</i> is MEMBERID_NIL, then the documentation for the type description is returned.</para>
            <para>If the type description inherits from another type description, this function is recursive to the base type description, if necessary, to find the item with the requested member ID.</para>
            <para>The caller should use <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-sysfreestring">SysFreeString</a> to free the BSTRs referenced by <i>pBstrName</i>, <i>pBstrDocString</i>, and <i>pBstrHelpFile</i>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-getdocumentation#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetDllEntry(System.Int32,Windows.Win32.System.Com.INVOKEKIND,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt16@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetDllEntry(System.Int32,Windows.Win32.System.Com.INVOKEKIND,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt16*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetDllEntry(System.Int32,Windows.Win32.System.Com.INVOKEKIND,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt16*)">
            <summary>Retrieves a description or specification of an entry point for a function in a DLL.</summary>
            <param name="memid">The ID of the member function whose DLL entry description is to be returned.</param>
            <param name="invKind">The kind of member identified by <i>memid</i>. This is important for properties, because one <i>memid</i> can identify up to three separate functions.</param>
            <param name="pBstrDllName">If not null, the function sets <i>pBstrDllName</i> to the name of the DLL.</param>
            <param name="pBstrName">If not null, the function sets <i>pBstrName</i> to the name of the entry point. If the entry point is specified by an ordinal, this argument is null.</param>
            <param name="pwOrdinal">If not null, and if the function is defined by an ordinal, the function sets <i>pwOrdinal</i> to the ordinal.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The caller passes in a member ID, which represents the member function whose entry description is desired. If the function has a DLL entry point, the name of the DLL that contains the function, as well as its name or ordinal identifier, are placed in the passed-in pointers allocated by the caller. If there is no DLL entry point for the function, an error is returned.</para>
            <para>If the type description inherits from another type description, this function is recursive to the base type description, if necessary, to find the item with the requested member ID.</para>
            <para>The caller should use <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-sysfreestring">SysFreeString</a> to free the BSTRs referenced by <i>pBstrName</i> and <i>pBstrDllName</i>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-getdllentry#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetRefTypeInfo(System.UInt32,Windows.Win32.System.Com.ITypeInfo**)">
            <summary>If a type description references other type descriptions, it retrieves the referenced type descriptions.</summary>
            <param name="hRefType">A handle to the referenced type description to return.</param>
            <param name="ppTInfo">The referenced type description.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>On return, the second parameter contains a pointer to a pointer to a type description that is referenced by this type description. A type description must have a reference to each type description that occurs as the type of any of its variables, function parameters, or function return types. For example, if the type of a data member is a record type, the type description for that data member contains the <i>hRefType</i> of a referenced type description. To get a pointer to the type description, the reference is passed to <b>GetRefTypeInfo</b>.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.AddressOfMember(System.Int32,Windows.Win32.System.Com.INVOKEKIND,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.AddressOfMember(System.Int32,Windows.Win32.System.Com.INVOKEKIND,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.AddressOfMember(System.Int32,Windows.Win32.System.Com.INVOKEKIND,System.Void**)">
            <summary>Retrieves the addresses of static functions or variables, such as those defined in a DLL.</summary>
            <param name="memid">The member ID of the static member whose address is to be retrieved. The member ID is defined by the DISPID.</param>
            <param name="invKind">Indicates whether the member is a property, and if so, what kind.</param>
            <param name="ppv">The static member.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The addresses are valid until the caller releases its reference to the type description. The <i>invKind</i> parameter can be ignored unless the address of a property function is being requested. If the type description inherits from another type description, this function is recursive to the base type description, if necessary, to find the item with the requested member ID.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-addressofmember#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.CreateInstance(Windows.Win32.System.Com.IUnknown*,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.CreateInstance(Windows.Win32.System.Com.IUnknown*,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.CreateInstance(Windows.Win32.System.Com.IUnknown*,System.Guid*,System.Void**)">
            <summary>Creates a new instance of a type that describes a component object class (coclass).</summary>
            <param name="pUnkOuter">The controlling <b>IUnknown</b>. If Null, then a stand-alone instance is created. If valid, then an aggregate object is created.</param>
            <param name="riid">An ID for the interface that the caller will use to communicate with the resulting object.</param>
            <param name="ppvObj">An instance of the created object.</param>
            <returns>
            <para></para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>For types that describe a component object class (coclass), <b>CreateInstance</b> creates a new instance of the class. Normally, <b>CreateInstance</b> calls <b>CoCreateInstance</b> with the type description's GUID. For an Application object, it first calls <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-getactiveobject">GetActiveObject</a>. If the application is active, <b>GetActiveObject</b> returns the active object; otherwise, if <b>GetActiveObject</b> fails, <b>CreateInstance</b> calls <b>CoCreateInstance</b>.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetMops(System.Int32,Windows.Win32.Foundation.BSTR*)">
            <summary>Retrieves marshaling information.</summary>
            <param name="memid">The member ID that indicates which marshaling information is needed.</param>
            <param name="pBstrMops">The opcode string used in marshaling the fields of the structure described by the referenced type description, or null if there is no information to return.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>If the passed-in member ID is MEMBERID_NIL, the function returns the opcode string for marshaling the fields of the structure described by the type description. Otherwise, it returns the opcode string for marshaling the function specified by the index.</para>
            <para>If the type description inherits from another type description, this function recurses on the base type description, if necessary, to find the item with the requested member ID.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-getmops#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetContainingTypeLib(Windows.Win32.System.Com.ITypeLib**,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.GetContainingTypeLib(Windows.Win32.System.Com.ITypeLib**,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.GetContainingTypeLib(Windows.Win32.System.Com.ITypeLib**,System.UInt32*)">
            <summary>Retrieves the containing type library and the index of the type description within that type library.</summary>
            <param name="ppTLib">The containing type library.</param>
            <param name="pIndex">The index of the type description within the containing type library.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-getcontainingtypelib">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.ReleaseTypeAttr(Windows.Win32.System.Com.TYPEATTR@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.ReleaseTypeAttr(Windows.Win32.System.Com.TYPEATTR*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.ReleaseTypeAttr(Windows.Win32.System.Com.TYPEATTR*)">
            <summary>Releases a TYPEATTR previously returned by ITypeInfo::GetTypeAttr.</summary>
            <param name="pTypeAttr">The TYPEATTR to be freed.</param>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-releasetypeattr">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.ReleaseFuncDesc(Windows.Win32.System.Com.FUNCDESC@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.ReleaseFuncDesc(Windows.Win32.System.Com.FUNCDESC*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.ReleaseFuncDesc(Windows.Win32.System.Com.FUNCDESC*)">
            <summary>Releases a FUNCDESC previously returned by ITypeInfo::GetFuncDesc.</summary>
            <param name="pFuncDesc">The FUNCDESC to be freed.</param>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-releasefuncdesc">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.ReleaseVarDesc(Windows.Win32.System.Com.VARDESC@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.ReleaseVarDesc(Windows.Win32.System.Com.VARDESC*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeInfo.ReleaseVarDesc(Windows.Win32.System.Com.VARDESC*)">
            <summary>Releases a VARDESC previously returned by ITypeInfo::GetVarDesc.</summary>
            <param name="pVarDesc">The VARDESC to be freed.</param>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypeinfo-releasevardesc">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.ITypeInfo.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00020401-0000-0000-c000-000000000046}</value>
        </member>
        <member name="T:Windows.Win32.System.Com.IUnknown.CCW">
            <summary>
             Manual COM Callable Wrapper for <see cref="T:Windows.Win32.System.Com.IUnknown"/>.
            </summary>
            <remarks>
             <para>
              This is for test and debug scenarios only. It should not be used directly in the product.
             </para>
            </remarks>
            <devdoc>
             This is a simplified version of what <see cref="T:System.Runtime.InteropServices.ComWrappers"/> does. It is useful when we want to manage
             our own <see cref="M:Windows.Win32.System.Com.IUnknown.QueryInterface(System.Guid*,System.Void**)"/> handling for debugging and testing purposes.
            </devdoc>
        </member>
        <member name="M:Windows.Win32.System.Com.IUnknown.CCW.Create(Windows.Win32.System.Com.IUnknown.Interface)">
            <inheritdoc cref="T:Windows.Win32.System.Com.IUnknown.CCW"/>
            <summary>
             Creates a manual COM Callable Wrapper for the given <paramref name="object"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.IUnknown.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IUnknown.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Windows.Win32.System.Com.IUnknown.QueryInterface(System.Guid*,System.Void**)" -->
        <member name="M:Windows.Win32.System.Com.IUnknown.AddRef">
            <summary>Increments the reference count for an interface pointer to a COM object. You should call this method whenever you make a copy of an interface pointer.</summary>
            <returns>The method returns the new reference count. This value is intended to be used only for test purposes.</returns>
            <remarks>
            <para>A COM object uses a per-interface reference-counting mechanism to ensure that the object doesn't outlive references to it. You use **AddRef** to stabilize a copy of an interface pointer. It can also be called when the life of a cloned pointer must extend beyond the lifetime of the original pointer. The cloned pointer must be released by calling [IUnknown::Release](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)) on it. The internal reference counter that **AddRef** maintains should be a 32-bit unsigned integer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/unknwn/nf-unknwn-iunknown-addref#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IUnknown.Release">
            <summary>Decrements the reference count for an interface on a COM object.</summary>
            <returns>The method returns the new reference count. This value is intended to be used only for test purposes.</returns>
            <remarks>
            <para>When the reference count on an object reaches zero, **Release** must cause the interface pointer to free itself. When the released pointer is the only (formerly) outstanding reference to an object (whether the object supports single or multiple interfaces), the implementation must free the object. Note that aggregation of objects restricts the ability to recover interface pointers.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/unknwn/nf-unknwn-iunknown-release#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IUnknown.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000000-0000-0000-c000-000000000046}</value>
        </member>
        <member name="T:Windows.Win32.System.Com.Lifetime`2">
            <summary>
             Struct that handles managed object COM projection lifetime management.
            </summary>
            <typeparam name="TVTable">
             Struct that repesents the VTable for a COM pointer.
            </typeparam>
            <typeparam name="TObject">
             The type of object being projected.
            </typeparam>
        </member>
        <member name="M:Windows.Win32.System.Com.Lifetime`2.Allocate(`1,`0*)">
            <summary>
             Allocate a lifetime wrapper for the given <paramref name="object"/> with the given
             <paramref name="vtable"/>.
            </summary>
            <remarks>
             <para>
              This creates a <see cref="T:System.Runtime.InteropServices.GCHandle"/> to root the <paramref name="object"/> until ref
              counting has gone to zero.
             </para>
             <para>
              The <paramref name="vtable"/> should be fixed, typically as a static. Com calls always
              include the "this" pointer as the first argument.
             </para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.Lifetime`2.GetObject(System.Void*)">
            <summary>
             Get the object associated with this lifetime.
            </summary>
            <param name="this">
             The passed back "this" pointer that originally came from <see cref="M:Windows.Win32.System.Com.Lifetime`2.Allocate(`1,`0*)"/>.
            </param>
            <returns>The object associated with this lifetime, if any.</returns>
            <exception cref="T:System.InvalidOperationException">The handle was freed.</exception>
        </member>
        <member name="T:Windows.Win32.System.Com.SAFEARRAY">
            <summary>Represents a safe array.</summary>
            <remarks>
            <para>The array <b>rgsabound</b> is stored with the left-most dimension in rgsabound[0] and the right-most dimension in <c>rgsabound[cDims - 1]</c>. If an array was specified in a C-like syntax as a [2][5], it would have two elements in the <b>rgsabound</b> vector. Element 0 has an <b>lLbound</b> of 0 and a <b>cElements</b> of 2. Element 1 has an <b>lLbound</b> of 0 and a <b>cElements</b> of 5.</para>
            <para>The <b>fFeatures</b> flags describe attributes of an array that can affect how the array is released. The <b>fFeatures</b> field describes what type of data is stored in the <b>SAFEARRAY</b> and how the array is allocated. This allows freeing the array without referencing its containing variant.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-safearray#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.SAFEARRAY.GetBounds(System.Int32)">
            <summary>
             Gets the <see cref="T:Windows.Win32.System.Com.SAFEARRAYBOUND"/> of the <paramref name="dimension"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.SAFEARRAY.CreateEmpty(Windows.Win32.System.Variant.VARENUM)">
            <summary>
             Creates an empty one-dimensional SAFEARRAY of type <paramref name="arrayType"/>.
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.SAFEARRAY.cDims">
            <summary>The number of dimensions.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.SAFEARRAY.fFeatures">
            <summary>
            <para>Flags. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-safearray#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.SAFEARRAY.cbElements">
            <summary>The size of an array element.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.SAFEARRAY.cLocks">
            <summary>The number of times the array has been locked without a corresponding unlock.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.SAFEARRAY.pvData">
            <summary>The data.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.SAFEARRAY.rgsabound">
            <summary>One bound for each dimension.</summary>
        </member>
        <member name="M:Windows.Win32.System.Com.SAFEARRAY.SizeOf(System.Int32)">
            <summary>Computes the amount of memory that must be allocated to store this struct, including the specified number of elements in the variable length inline array at the end.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.SafeArrayScope`1">
            <summary>
             Helper to scope lifetime of a <see cref="T:Windows.Win32.System.Com.SAFEARRAY"/> created via
             <see cref="M:Windows.Win32.PInvokeCore.SafeArrayCreate(Windows.Win32.System.Variant.VARENUM,System.UInt32,Windows.Win32.System.Com.SAFEARRAYBOUND*)"/>
             Destroys the <see cref="T:Windows.Win32.System.Com.SAFEARRAY"/> (if any) when disposed. Note that this scope currently only works for a
             one dimensional <see cref="T:Windows.Win32.System.Com.SAFEARRAY"/>.
            </summary>
            <remarks>
             <para>
              Use in a <see langword="using" /> statement to ensure the <see cref="T:Windows.Win32.System.Com.SAFEARRAY"/> gets disposed.
             </para>
             <para>
              If the <see cref="T:Windows.Win32.System.Com.SAFEARRAY"/> you are intending to scope the lifetime of has type <see cref="F:Windows.Win32.System.Variant.VARENUM.VT_UNKNOWN"/>,
              use <see cref="T:Windows.Win32.System.Com.ComSafeArrayScope`1"/> for better usability.
             </para>
            </remarks>
        </member>
        <member name="P:Windows.Win32.System.Com.SafeArrayScope`1.Item(System.Int32)">
            <remarks>
             <para>
              A copy will be made of anything that is put into the <see cref="T:Windows.Win32.System.Com.SAFEARRAY"/>
              and anything the <see cref="T:Windows.Win32.System.Com.SAFEARRAY"/> gives out is a copy and has been add ref appropriately if applicable.
              Be sure to dispose of items that are given to the <see cref="T:Windows.Win32.System.Com.SAFEARRAY"/> if necessary. All
              items given out by the <see cref="T:Windows.Win32.System.Com.SAFEARRAY"/> should be disposed.
             </para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.System.Com.StructuredStorage.CA">
            <summary>
             Untyped representation of CA* typed arrays in Windows. <see cref="T:Windows.Win32.System.Com.StructuredStorage.CAUB"/>, etc.
            </summary>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.Next(System.Span{Windows.Win32.System.Com.STATSTG},System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.Next(System.UInt32,Windows.Win32.System.Com.STATSTG*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.Next(System.UInt32,Windows.Win32.System.Com.STATSTG*,System.UInt32*)">
            <summary>Retrieves a specified number of STATSTG structures, that follow in the enumeration sequence.</summary>
            <param name="celt">The number of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structures requested.</param>
            <param name="rgelt">An array of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structures returned.</param>
            <param name="pceltFetched">The number of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structures  retrieved in the <i>rgelt</i> parameter.</param>
            <returns>
            <para>This method supports the following return values: </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumstatstg-next">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.Skip(System.UInt32)">
            <summary>Skips a specified number of STATSTG structures in the enumeration sequence.</summary>
            <param name="celt">The number of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structures to skip.</param>
            <returns>
            <para>This method supports the following return values: | Return code | Description | |----------------|---------------| | S_OK | The specified number of **STATSTG** structures that were successfully skipped. | | S_FALSE | The number of **STATSTG** structures skipped is less than the *celt* parameter. |</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumstatstg-skip">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.Reset">
            <summary>Resets the enumeration sequence to the beginning of the STATSTG structure array.</summary>
            <returns>
            <para>This method supports the S_OK return value. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumstatstg-reset">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.Clone(Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG**)">
            <summary>Creates a new enumerator that contains the same enumeration state as the current STATSTG structure enumerator.</summary>
            <param name="ppenum">
            <para>A pointer to the variable that receives the  <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstatstg">IEnumSTATSTG</a> interface pointer. If the method is unsuccessful, the value of the <i>ppenum</i> parameter is undefined.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumstatstg-clone#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method supports the following return values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumstatstg-clone">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0000000d-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.CreateStream(System.String,Windows.Win32.System.Com.STGM,System.UInt32,System.UInt32,Windows.Win32.System.Com.IStream**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.CreateStream(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.STGM,System.UInt32,System.UInt32,Windows.Win32.System.Com.IStream**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.CreateStream(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.STGM,System.UInt32,System.UInt32,Windows.Win32.System.Com.IStream**)">
            <summary>Creates and opens a stream object with the specified name contained in this storage object.</summary>
            <param name="pwcsName">A pointer to a wide character null-terminated Unicode string that contains the name of the newly created stream. The name can be used later to open or reopen the stream. The name must not exceed 31 characters in length, not including the string terminator. The 000 through 01f characters, serving as the first character of the stream/storage name, are reserved for use by OLE. This is a compound file restriction, not a structured storage restriction.</param>
            <param name="grfMode">Specifies the access mode to use when opening the newly created stream. For more information and descriptions of the possible values, see <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM Constants</a>.</param>
            <param name="reserved1">Reserved for future use; must be zero.</param>
            <param name="reserved2">Reserved for future use; must be zero.</param>
            <param name="ppstm">
            <para>On return, pointer to the location of the new <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer. This is only valid if the operation is successful. When an error occurs, this parameter is set to <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-createstream#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The new stream was successfully created.| |E_PENDING | Asynchronous Storage only: Part or all of the necessary data is currently unavailable. | |STG_E_ACCESSDENIED | Not enough permissions to create stream.| |STG_E_FILEALREADYEXISTS | The name specified for the stream already exists in the storage object and the *grfMode* parameter includes the value STGM_FAILIFTHERE.| |STG_E_INSUFFICIENTMEMORY | The stream was not created due to a lack of memory.| |STG_E_INVALIDFLAG | The value specified for the *grfMode* parameter is not a valid **STGM** constants value.| |STG_E_INVALIDFUNCTION | The specified combination of flags in the *grfMode* parameter is not supported; for example, when this method is called without the STGM_SHARE_EXCLUSIVE flag.| |STG_E_INVALIDNAME | Invalid value for *pwcsName*.| |STG_E_INVALIDPOINTER | The pointer specified for the stream object was invalid.| |STG_E_INVALIDPARAMETER | One of the parameters was invalid.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.| |STG_E_TOOMANYOPENFILES | The stream was not created because there are too many open files.|</para>
            </returns>
            <remarks>
            <para>If a stream with the name specified in the <i>pwcsName</i> parameter already exists and the <i>grfMode</i> parameter includes the STGM_CREATE flag, the existing stream is replaced by a newly created one. Both the destruction of the old stream and the creation of the new stream object are subject to the transaction mode on the parent storage object. The COM-provided compound file implementation of the <b>IStorage::CreateStream</b> method does not support the following behaviors: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-createstream#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.OpenStream(System.String,Windows.Win32.System.Com.STGM,System.UInt32,Windows.Win32.System.Com.IStream**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.OpenStream(Windows.Win32.Foundation.PCWSTR,System.Void*,Windows.Win32.System.Com.STGM,System.UInt32,Windows.Win32.System.Com.IStream**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.OpenStream(Windows.Win32.Foundation.PCWSTR,System.Void*,Windows.Win32.System.Com.STGM,System.UInt32,Windows.Win32.System.Com.IStream**)">
            <summary>Opens an existing stream object within this storage object in the specified access mode.</summary>
            <param name="pwcsName">A pointer to a wide character null-terminated Unicode string that contains the name of the stream to open. The 000 through 01f characters, serving as the first character of the stream/storage name, are reserved for use by OLE. This is a compound file restriction, not a structured storage restriction.</param>
            <param name="reserved1">Reserved for future use; must be <b>NULL</b>.</param>
            <param name="grfMode">Specifies the access mode to be assigned to the open stream. For more information and descriptions of possible values, see <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM Constants</a>.  Other modes you choose must at least specify STGM_SHARE_EXCLUSIVE when calling this method in the compound file implementation.</param>
            <param name="reserved2">Reserved for future use; must be zero.</param>
            <param name="ppstm">
            <para>A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> pointer variable that receives the interface pointer to the newly opened stream object. If an error occurs, *<i>ppstm</i> must be set to <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-openstream#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The stream was successfully opened.| |E_PENDING | Asynchronous Storage only: Part or all of the stream data is currently unavailable. | |STG_E_ACCESSDENIED | Not enough permissions to open stream.| |STG_E_FILENOTFOUND | The stream with specified name does not exist.| |STG_E_INSUFFICIENTMEMORY | The stream was not opened due to a lack of memory.| |STG_E_INVALIDFLAG | The value specified for the *grfMode* parameter is not a valid **STGM** constants value.| |STG_E_INVALIDFUNCTION | The specified combination of flags in the *grfMode* parameter is not supported; for example, when this method is called without the STGM_SHARE_EXCLUSIVE flag.| |STG_E_INVALIDNAME | Invalid value for *pwcsName*.| |STG_E_INVALIDPOINTER | The pointer specified for the stream object was not valid.| |STG_E_INVALIDPARAMETER | One of the parameters was not valid.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.| |STG_E_TOOMANYOPENFILES | The stream was not opened because there are too many open files.|</para>
            </returns>
            <remarks><b>IStorage::OpenStream</b> opens an existing stream object within this storage object in the access mode specified in <i>grfMode</i>. There are restrictions on the permissions that can be given in <i>grfMode</i>. For example, the permissions on this storage object restrict the permissions on its streams. In general, access restrictions on streams need to be stricter than those on their parent storages. Compound-file streams must be opened with STGM_SHARE_EXCLUSIVE.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.CreateStorage(System.String,Windows.Win32.System.Com.STGM,System.UInt32,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IStorage**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.CreateStorage(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.STGM,System.UInt32,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IStorage**)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Windows.Win32.System.Com.StructuredStorage.IStorage.CreateStorage(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.STGM,System.UInt32,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IStorage**)" -->
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.OpenStorage(System.String,Windows.Win32.System.Com.StructuredStorage.IStorage*,Windows.Win32.System.Com.STGM,System.UInt16*@,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IStorage**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.OpenStorage(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.StructuredStorage.IStorage*,Windows.Win32.System.Com.STGM,System.UInt16**,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IStorage**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.OpenStorage(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.StructuredStorage.IStorage*,Windows.Win32.System.Com.STGM,System.UInt16**,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IStorage**)">
            <summary>Opens an existing storage object with the specified name in the specified access mode.</summary>
            <param name="pwcsName">A pointer to a wide character null-terminated Unicode string that contains the name of the storage object to open. The 000 through 01f characters, serving as the first character of the stream/storage name, are reserved for use by OLE. This is a compound file restriction, not a structured storage restriction. It is ignored if <i>pstgPriority</i> is non-<b>NULL</b>.</param>
            <param name="pstgPriority">Must be <b>NULL</b>. A non-<b>NULL</b> value will return STG_E_INVALIDPARAMETER.</param>
            <param name="grfMode">Specifies the access mode to use when opening the storage object. For descriptions of the possible values, see <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM Constants</a>. Other modes you choose must at least specify STGM_SHARE_EXCLUSIVE when calling this method.</param>
            <param name="snbExclude">Must be <b>NULL</b>. A non-<b>NULL</b> value will return STG_E_INVALIDPARAMETER.</param>
            <param name="reserved">Reserved for future use; must be zero.</param>
            <param name="ppstg">
            <para>When successful, pointer to the location of an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> pointer to the opened storage object. This parameter is set to <b>NULL</b> if an error occurs.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-openstorage#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The storage object was opened successfully.| |E_PENDING | Asynchronous Storage only: Part or all of the storage's data is currently unavailable. | |STG_E_ACCESSDENIED | Not enough permissions to open storage object.| |STG_E_FILENOTFOUND | The storage object with the specified name does not exist.| |STG_E_INSUFFICIENTMEMORY | The storage object was not opened due to a lack of memory.| |STG_E_INVALIDFLAG | The value specified for the *grfMode* parameter is not a valid **STGM** constants value.| |STG_E_INVALIDFUNCTION | The specified combination of flags in the *grfMode* parameter is not supported.| |STG_E_INVALIDNAME | Not a valid value for *pwcsName*.| |STG_E_INVALIDPOINTER | The pointer specified for the storage object was not valid.| |STG_E_INVALIDPARAMETER | One of the parameters was not valid.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.| |STG_E_TOOMANYOPENFILES | The storage object was not created because there are too many open files.| |STG_S_CONVERTED | The existing stream with the specified name was replaced with a new storage object containing a single stream called CONTENTS. In direct mode, the new storage is immediately written to disk. In transacted mode, the new storage is written to a temporary storage in memory and later written to disk when it is committed.|</para>
            </returns>
            <remarks>
            <para>If the <i>pstgPriority</i> parameter is <b>NULL</b>, it is ignored. If the <i>pstgPriority</i> parameter is not <b>NULL</b>, it is an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> pointer to a previous opening of an element of the storage object, usually one that was opened in priority mode. The storage object should be closed and reopened according to <i>grfMode</i>. When the <b>IStorage::OpenStorage</b> method returns, <i>pstgPriority</i> is no longer valid. Use the value supplied in the <i>ppstg</i> parameter. Storage objects can be opened with STGM_DELETEONRELEASE, in which case the object is destroyed when it receives its final release. This is useful for creating temporary storage objects.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-openstorage#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.CopyTo(System.ReadOnlySpan{System.Guid},System.UInt16**,Windows.Win32.System.Com.StructuredStorage.IStorage*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.CopyTo(System.UInt32,System.Guid*,System.UInt16**,Windows.Win32.System.Com.StructuredStorage.IStorage*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.CopyTo(System.UInt32,System.Guid*,System.UInt16**,Windows.Win32.System.Com.StructuredStorage.IStorage*)">
            <summary>Copies the entire contents of an open storage object to another storage object.</summary>
            <param name="ciidExclude">The number of elements in the array pointed to by <i>rgiidExclude</i>. If <i>rgiidExclude</i> is <b>NULL</b>, then <i>ciidExclude</i> is ignored.</param>
            <param name="rgiidExclude">
            <para>An array of interface identifiers (IIDs) that either the caller knows about and does not want copied or that the storage object does not support, but whose state the caller will later explicitly copy. The array can include <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a>, indicating that only stream objects are to be copied, and <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>, indicating that only storage objects are to be copied. An array length of zero indicates that only the state exposed by the <b>IStorage</b> object is to be copied; all other interfaces on the object are to be ignored. Passing <b>NULL</b> indicates that all interfaces on the object are to be copied.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-copyto#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="snbExclude">
            <para>A string name block (refer to <a href="https://docs.microsoft.com/windows/desktop/Stg/snb">SNB</a>) that specifies a block of storage or stream objects that are not to be copied to the destination. These elements are not created at the destination. If <b>IID_IStorage</b> is in the <i>rgiidExclude</i> array, this parameter is ignored. This parameter may be <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-copyto#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pstgDest">
            <para>A pointer to the open storage object into which this storage object is to be copied. The destination storage object can be a different implementation of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> interface from the source storage object. Thus, <b>IStorage::CopyTo</b> can use only publicly available methods of the destination storage object. If <i>pstgDest</i> is open in transacted mode, it can be reverted by calling its <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-revert">IStorage::Revert</a> method.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-copyto#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The storage object was successfully copied.| |E_PENDING | Asynchronous Storage only: Part or all of the data to be copied is currently unavailable. | |STG_E_ACCESSDENIED | The destination storage object is a child of the source storage object.| |STG_E_INSUFFICIENTMEMORY | The copy was not completed due to a lack of memory.| |STG_E_INVALIDPOINTER | The pointer specified for the storage object was not valid.| |STG_E_INVALIDPARAMETER | One of the parameters was not valid.| |STG_E_TOOMANYOPENFILES | The copy was not completed because there are too many open files.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.| |STG_E_MEDIUMFULL | The copy was not completed because the storage medium is full.|</para>
            </returns>
            <remarks>
            <para>This method merges elements contained in the source storage object with those already present in the destination. The layout of the destination storage object may differ from the source storage object. The copy process is recursive, invoking <b>IStorage::CopyTo</b> and <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-copyto">IStream::CopyTo</a> on the elements nested inside the source. When copying a stream on top of an existing stream with the same name, the existing stream is first removed and then replaced with the source stream. When copying a storage on top of an existing storage with the same name, the existing storage is not removed. As a result, after the copy operation, the destination <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> contains older elements, unless they were replaced by newer ones with the same names. A storage object may expose interfaces other than <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a>, including <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-irootstorage">IRootStorage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/propidl/nn-propidl-ipropertystorage">IPropertyStorage</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/propidl/nn-propidl-ipropertysetstorage">IPropertySetStorage</a>. The <i>rgiidExclude</i> parameter permits the exclusion of any or all of these additional interfaces from the copy operation. A caller with a newer or more efficient copy of an existing substorage or stream object may want to exclude the current versions of these objects from the copy operation. The <i>snbExclude</i> and <i>rgiidExclude</i> parameters provide two ways of excluding a storage objects existing storages or streams. <h3><a id="Note_to_Callers"></a><a id="note_to_callers"></a><a id="NOTE_TO_CALLERS"></a>Note to Callers</h3> The most common way to use the <b>IStorage::CopyTo</b> method is to copy everything from the source to the destination, as in most full-save and save-as operations. The following  example code shows how to copy everything  from the source storage object to the destination storage object.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-copyto#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.MoveElementTo(System.String,Windows.Win32.System.Com.StructuredStorage.IStorage*,System.String,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.MoveElementTo(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.StructuredStorage.IStorage*,Windows.Win32.Foundation.PCWSTR,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.MoveElementTo(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.StructuredStorage.IStorage*,Windows.Win32.Foundation.PCWSTR,System.UInt32)">
            <summary>The MoveElementTo method copies or moves a substorage or stream from this storage object to another storage object.</summary>
            <param name="pwcsName">Pointer to a wide character null-terminated Unicode string that contains the name of the element in this storage object to be moved or copied.</param>
            <param name="pstgDest"><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> pointer to the destination storage object.</param>
            <param name="pwcsNewName">Pointer to a wide character null-terminated unicode string that contains the new name for the element in its new storage object.</param>
            <param name="grfFlags">
            <para>Specifies whether the operation should be a move (STGMOVE_MOVE) or a copy (STGMOVE_COPY). See the <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ne-wtypes-stgmove">STGMOVE</a> enumeration.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-moveelementto#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The storage object was successfully copied or moved.| |E_PENDING | Asynchronous Storage only: Part or all of the element's data is currently unavailable. | |STG_E_ACCESSDENIED | The destination storage object is a child of the source storage object. Or, the destination object and element name are the same as the source object and element name. In other words, you cannot move an element to itself.| |STG_E_FILENOTFOUND | The element with the specified name does not exist.| |STG_E_FILEALREADYEXISTS | The specified file already exists.| |STG_E_INSUFFICIENTMEMORY | The copy or move was not completed due to a lack of memory.| |STG_E_INVALIDFLAG | The value for the *grfFlags* parameter is not valid.| |STG_E_INVALIDNAME | Not a valid value for *pwcsName*.| |STG_E_INVALIDPOINTER | The pointer specified for the storage object was not valid.| |STG_E_INVALIDPARAMETER | One of the parameters was not valid.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.| |STG_E_TOOMANYOPENFILES | The copy or move was not completed because there are too many open files.|</para>
            </returns>
            <remarks>
            <para>The <b>IStorage::MoveElementTo</b> method is typically the same as invoking the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-copyto">IStorage::CopyTo</a> method on the indicated element and then removing the source element. In this case, the <b>MoveElementTo</b> method uses only the publicly available functions of the destination storage object to carry out the move. If the source and destination storage objects have special knowledge about each other's implementation (they could, for example, be different instances of the same implementation), this method can be implemented more efficiently. Before calling this method, the element to be moved must be closed, and the destination storage must be open. Also, the destination object and element cannot be the same storage object/element name as the source of the move. That is, you cannot move an element to itself.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-moveelementto#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Commit(System.UInt32)">
            <summary>The Commit method ensures that any changes made to a storage object open in transacted mode are reflected in the parent storage.</summary>
            <param name="grfCommitFlags">
            <para>Controls how the changes are committed to the storage object. See the <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ne-wtypes-stgc">STGC</a> enumeration for a definition of these values.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-commit#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | Changes to the storage object were successfully committed to the parent level. If STGC_CONSOLIDATE was specified, the storage was successfully consolidated, or the storage was already too compact to consolidate further.| |STG_S_MULTIPLEOPENS | The commit operation succeeded, but the storage could not be consolidated because it had been opened multiple times using the STGM_NOSNAPSHOT flag.| |STG_S_CANNOTCONSOLIDATE | The commit operation succeeded, but the storage could not be consolidated due to an incorrect storage mode. For compound files, the storage may have been opened using the STGM_NOSCRATCH flag, or the storage may not be the outermost transacted level.| |STG_S_CONSOLIDATIONFAILED | The commit operation succeeded, but the storage could not be consolidated due to an internal error (for example, a memory allocation failure).| |E_PENDING | Asynchronous storage only: Part or all of the data to be committed is currently unavailable.| |STG_E_INVALIDFLAG | The value for the *grfCommitFlags* parameter is not valid.| |STG_E_INVALIDPARAMETER | One of the parameters was not valid.| |STG_E_NOTCURRENT | Another open instance of the storage object has committed changes. As a result, the current commit operation may overwrite previous changes.| |STG_E_MEDIUMFULL | No space left on device to commit.| |STG_E_TOOMANYOPENFILES | The commit operation could not be completed because there are too many open files.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para><b>IStorage::Commit</b> makes permanent changes to a storage object that is in transacted mode, in which changes are accumulated in a buffer, and not reflected in the storage object until there is a call to this method. The alternative is to open an object in direct mode, in which changes are immediately reflected in the storage object. An object opened in the direct mode does not require calling <b>IStorage::Commit</b> to make permanent changes in the storage object. Calling the <b>IStorage::Commit</b> method on a nonroot storage opened in direct mode has no effect. Opening a root storage object in direct mode ensures that changes in memory buffers are written to the underlying storage device. The commit operation publishes the current changes in this storage object and its children to the next level up in the storage hierarchy. To undo current changes before committing them, call <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-revert">IStorage::Revert</a> to roll back to the last-committed version. Calling <b>IStorage::Commit</b> has no effect on currently opened nested elements of this storage object. They remain valid and can be used. However, the <b>IStorage::Commit</b> method does not automatically commit changes to these nested elements. The commit operation publishes only known changes to the next higher level in the storage hierarchy. Thus, transactions to nested levels must be committed to this storage object before they can be committed to higher levels. In commit operations, you need to take steps to ensure that data is protected during the commit process: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-commit#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Revert">
            <summary>The Revert method discards all changes that have been made to the storage object since the last commit operation.</summary>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The revert operation was successful.| |E_PENDING | Asynchronous Storage only: Part or all of the storage's data is currently unavailable. | |STG_E_INSUFFICIENTMEMORY | The revert operation could not be completed due to a lack of memory.| |STG_E_TOOMANYOPENFILES | The revert operation could not be completed because there are too many open files.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para>For storage objects opened in transacted mode, the <b>IStorage::Revert</b> method discards any uncommitted changes to this storage object or changes that have been committed to this storage object from nested elements. After this method returns, any existing elements (substorages or streams) that were opened from the reverted storage object are invalid and can no longer be used. Specifying these reverted elements in any call except <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> returns the error STG_E_REVERTED This method has no effect on storage objects opened in direct mode.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-revert#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.EnumElements(Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.EnumElements(System.UInt32,System.Void*,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.EnumElements(System.UInt32,System.Void*,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG**)">
            <summary>The EnumElements method retrieves a pointer to an enumerator object that can be used to enumerate the storage and stream objects contained within this storage object.</summary>
            <param name="reserved1">Reserved for future use; must be zero.</param>
            <param name="reserved2">Reserved for future use; must be <b>NULL</b>.</param>
            <param name="reserved3">Reserved for future use; must be zero.</param>
            <param name="ppenum">
            <para>Pointer to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstatstg">IEnumSTATSTG</a>* pointer variable that receives the interface pointer to the new enumerator object.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-enumelements#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The enumerator object was successfully returned.| |E_PENDING | Asynchronous Storage only: Part or all of the element's data is currently unavailable.| |STG_E_INSUFFICIENTMEMORY | The enumerator object could not be created due to lack of memory.| |STG_E_INVALIDPARAMETER | One of the parameters was not valid.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para>The enumerator object returned by this method implements the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstatstg">IEnumSTATSTG</a> interface, one of the standard enumerator interfaces that contain the <b>Next</b>, <b>Reset</b>, <b>Clone</b>, and <b>Skip</b> methods. <b>IEnumSTATSTG</b> enumerates the data stored in an array of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structures. The storage object must be open in read mode to allow the enumeration of its elements. The enumerator object is permitted to enumerate the elements in any order. The enumerator object is also permitted to treat the enumeration as a snapshot or to have the enumeration reflect the current state of the storage object.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-enumelements#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.DestroyElement(System.String)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.DestroyElement(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Windows.Win32.System.Com.StructuredStorage.IStorage.DestroyElement(Windows.Win32.Foundation.PCWSTR)" -->
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.RenameElement(System.String,System.String)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.RenameElement(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.RenameElement(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR)">
            <summary>The RenameElement method renames the specified substorage or stream in this storage object.</summary>
            <param name="pwcsOldName">
            <para>Pointer to a wide character null-terminated Unicode string that contains the name of the substorage or stream to be changed. <div class="alert"><b>Note</b>  The <i>pwcsName</i>, created in <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-createstorage">CreateStorage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-createstream">CreateStream</a> must not exceed 31 characters in length, not including the string terminator.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-renameelement#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pwcsNewName">
            <para>Pointer to a wide character null-terminated unicode string that contains the new name for the specified substorage or stream. <div class="alert"><b>Note</b>  The <i>pwcsName</i>, created in <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-createstorage">CreateStorage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-createstream">CreateStream</a> must not exceed 31 characters in length, not including the string terminator.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-renameelement#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The element was successfully renamed.| |E_PENDING | Asynchronous Storage only: Part or all of the element's data is currently unavailable.| |STG_E_ACCESSDENIED | The caller does not have enough permissions for renaming the element.| |STG_E_FILENOTFOUND | The element with the specified old name does not exist.| |STG_E_FILEALREADYEXISTS | The element specified by the new name already exists.| |STG_E_INSUFFICIENTMEMORY | The element was not renamed due to a lack of memory.| |STG_E_INVALIDNAME | Invalid value for one of the names.| |STG_E_INVALIDPOINTER | The pointer specified for the element was not valid.| |STG_E_INVALIDPARAMETER | One of the parameters was not valid.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.| |STG_E_TOOMANYOPENFILES | The element was not renamed because there are too many open files.|</para>
            </returns>
            <remarks>
            <para><b>IStorage::RenameElement</b> renames the specified substorage or stream in this storage object. An element in a storage object cannot be renamed while it is open. The rename operation is subject to committing the changes if the storage is open in transacted mode. The <b>IStorage::RenameElement</b> method is not guaranteed to work in low memory with storage objects open in transacted mode. It may work in direct mode.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-renameelement#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.SetElementTimes(System.String,System.Runtime.InteropServices.ComTypes.FILETIME@,System.Runtime.InteropServices.ComTypes.FILETIME@,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.SetElementTimes(Windows.Win32.Foundation.PCWSTR,System.Runtime.InteropServices.ComTypes.FILETIME*,System.Runtime.InteropServices.ComTypes.FILETIME*,System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.SetElementTimes(Windows.Win32.Foundation.PCWSTR,System.Runtime.InteropServices.ComTypes.FILETIME*,System.Runtime.InteropServices.ComTypes.FILETIME*,System.Runtime.InteropServices.ComTypes.FILETIME*)">
            <summary>The SetElementTimes method sets the modification, access, and creation times of the specified storage element, if the underlying file system supports this method.</summary>
            <param name="pwcsName">The name of the storage object element whose times are to be modified. If <b>NULL</b>, the time is set on the root storage rather than one of its elements.</param>
            <param name="pctime">Either the new creation time for the element or <b>NULL</b> if the creation time is not to be modified.</param>
            <param name="patime">Either the new access time for the element or <b>NULL</b> if the access time is not to be modified.</param>
            <param name="pmtime">Either the new modification time for the element or <b>NULL</b> if the modification time is not to be modified.</param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The time values were successfully set.| |E_PENDING | Asynchronous Storage only: Part or all of the element's data is currently unavailable.| |STG_E_ACCESSDENIED | The caller does not have enough permissions for changing the element.| |STG_E_FILENOTFOUND | The element with the specified name does not exist.| |STG_E_INSUFFICIENTMEMORY | The element was not changed due to a lack of memory.| |STG_E_INVALIDNAME | Not a valid value for the element name.| |STG_E_INVALIDPOINTER | The pointer specified for the element was not valid.| |STG_E_INVALIDPARAMETER | One of the parameters was not valid.| |STG_E_TOOMANYOPENFILES | The element was not changed because there are too many open files.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para><b>SetElementTimes</b>  sets time statistics for the specified storage element within this storage object. Not all file systems support all the time values. This method sets those times that are supported and ignores the rest. Each time-value parameter can be <b>NULL</b>; indicating that no modification should occur. Call the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-stat">IStorage::Stat</a> method to retrieve these time values.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-setelementtimes#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.SetClass(System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.SetClass(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.SetClass(System.Guid*)">
            <summary>The SetClass method assigns the specified class identifier (CLSID) to this storage object.</summary>
            <param name="clsid">The CLSID that is to be associated with the storage object.</param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The CLSID was successfully assigned.| |E_PENDING | Asynchronous Storage only: Part or all of the storage's data is currently unavailable.| |STG_E_ACCESSDENIED | The caller does not have enough permissions for assigning a CLSID to the storage object.| |STG_E_MEDIUMFULL | Not enough space was left on device to complete the operation.| |STG_E_REVERTED | The storage object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para>When first created, a storage object has an associated CLSID of CLSID_NULL. Call <b>SetClass</b> to assign a CLSID to the storage object. Call the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-stat">IStorage::Stat</a> method to retrieve the current CLSID of a storage object.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-setclass#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.SetStateBits(System.UInt32,System.UInt32)">
            <summary>The SetStateBits method stores up to 32 bits of state information in this storage object.</summary>
            <param name="grfStateBits">Specifies the new values of the bits to set. No legal values are defined for these bits; they are all reserved for future use and must not be used by applications.</param>
            <param name="grfMask">A binary mask indicating which bits in <i>grfStateBits</i> are significant in this call.</param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The state information was successfully set.| |E_PENDING | Asynchronous Storage only: Part or all of the storage's data is currently unavailable. | |STG_E_ACCESSDENIED | The caller does not have enough permissions for changing this storage object.| |STG_E_INVALIDFLAG | The value for the grfStateBits or *grfMask* parameter is not valid.| |STG_E_INVALIDPARAMETER | One of the parameters was not valid.|</para>
            </returns>
            <remarks>The values for the state bits are not currently defined.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Stat(Windows.Win32.System.Com.STATSTG@,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Stat(Windows.Win32.System.Com.STATSTG*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Stat(Windows.Win32.System.Com.STATSTG*,System.UInt32)">
            <summary>The Stat method retrieves the STATSTG structure for this open storage object.</summary>
            <param name="pstatstg">
            <para>On return, pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structure where this method places information about the open storage object. This parameter is <b>NULL</b> if an error occurs.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-stat#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="grfStatFlag">
            <para>Specifies that some of the members in the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structure are not returned, thus saving a memory allocation operation. Values are taken from the <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ne-wtypes-statflag">STATFLAG</a> enumeration.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-stat#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The STATSTG structure was successfully returned at the specified location.| |E_PENDING | Asynchronous Storage only: Part or all of the storage's data is currently unavailable.| |STG_E_ACCESSDENIED | The caller does not have enough permissions for accessing statistics for this storage object.| |STG_E_INSUFFICIENTMEMORY | The STATSTG structure was not returned due to a lack of memory.| |STG_E_INVALIDFLAG | The value for the *grfStateFlag* parameter is not valid.| |STG_E_INVALIDPARAMETER | One of the parameters was not valid.|</para>
            </returns>
            <remarks>
            <para><b>IStorage::Stat</b> retrieves the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structure for the current storage object. The <b>STATSTG</b> structure contains statistical information about the storage object. <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-enumelements">IStorage::EnumElements</a> returns a pointer to an enumerator object. The enumerator object returned by this method implements the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstatstg">IEnumSTATSTG</a> interface, through which the data stored in the array of the <b>STATSTG</b> structures is enumerated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istorage-stat#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.StructuredStorage.IStorage.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0000000b-0000-0000-c000-000000000046}</value>
        </member>
        <member name="T:Windows.Win32.System.Com.StructuredStorage.PROPVARIANT">
            <summary>The PROPVARIANT structure is used in the ReadMultiple and WriteMultiple methods of IPropertyStorage to define the type tag and the value of a property in a property set.</summary>
            <remarks>
            <para>The <b>PROPVARIANT</b> structure can also hold a value of <b>VT_DECIMAL</b>:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/propidlbase/ns-propidlbase-propvariant#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.System.Com.BINDPTR">
            <summary>Describes a pointer.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-bindptr">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.BINDPTR.lpfuncdesc">
            <summary>Pointer to a function.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.BINDPTR.lpvardesc">
            <summary>Pointer to a variable, constant, or data member.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.BINDPTR.lptcomp">
            <summary>The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> that binds the pointer.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.BIND_OPTS">
            <summary>Contains parameters used during a moniker-binding operation.</summary>
            <remarks>
            <para>A <b>BIND_OPTS</b> structure is stored in a bind context; the same bind context is used by each component of a composite moniker during binding, allowing the same parameters to be passed to all components of a composite moniker. See <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> for more information about bind contexts. Moniker clients (use a moniker to acquire an interface pointer to an object) typically do not need to specify values for the members of this structure. The <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-createbindctx">CreateBindCtx</a> function creates a bind context with the bind options set to default values that are suitable for most situations; the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-bindmoniker">BindMoniker</a> function does the same thing when creating a bind context for use in binding a moniker. If you want to modify the values of these bind options, you can do so by passing a <b>BIND_OPTS</b> structure to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-setbindoptions">IBindCtx::SetBindOptions</a> method. Moniker implementers can pass a <b>BIND_OPTS</b> structure to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-getbindoptions">IBindCtx::GetBindOptions</a> method to retrieve the values of these bind options.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ns-objidl-bind_opts#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.BIND_OPTS.cbStruct">
            <summary>The size of this structure, in bytes.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.BIND_OPTS.grfFlags">
            <summary>Flags that control aspects of moniker binding operations. This value is any combination of the bit flags in the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-bind_flags">BIND_FLAGS</a> enumeration. The <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-createbindctx">CreateBindCtx</a> function initializes this member to zero.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.BIND_OPTS.grfMode">
            <summary>Flags that should be used when opening the file that contains the object identified by the moniker. Possible values  are the <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM constants</a>. The binding operation uses these flags in the call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersistfile-load">IPersistFile::Load</a> when loading the file. If the object is already running, these flags are ignored by the binding operation. The <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-createbindctx">CreateBindCtx</a> function initializes this field to STGM_READWRITE.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.BIND_OPTS.dwTickCountDeadline">
            <summary>
            <para>The clock time by which the caller would like the binding operation to be completed, in milliseconds. This member lets the caller limit the execution time of an operation when speed is of primary importance. A value of zero indicates that there is no deadline. Callers most often use this capability when calling the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-gettimeoflastchange">IMoniker::GetTimeOfLastChange</a> method, though it can be usefully applied to other operations as well. The <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-createbindctx">CreateBindCtx</a> function initializes this field to zero. Typical deadlines allow for a few hundred milliseconds of execution. This deadline is a recommendation, not a requirement; however, operations that exceed their deadline by a large amount may cause delays for the end user. Each moniker implementation should try to complete its operation by the deadline, or fail with the error MK_E_EXCEEDEDDEADLINE. If a binding operation exceeds its deadline because one or more objects that it needs are not running, the moniker implementation should register the objects responsible in the bind context using the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-registerobjectparam">IBindCtx::RegisterObjectParam</a>. The objects should be registered under the parameter names "ExceededDeadline", "ExceededDeadline1", "ExceededDeadline2", and so on. If the caller later finds the object in the running object table, the caller can retry the binding operation. The <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-gettickcount">GetTickCount</a> function indicates the number of milliseconds since system startup, and wraps back to zero after 2^31 milliseconds. Consequently, callers should be careful not to inadvertently pass a zero value (which indicates no deadline), and moniker implementations should be aware of clock wrapping problems.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ns-objidl-bind_opts#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.System.Com.BLOB">
            <summary>The BLOB structure (nspapi.h), which is derived from Binary Large Object, contains information about a block of data.</summary>
            <remarks>
            <para>The structure name <b>BLOB</b> comes from the acronym BLOB, which stands for Binary Large Object. This structure does not describe the nature of the data pointed to by <b>pBlobData</b>. <div class="alert"><b>Note</b>  Windows Sockets defines a similar <b>BLOB</b> structure in Wtypes.h. Using both header files in the same source code file creates redefinition–compile time errors.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/nspapi/ns-nspapi-blob#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.BLOB.cbSize">
            <summary>Size of the block of data pointed to by <b>pBlobData</b>, in bytes.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.BLOB.pBlobData">
            <summary>Pointer to a block of data.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.CALLCONV">
            <summary>Identifies the calling convention used by a member function described in the METHODDATA structure.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ne-oaidl-callconv">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_FASTCALL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_CDECL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_MSCPASCAL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_PASCAL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_MACPASCAL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_STDCALL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_FPFASTCALL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_SYSCALL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_MPWCDECL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_MPWPASCAL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CALLCONV.CC_MAX">
            <summary></summary>
        </member>
        <member name="T:Windows.Win32.System.Com.CLSCTX">
            <summary>Values that are used in activation calls to indicate the execution contexts in which an object is to be run.</summary>
            <remarks>
            <para>Values from the <b>CLSCTX</b> enumeration are used in activation calls (<a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance">CoCreateInstance</a>, <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstanceex">CoCreateInstanceEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject">CoGetClassObject</a>, and so on) to indicate the preferred execution contexts (in-process, local, or remote) in which an object is to be run. They are also used in calls to <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject">CoRegisterClassObject</a> to indicate the set of execution contexts in which a class object is to be made available for requests to construct instances (<b>IClassFactory::CreateInstance</b>). To indicate that more than one context is acceptable, you can combine multiple values with Boolean ORs. The contexts are tried in the order in which they are listed.</para>
            <para>Given a set of <b>CLSCTX</b> flags, the execution context to be used depends on the availability of registered class codes and other parameters according to the following algorithm.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_INPROC_SERVER">
            <summary>The code that creates and manages objects of this class is a DLL that runs in the same process as the caller of the function specifying the class context.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_INPROC_HANDLER">
            <summary>The code that manages objects of this class is an in-process handler. This is a DLL that runs in the client process and implements client-side structures of this class when instances of the class are accessed remotely.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_LOCAL_SERVER">
            <summary>The EXE code that creates and manages objects of this class runs on same machine but is loaded in a separate process space.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_INPROC_SERVER16">
            <summary>Obsolete.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_REMOTE_SERVER">
            <summary>A remote context. The <a href="https://docs.microsoft.com/windows/desktop/com/localserver32">LocalServer32</a> or <a href="https://docs.microsoft.com/windows/desktop/com/localservice">LocalService</a> code that creates and manages objects of this class is run on a different computer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_INPROC_HANDLER16">
            <summary>Obsolete.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_RESERVED1">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_RESERVED2">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_RESERVED3">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_RESERVED4">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_NO_CODE_DOWNLOAD">
            <summary>Disables the downloading of code from the directory service or the Internet. This flag cannot be set at the same time as CLSCTX_ENABLE_CODE_DOWNLOAD.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_RESERVED5">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_NO_CUSTOM_MARSHAL">
            <summary>Specify if you want the activation to fail if it uses custom marshalling.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_ENABLE_CODE_DOWNLOAD">
            <summary>Enables the downloading of code from the directory service or the Internet. This flag cannot be set at the same time as CLSCTX_NO_CODE_DOWNLOAD.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_NO_FAILURE_LOG">
            <summary>
            <para>The CLSCTX_NO_FAILURE_LOG can be used to override the logging of failures in <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstanceex">CoCreateInstanceEx</a>. If the ActivationFailureLoggingLevel is created, the following values can determine the status of event logging: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_DISABLE_AAA">
            <summary>
            <para>Disables activate-as-activator (AAA) activations for this activation only. This flag overrides the setting of the EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration. This flag cannot be set at the same time as CLSCTX_ENABLE_AAA. Any activation where a server process would be launched under the caller's identity is known as an activate-as-activator (AAA) activation. Disabling AAA activations allows an application that runs under a privileged account (such as LocalSystem) to help prevent its identity from being used to launch untrusted components. Library applications that use activation calls should always set this flag during those calls. This helps prevent the library application from being used in an escalation-of-privilege security attack. This is the only way to disable AAA activations in a library application because the EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration is applied only to the server process and not to the library application. <b>Windows 2000:  </b>This flag is not supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_ENABLE_AAA">
            <summary>
            <para>Enables activate-as-activator (AAA) activations for this activation only. This flag overrides the setting of the EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration. This flag cannot be set at the same time as CLSCTX_DISABLE_AAA. Any activation where a server process would be launched under the caller's identity is known as an activate-as-activator (AAA) activation. Enabling this flag allows an application to transfer its identity to an activated component. <b>Windows 2000:  </b>This flag is not supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_FROM_DEFAULT_CONTEXT">
            <summary>Begin this activation from the default context of the current apartment.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_ACTIVATE_X86_SERVER">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_ACTIVATE_32_BIT_SERVER">
            <summary>Activate or connect to a 32-bit version of the server; fail if one is not registered.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_ACTIVATE_64_BIT_SERVER">
            <summary>Activate or connect to a 64 bit version of the server; fail if one is not registered.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_ENABLE_CLOAKING">
            <summary>
            <para>When this flag is specified, COM uses the impersonation token of the thread, if one is present, for the activation request made by the thread. When this flag is not specified or if the thread does not have an impersonation token, COM uses the process token of the thread's process for the activation request made by the thread.</para>
            <para><b>Windows Vista or later:  </b>This flag is supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_APPCONTAINER">
            <summary>
            <para>Indicates activation is for an app container.</para>
            <para><div class="alert"><b>Note</b>  This flag is reserved for internal use and is not intended to be used directly from your code.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_ACTIVATE_AAA_AS_IU">
            <summary>
            <para>Specify this flag for Interactive User activation behavior for As-Activator servers. A strongly named Medium IL Windows Store app can use this flag to launch an "As Activator" COM server without a strong name. Also, you can use this flag to bind to a running instance of the COM server that's launched by a desktop application. The client must be Medium IL, it must be strongly named, which means that it has a SysAppID in the client token, it can't be in session 0,  and it must have the same user as the session ID's user in the client token. If  the server is out-of-process and "As Activator", it launches the server with the token of the client token's session user. This token won't be strongly named. If the server is out-of-process and RunAs "Interactive User", this flag has no effect. If the server is out-of-process and is any other RunAs type, the activation fails. This flag has no effect for in-process servers. Off-machine activations fail when they use this flag.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_RESERVED6">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_ACTIVATE_ARM32_SERVER">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Com.CLSCTX.CLSCTX_PS_DLL">
            <summary>
            <para>Used for loading Proxy/Stub DLLs.</para>
            <para><div class="alert"><b>Note</b>  This flag is reserved for internal use and is not intended to be used directly from your code.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.System.Com.DESCKIND">
            <summary>Identifies the type description being bound to.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ne-oaidl-desckind">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.DESCKIND.DESCKIND_NONE">
            <summary>No match was found.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DESCKIND.DESCKIND_FUNCDESC">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/ns-oaidl-funcdesc">FUNCDESC</a> was returned.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DESCKIND.DESCKIND_VARDESC">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/ns-oaidl-vardesc">VARDESC</a> was returned.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DESCKIND.DESCKIND_TYPECOMP">
            <summary>A TYPECOMP was returned.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DESCKIND.DESCKIND_IMPLICITAPPOBJ">
            <summary>An IMPLICITAPPOBJ was returned.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DESCKIND.DESCKIND_MAX">
            <summary>The end of the enum.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.DISPPARAMS">
            <summary>Contains the arguments passed to a method or property.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-dispparams">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.DISPPARAMS.rgvarg">
            <summary>
            <para>An array of arguments. **Note**: these arguments appear in reverse order</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-dispparams#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DISPPARAMS.rgdispidNamedArgs">
            <summary>The dispatch IDs of the named arguments.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DISPPARAMS.cArgs">
            <summary>The number of arguments.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DISPPARAMS.cNamedArgs">
            <summary>The number of named arguments.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.DVASPECT">
            <summary>Specifies the desired data or view aspect of the object when drawing or getting data.</summary>
            <remarks>
            <para>Values of this enumeration are used to define the <b>dwAspect</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure. Only one <b>DVASPECT</b> value can be used to specify a single presentation aspect in a <b>FORMATETC</b> structure. The <b>FORMATETC</b> structure is used in many OLE functions and interface methods that require information on data presentation.</para>
            <para>The default value of <b>MiscStatus</b> is used if a subkey corresponding to the specified <b>DVASPECT</b> is not found. To set an OLE control, specify DVASPECT==1. This will cause the following to occur in the registry:</para>
            <para><pre><b>HKEY_CLASSES_ROOT\CLSID\ . . .</b> <b>MiscStatus</b> = 1</pre></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypes/ne-wtypes-dvaspect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.DVASPECT.DVASPECT_CONTENT">
            <summary>Provides a representation of an object so it can be displayed as an embedded object inside of a container. This value is typically specified for compound document objects. The presentation can be provided for the screen or printer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DVASPECT.DVASPECT_THUMBNAIL">
            <summary>Provides a thumbnail representation of an object so it can be displayed in a browsing tool. The thumbnail is approximately a 120 by 120 pixel, 16-color (recommended) device-independent bitmap potentially wrapped in a metafile.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DVASPECT.DVASPECT_ICON">
            <summary>Provides an iconic representation of an object.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DVASPECT.DVASPECT_DOCPRINT">
            <summary>Provides a representation of the object on the screen as though it were printed to a printer using the <b>Print</b> command from the <b>File</b> menu. The described data may represent a sequence of pages.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.DVTARGETDEVICE">
            <summary>Specifies information about the target device for which data is being composed. DVTARGETDEVICE contains enough information about a Windows target device so a handle to a device context (HDC) can be created using the CreateDC function.</summary>
            <remarks>Some OLE 1 client applications incorrectly construct target devices by allocating too few bytes in the <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> structure for the <b>DVTARGETDEVICE</b>. They typically only supply the number of bytes in the <b>dmSize</b> member of <b>DEVMODE</b>. The number of bytes to be allocated should be the sum of <b>dmSize</b> + <b>dmDriverExtra</b>. When a call is made to the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createdca">CreateDC</a> function with an incorrect target device, the printer driver tries to access the additional bytes and unpredictable results can occur. To help protect against a crash and make the additional bytes available, OLE pads the size of OLE 2 target devices created from OLE 1 target devices.</remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.DVTARGETDEVICE.tdSize">
            <summary>The size, in bytes, of the <b>DVTARGETDEVICE</b> structure. The initial size is included so the structure can be copied more easily.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DVTARGETDEVICE.tdDriverNameOffset">
            <summary>The offset, in bytes, from the beginning of the structure to the device driver name, which is stored as a NULL-terminated string in the <b>tdData</b> buffer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DVTARGETDEVICE.tdDeviceNameOffset">
            <summary>The offset, in bytes, from the beginning of the structure to the device name, which is stored as a NULL-terminated string in the <b>tdData</b> buffer. This value can be zero to indicate no device name.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DVTARGETDEVICE.tdPortNameOffset">
            <summary>The offset, in bytes, from the beginning of the structure to the port name, which is stored as a NULL-terminated string in the <b>tdData</b> buffer. This value can be zero to indicate no port name.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DVTARGETDEVICE.tdExtDevmodeOffset">
            <summary>The offset, in bytes, from the beginning of the structure to the <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> structure retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/printdocs/documentproperties">DocumentProperties</a>.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.DVTARGETDEVICE.tdData">
            <summary>An array of bytes containing data for the target device. It is not necessary to include empty strings in <b>tdData</b> (for names where the offset value is zero).</summary>
        </member>
        <member name="M:Windows.Win32.System.Com.DVTARGETDEVICE.SizeOf(System.Int32)">
            <summary>Computes the amount of memory that must be allocated to store this struct, including the specified number of elements in the variable length inline array at the end.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.ELEMDESC">
            <summary>The ELEMDESC structure contains the type description and process-transfer information for a variable, a function, or a function parameter. (ELEMDESC)</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.ELEMDESC.tdesc">
            <summary>The type of the element.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.EXCEPINFO">
            <summary>Describes an exception that occurred during IDispatch::Invoke.</summary>
            <remarks>
            <para>Use the <b>pfnDeferredFillIn</b> field to enable an object to defer filling in the <b>bstrDescription</b>, <b>bstrHelpFile</b>, and <b>dwHelpContext</b> fields until they are needed. This field might be used, for example, if loading the string for the error is a time-consuming operation. To use deferred fill-in, the object puts a function pointer in this slot and does not fill any of the other fields except <b>wCode</b>, which is required. To get additional information, the caller passes the <b>EXCEPINFO</b> structure back to the <b>pexcepinfo</b> callback function, which fills in the additional information. When the ActiveX object and the ActiveX client are in different processes, the ActiveX object calls <b>pfnDeferredFillIn</b> before returning to the controller.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-excepinfo#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.EXCEPINFO.wCode">
            <summary>The error code. Error codes should be greater than 1000. Either this field or the scode field must be filled in; the other must be set to 0.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.EXCEPINFO.wReserved">
            <summary>Reserved. Should be 0.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.EXCEPINFO.bstrSource">
            <summary>The name of the exception source. Typically, this is an application name. This field should be filled in by the implementer of <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch</a>.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.EXCEPINFO.bstrDescription">
            <summary>The exception description to display. If no description is available, use null.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.EXCEPINFO.bstrHelpFile">
            <summary>The fully qualified help file path. If no Help is available, use null.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.EXCEPINFO.dwHelpContext">
            <summary>The help context ID.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.EXCEPINFO.pvReserved">
            <summary>Reserved. Must be null.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.EXCEPINFO.pfnDeferredFillIn">
            <summary>Provides deferred fill-in. If deferred fill-in is not desired, this field should be set to null.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.EXCEPINFO.scode">
            <summary>A return value that describes the error. Either this field or wCode (but not both) must be filled in; the other must be set to 0. (16-bit Windows versions only.)</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.FORMATETC">
            <summary>Represents a generalized clipboard format.</summary>
            <remarks>The <b>FORMATETC</b> structure is used by methods in the data transfer and presentation interfaces as a parameter specifying the data being transferred. For example, the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">IDataObject::GetData</a> method uses the <b>FORMATETC</b> structure to indicate exactly what kind of data the caller is requesting.</remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.FORMATETC.cfFormat">
            <summary>
            <para>The clipboard format of interest. There are three types of formats recognized by OLE:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ns-objidl-formatetc#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FORMATETC.ptd">
            <summary>A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-dvtargetdevice">DVTARGETDEVICE</a> structure containing information about the target device for which the data is being composed. A <b>NULL</b> value is used whenever the specified data format is independent of the target device or when the caller doesn't care what device is used. In the latter case, if the data requires a target device, the object should pick an appropriate default device (often the display for visual components). Data obtained from an object with a <b>NULL</b> target device, such as most metafiles, is independent of the target device. The resulting data is usually the same as it would be if the user chose the <b>Save As</b> command from the <b>File</b> menu and selected an interchange format.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FORMATETC.dwAspect">
            <summary>Indicates how much detail should be contained in the rendering. This parameter should be one of the <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ne-wtypes-dvaspect">DVASPECT</a> enumeration values. A single clipboard format can support multiple aspects or views of the object. Most data and presentation transfer and caching methods pass aspect information. For example, a caller might request an object's iconic picture, using the metafile clipboard format to retrieve it. Note that only one <b>DVASPECT</b> value can be used in <b>dwAspect</b>. That is, <b>dwAspect</b> cannot be the result of a Boolean OR operation on several <b>DVASPECT</b> values.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FORMATETC.lindex">
            <summary>Part of the aspect when the data must be split across page boundaries. The most common value is -1, which identifies all of the data. For the aspects DVASPECT_THUMBNAIL and DVASPECT_ICON, lindex is ignored.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FORMATETC.tymed">
            <summary>One of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-tymed">TYMED</a> enumeration constants which indicate the type of storage medium used to transfer the object's data. Data can be transferred using whatever medium makes sense for the object. For example, data can be passed using global memory, a disk file, or structured storage objects. For more information, see the <b>TYMED</b> enumeration.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.FUNCDESC">
            <summary>Describes a function. (FUNCDESC)</summary>
            <remarks>
            <para>The <b>cParams</b> field specifies the total number of required and optional parameters.</para>
            <para>The <b>cParamsOpt</b> field specifies the form of optional parameters accepted by the function, as follows: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-funcdesc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.memid">
            <summary>The function member ID.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.lprgscode">
            <summary>The status code.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.lprgelemdescParam">
            <summary>Description of the element.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.funckind">
            <summary>Indicates the type of function (virtual, static, or dispatch-only).</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.invkind">
            <summary>The invocation type. Indicates whether this is a property function, and if so, which type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.callconv">
            <summary>The calling convention.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.cParams">
            <summary>The total number of parameters.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.cParamsOpt">
            <summary>The number of optional parameters.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.oVft">
            <summary>For FUNC_VIRTUAL, specifies the offset in the VTBL.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.cScodes">
            <summary>The number of possible return values.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.elemdescFunc">
            <summary>The function return type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCDESC.wFuncFlags">
            <summary>The function flags. See <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/ne-oaidl-funcflags">FUNCFLAGS</a>.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.FUNCFLAGS">
            <summary>Specifies function flags.</summary>
            <remarks>
            <para>FUNCFLAG_FHIDDEN means that the property should never be shown in object browsers, property browsers, and so on. This function is useful for removing items from an object model. Code can bind to the member, but the user will never know that the member exists. FUNCFLAG_FNONBROWSABLE means that the property should not be displayed in a properties browser. It is used in circumstances in which an error would occur if the property were shown in a properties browser. FUNCFLAG_FRESRICTED means that macro-oriented programmers should not be allowed to access this member. These members are usually treated as _FHIDDEN by tools such as Visual Basic, with the main difference being that code cannot bind to those members.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ne-oaidl-funcflags#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FRESTRICTED">
            <summary>The function should not be accessible from macro languages. This flag is intended for system-level functions or functions that type browsers should not display.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FSOURCE">
            <summary>The function returns an object that is a source of events.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FBINDABLE">
            <summary>The function that supports data binding.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FREQUESTEDIT">
            <summary>When set, any call to a method that sets the property results first in a call to <b>IPropertyNotifySink::OnRequestEdit</b>. The implementation of <b>OnRequestEdit</b> determines if the call is allowed to set the property.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FDISPLAYBIND">
            <summary>The function that is displayed to the user as bindable. FUNC_FBINDABLE must also be set.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FDEFAULTBIND">
            <summary>The function that best represents the object. Only one function in a type information can have this attribute.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FHIDDEN">
            <summary>The function should not be displayed to the user, although it exists and is bindable.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FUSESGETLASTERROR">
            <summary>The function supports <b>GetLastError</b>. If an error occurs during the function, the caller can call <b>GetLastError</b> to retrieve the error code.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FDEFAULTCOLLELEM">
            <summary>Permits an optimization in which the compiler looks for a member named xyz on the type of abc. If such a member is found and is flagged as an accessor function for an element of the default collection, then a call is generated to that member function. Permitted on members in dispinterfaces and interfaces; not permitted on modules. For more information, refer to defaultcollelem in Type Libraries and the Object Description Language.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FUIDEFAULT">
            <summary>The type information member is the default member for display in the user interface.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FNONBROWSABLE">
            <summary>The property appears in an object browser, but not in a properties browser.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FREPLACEABLE">
            <summary>Tags the interface as having default behaviors.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCFLAGS.FUNCFLAG_FIMMEDIATEBIND">
            <summary>Mapped as individual bindable properties.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.FUNCKIND">
            <summary>Specifies the function type.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ne-oaidl-funckind">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCKIND.FUNC_VIRTUAL">
            <summary>The function is accessed the same as PUREVIRTUAL, except the function has an implementation.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCKIND.FUNC_PUREVIRTUAL">
            <summary>The function is accessed through the virtual function table (VTBL), and takes an implicit this pointer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCKIND.FUNC_NONVIRTUAL">
            <summary>The function is accessed by static address and takes an implicit this pointer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCKIND.FUNC_STATIC">
            <summary>The function is accessed by static address and does not take an implicit this pointer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.FUNCKIND.FUNC_DISPATCH">
            <summary>The function can be accessed only through <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch</a>.</summary>
        </member>
        <member name="M:Windows.Win32.System.Com.IAdviseSink.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IAdviseSink.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IAdviseSink.OnDataChange(Windows.Win32.System.Com.FORMATETC@,Windows.Win32.System.Com.STGMEDIUM@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IAdviseSink.OnDataChange(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IAdviseSink.OnDataChange(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)">
            <summary>Called by the server to notify a data object's currently registered advise sinks that data in the object has changed.</summary>
            <param name="pFormatetc">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure, which describes the format, target device, rendering, and storage information of the calling data object.</param>
            <param name="pStgmed">A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> structure, which defines the storage medium (global memory, disk file, storage object, stream object, GDI object, or undefined) and ownership of that medium for the calling data object.</param>
            <remarks>
            <para>Object handlers and containers of link objects implement <b>IAdviseSink::OnDataChange</b> to take appropriate steps when notified that data in the object has changed. They also must call <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-dadvise">IDataObject::DAdvise</a> to set up advisory connections with the objects in whose data they are interested. Containers that take advantage of OLE's caching support do not need to register for data-change notifications, because the information necessary to update the container's presentation of the object, including any changes in its data, are maintained in the object's cache. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> If you implement <b>IAdviseSink::OnDataChange</b> for a container, remember that this method is asynchronous and that making synchronous calls within asynchronous methods is not valid. Therefore, you cannot call <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">IDataObject::GetData</a> to obtain the data you need to update your object. Instead, you either post an internal message, or invalidate the rectangle for the changed data by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-invalidaterect">InvalidateRect</a> and waiting for a <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> message, at which point you are free to get the data and update the object. The data itself, which is valid only for the duration of the call, is passed using the storage medium pointed to by <i>pStgmed</i>. Since the caller owns the medium, the advise sink should not free it. Also, if <i>pStgmed</i> points to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface, the sink must not increment the reference count.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-iadvisesink-ondatachange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IAdviseSink.OnViewChange(System.UInt32,System.Int32)">
            <summary>Notifies an object's registered advise sinks that its view has changed.</summary>
            <param name="dwAspect">The aspect, or view, of the object. Contains a value taken from the <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ne-wtypes-dvaspect">DVASPECT</a> enumeration.</param>
            <param name="lindex">The portion of the view that has changed. Currently only -1 is valid.</param>
            <remarks>
            <para>Containers register to be notified when an object's view changes by calling <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-iviewobject-setadvise">IViewObject::SetAdvise</a>. After it is registered, the object will call the sink's <b>IAdviseSink::OnViewChange</b> method when appropriate. <b>OnViewChange</b> can be called when the object is in either the loaded or running state. Even though <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ne-wtypes-dvaspect">DVASPECT</a> values are individual flag bits, <i>dwAspect</i> may represent only one value. That is, <i>dwAspect</i> cannot contain the result of an OR operation combining two or more <b>DVASPECT</b> values. The <i>lindex</i> parameter represents the part of the aspect that is of interest. The value of <i>lindex</i> depends on the value of <i>dwAspect</i>. If <i>dwAspect</i> is either DVASPECT_THUMBNAIL or DVASPECT_ICON, <i>lindex</i> is ignored. If <i>dwAspect</i> is DVASPECT_CONTENT, <i>lindex</i> must be -1, which indicates that the entire view is of interest and is the only value that is currently valid.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-iadvisesink-onviewchange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IAdviseSink.OnRename(Windows.Win32.System.Com.IMoniker*)">
            <summary>Called by the server to notify all registered advisory sinks that the object has been renamed.</summary>
            <param name="pmk">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on the new full moniker of the object.</param>
            <remarks>OLE link objects normally implement <b>IAdviseSink::OnRename</b> to receive notification of a change in the name of a link source or its container. The object serving as the link source calls <b>OnRename</b> and passes its new full moniker to the object handler, which forwards the notification to the link object. In response, the link object must update its moniker. The link object, in turn, forwards the notification to its own container.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IAdviseSink.OnSave">
            <summary>Called by the server to notify all registered advisory sinks that the object has been saved.</summary>
            <remarks>Object handlers and link objects normally implement <b>IAdviseSink::OnSave</b> to receive notifications of when an object is saved to disk, either to its original storage (through a <b>Save</b> operation) or to new storage (through a <b>Save As</b> operation). Object Handlers and link objects register to be notified when an object is saved for the purpose of updating their caches, but then only if the advise flag passed during registration specifies ADVFCACHE_ONSAVE. Object handlers and link objects forward these notifications to their containers.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IAdviseSink.OnClose">
            <summary>Called by the server to notify all registered advisory sinks that the object has changed from the running to the loaded state.</summary>
            <remarks>
            <para>The <b>OnClose</b> notification indicates that an object is making the transition from the running to the loaded state, so its container can take appropriate measures to ensure an orderly shutdown. For example, an object handler must release its pointer to the object. If the object that is closing is the last open object supported by its OLE server application, the application can also shut down. In the case of a link object, the notification that the object is closing should always be interpreted to mean that the connection to the link source has broken.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-iadvisesink-onclose#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IAdviseSink.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0000010f-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IBindCtx.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.RegisterObjectBound(Windows.Win32.System.Com.IUnknown*)">
            <summary>Registers an object with the bind context to ensure that the object remains active until the bind context is released.</summary>
            <param name="punk">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface on the object that is being registered as bound.</param>
            <returns>This method can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>Those writing a new moniker class (through an implementation of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface) should call this method whenever the implementation activates an object. This happens most often in the course of binding a moniker, but it can also happen while retrieving a moniker's display name, parsing a display name into a moniker, or retrieving the time that an object was last modified. <b>RegisterObjectBound</b> calls <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> to create an additional reference to the object. You must, however, still release your own copy of the pointer. Calling this method twice for the same object creates two references to that object. You can release a reference obtained through a call to this method by calling <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-revokeobjectbound">IBindCtx::RevokeObjectBound</a>. All references held by the bind context are released when the bind context itself is released. Calling <b>RegisterObjectBound</b> to register an object with a bind context keeps the object active until the bind context is released. Reusing a bind context in a subsequent binding operation (either for another piece of the same composite moniker or for a different moniker) can make the subsequent binding operation more efficient because it doesn't have to reload that object. This, however, improves performance only if the subsequent binding operation requires some of the same objects as the original one, so you need to balance the possible performance improvement of reusing a bind context against the costs of keeping objects activated unnecessarily.</para>
            <para><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> does not provide a method to retrieve a pointer to an object registered using <b>RegisterObjectBound</b>. Assuming the object has registered itself with the running object table, moniker implementations can call <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-getobject">IRunningObjectTable::GetObject</a> to retrieve a pointer to the object.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ibindctx-registerobjectbound#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.RevokeObjectBound(Windows.Win32.System.Com.IUnknown*)">
            <summary>Removes the object from the bind context, undoing a previous call to RegisterObjectBound.</summary>
            <param name="punk">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/com/iunknown-and-interface-inheritance">IUnknown</a> interface on the object to be removed.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>You would rarely call this method. It is documented primarily for completeness.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.ReleaseBoundObjects">
            <summary>Releases all pointers to all objects that were previously registered by calls to RegisterObjectBound.</summary>
            <returns>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</returns>
            <remarks>
            <para>You rarely call this method directly. The system's <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> implementation calls this method when the pointer to the <b>IBindCtx</b> interface on the bind context is released (the bind context is released). If a bind context is not released, all of the registered objects remain active. If the same object has been registered more than once, this method calls the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> method on the object the number of times it was registered.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ibindctx-releaseboundobjects#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.SetBindOptions(Windows.Win32.System.Com.BIND_OPTS@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IBindCtx.SetBindOptions(Windows.Win32.System.Com.BIND_OPTS*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.SetBindOptions(Windows.Win32.System.Com.BIND_OPTS*)">
            <summary>Sets new values for the binding parameters stored in the bind context.</summary>
            <param name="pbindopts">A pointer to a [BIND_OPTS3](/windows/win32/api/objidl/ns-objidl-bind_opts3-r1) structure containing the binding parameters.</param>
            <returns>This method can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>A bind context contains a block of parameters that are common to most <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> operations. These parameters do not change as the operation moves from piece to piece of a composite moniker. Subsequent binding operations can call <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-getbindoptions">IBindCtx::GetBindOptions</a> to retrieve these parameters. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> This method can be called by moniker clients (those who use monikers to acquire interface pointers to objects). When you first create a bind context by using the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-createbindctx">CreateBindCtx</a> function, the fields of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-bind_opts">BIND_OPTS</a> structure are initialized to the following values:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ibindctx-setbindoptions#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.GetBindOptions(Windows.Win32.System.Com.BIND_OPTS@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IBindCtx.GetBindOptions(Windows.Win32.System.Com.BIND_OPTS*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.GetBindOptions(Windows.Win32.System.Com.BIND_OPTS*)">
            <summary>Retrieves the binding options stored in this bind context.</summary>
            <param name="pbindopts">A pointer to an initialized structure that receives the current binding parameters on return. See [BIND_OPTS3](/windows/win32/api/objidl/ns-objidl-bind_opts3-r1).</param>
            <returns>This method can return the standard return values E_UNEXPECTED and S_OK.</returns>
            <remarks>
            <para>A bind context contains a block of parameters that are common to most <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> operations and that do not change as the operation moves from piece to piece of a composite moniker. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> You typically call this method if you are writing your own moniker class. (This requires that you implement the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface.) You call this method to retrieve the parameters specified by the moniker client. You must initialize the structure that is filled in by this method. Before calling this method, you must initialize the <b>cbStruct</b> member to the size of the structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ibindctx-getbindoptions#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.GetRunningObjectTable(Windows.Win32.System.Com.IRunningObjectTable**)">
            <summary>Retrieves an interface pointer to the running object table (ROT) for the computer on which this bind context is running.</summary>
            <param name="pprot">The address of a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-irunningobjecttable">IRunningObjectTable</a>* pointer variable that receives the interface pointer to the running object table. If an error occurs, *<i>pprot</i> is set to <b>NULL</b>. If *<i>pprot</i> is non-<b>NULL</b>, the implementation calls <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the running table object; it is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>.</param>
            <returns>This method can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.</returns>
            <remarks>
            <para>The running object table is a globally accessible table on each computer. It keeps track of all the objects that are currently running on the computer. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Typically, those implementing a new moniker class (through an implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface) call <b>GetRunningObjectTable</b>. It is useful to call this method in an implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-bindtoobject">IMoniker::BindToObject</a> or <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-isrunning">IMoniker::IsRunning</a> to check whether an object is currently running. You can also call this method in the implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-gettimeoflastchange">IMoniker::GetTimeOfLastChange</a> to learn when a running object was last modified. Moniker implementations should call this method instead of using the <b>GetRunningObjectTable</b> function. This makes it possible for future implementations of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> to modify binding behavior.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ibindctx-getrunningobjecttable#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.RegisterObjectParam(Windows.Win32.Foundation.PWSTR,Windows.Win32.System.Com.IUnknown*)">
            <summary>Associates an object with a string key in the bind context's string-keyed table of pointers.</summary>
            <param name="pszKey">The <a href="https://docs.microsoft.com/windows/desktop/shell/str-constants">bind context string key</a> under which the object is being registered. Key string comparison is case-sensitive.</param>
            <param name="punk">
            <para>A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface on the object that is to be registered. The method calls <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the pointer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ibindctx-registerobjectparam#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>This method can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>A bind context maintains a table of interface pointers, each associated with a string key. This enables communication between a moniker implementation and the caller that initiated the binding operation. One party can store an interface pointer under a string known to both parties so that the other party can later retrieve it from the bind context. Binding operations subsequent to the use of this method can use <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-getobjectparam">IBindCtx::GetObjectParam</a> to retrieve the stored pointer. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> <b>RegisterObjectParam</b> is useful to those implementing a new moniker class (through an implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a>) and to moniker clients (those who use monikers to bind to objects). In implementing a new moniker class, you call this method when an error occurs during moniker binding to inform the caller of the cause of the error. The key that you would obtain with a call to this method would depend on the error condition. Following is a list of common moniker binding errors, describing for each the keys that would be appropriate: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ibindctx-registerobjectparam#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.GetObjectParam(Windows.Win32.Foundation.PWSTR,Windows.Win32.System.Com.IUnknown**)">
            <summary>Retrieves an interface pointer to the object associated with the specified key in the bind context's string-keyed table of pointers.</summary>
            <param name="pszKey">The <a href="https://docs.microsoft.com/windows/desktop/shell/str-constants">bind context string key</a> to be searched for. Key string comparison is case-sensitive.</param>
            <param name="ppunk">The address of an <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>* pointer variable that receives the interface pointer to the object associated with <i>pszKey</i>. When successful, the implementation calls <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on *<i>ppunk</i>. It is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If an error occurs, the implementation sets *<i>ppunk</i> to <b>NULL</b>.</param>
            <returns>If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.</returns>
            <remarks>
            <para>A bind context maintains a table of interface pointers, each associated with a string key. This enables communication between a moniker implementation and the caller that initiated the binding operation. One party can store an interface pointer under a string known to both parties so that the other party can later retrieve it from the bind context. The pointer this method retrieves must have previously been inserted into the table using the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-registerobjectparam">IBindCtx::RegisterObjectParam</a> method. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Objects using monikers to locate other objects can call this method when a binding operation fails to get specific information about the error that occurred. Depending on the error, it may be possible to correct the situation and retry the binding operation. See <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-registerobjectparam">IBindCtx::RegisterObjectParam</a> for more information. Moniker implementations can call this method to handle situations where a caller initiates a binding operation and requests specific information. By convention, the implementer should use key names that begin with the string form of the CLSID of a moniker class. (See the <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-stringfromclsid">StringFromCLSID</a> function.)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ibindctx-getobjectparam#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.EnumObjectParam(Windows.Win32.System.Com.IEnumString**)">
            <summary>Retrieves a pointer to an interface that can be used to enumerate the keys of the bind context's string-keyed table of pointers.</summary>
            <param name="ppenum">The address of an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstring">IEnumString</a>* pointer variable that receives the interface pointer to the enumerator. If an error occurs, *<i>ppenum</i> is set to <b>NULL</b>. If *<i>ppenum</i> is non-<b>NULL</b>, the implementation calls <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on *<i>ppenum</i>; it is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>.</param>
            <returns>This method can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>The keys returned by the enumerator are the ones previously specified in calls to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-registerobjectparam">IBindCtx::RegisterObjectParam</a>. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> A bind context maintains a table of interface pointers, each associated with a string key. This enables communication between a moniker implementation and the caller that initiated the binding operation. One party can store an interface pointer under a string known to both parties so that the other party can later retrieve it from the bind context. In the system implementation of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface, this method is not implemented. Therefore, calling this method results in a return value of E_NOTIMPL.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ibindctx-enumobjectparam#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IBindCtx.RevokeObjectParam(Windows.Win32.Foundation.PWSTR)">
            <summary>Removes the specified key and its associated pointer from the bind context's string-keyed table of objects. The key must have previously been inserted into the table with a call to RegisterObjectParam.</summary>
            <param name="pszKey">The <a href="https://docs.microsoft.com/windows/desktop/shell/str-constants">bind context string key</a> to be removed. Key string comparison is case-sensitive.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>A bind context maintains a table of interface pointers, each associated with a string key. This enables communication between a moniker implementation and the caller that initiated the binding operation. One party can store an interface pointer under a string known to both parties so that the other party can later retrieve it from the bind context. This method is used to remove an entry from the table. If the specified key is found, the bind context also releases its reference to the object.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ibindctx-revokeobjectparam#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IBindCtx.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0000000e-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.GetData(Windows.Win32.System.Com.FORMATETC@,Windows.Win32.System.Com.STGMEDIUM@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.GetData(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.GetData(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)">
            <summary>Called by a data consumer to obtain data from a source data object.</summary>
            <param name="pformatetcIn">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure that defines the format, medium, and target device to use when passing the data. It is possible to specify more than one medium by using the Boolean OR operator, allowing the method to choose the best medium among those specified.</param>
            <param name="pmedium">A pointer to the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> structure that indicates the storage medium containing the returned data through its tymed member, and the responsibility for releasing the medium through the value of its <b>pUnkForRelease</b> member. If <b>pUnkForRelease</b> is <b>NULL</b>, the receiver of the medium is responsible for releasing it; otherwise, <b>pUnkForRelease</b> points to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> on the appropriate object so its <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> method can be called. The medium must be allocated and filled in by <b>GetData</b>.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>A data consumer calls <b>GetData</b> to retrieve data from a data object, conveyed through a storage medium (defined through the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> structure). <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> You can specify more than one acceptable <b>tymed</b> medium with the Boolean OR operator. <b>GetData</b> must choose from the OR'd values the medium that best represents the data, do the allocation, and indicate responsibility for releasing the medium. Data transferred across a stream extends from position zero of the stream pointer through to the position immediately before the current stream pointer (that is, the stream pointer position upon exit). <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> <b>GetData</b> must check all fields in the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure. It is important that <b>GetData</b> render the requested aspect and, if possible, use the requested medium. If the data object cannot comply with the information specified in the <b>FORMATETC</b>, the method should return DV_E_FORMATETC. If an attempt to allocate the medium fails, the method should return STG_E_MEDIUMFULL. It is important to fill in all of the fields in the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> structure. Although the caller can specify more than one medium for returning the data, <b>GetData</b> can provide only one medium. If the initial transfer fails with the selected medium, this method can be implemented to try one of the other media specified before returning an error.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-idataobject-getdata#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.GetDataHere(Windows.Win32.System.Com.FORMATETC@,Windows.Win32.System.Com.STGMEDIUM@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.GetDataHere(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.GetDataHere(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)">
            <summary>Called by a data consumer to obtain data from a source data object. This method differs from the GetData method in that the caller must allocate and free the specified storage medium.</summary>
            <param name="pformatetc">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure that defines the format, medium, and target device to use when passing the data. Only one medium can be specified in <b>tymed</b>, and only the following values are valid: TYMED_ISTORAGE, TYMED_ISTREAM, TYMED_HGLOBAL, or TYMED_FILE.</param>
            <param name="pmedium">A pointer to the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> structure that defines the storage medium containing the data being transferred. The medium must be allocated by the caller and filled in by <b>GetDataHere</b>. The caller must also free the medium. The implementation of this method must always supply a value of <b>NULL</b> for the <b>punkForRelease</b> member of the <b>STGMEDIUM</b> structure to which this parameter points.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The <b>GetDataHere</b> method is similar to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">IDataObject::GetData</a>, except that the caller must both allocate and free the medium specified in <i>pmedium</i>. <b>GetDataHere</b> renders the data described in a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure and copies the data into that caller-provided <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> structure. For example, if the medium is TYMED_HGLOBAL, this method cannot resize the medium or allocate a new hGlobal. Some media are not appropriate in a call to <b>GetDataHere</b>, including GDI types such as metafiles. The <b>GetDataHere</b> method cannot put data into a caller-provided metafile. In general, the only storage media it is necessary to support in this method are TYMED_ISTORAGE, TYMED_ISTREAM, and TYMED_FILE. When the transfer medium is a stream, OLE makes assumptions about where the data is being returned and the position of the stream's seek pointer. In a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">GetData</a> call, the data returned is from stream position zero through just before the current seek pointer of the stream (that is, the position on exit). For <b>GetDataHere</b>, the data returned is from the stream position on entry through just before the position on exit.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-idataobject-getdatahere#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.QueryGetData(Windows.Win32.System.Com.FORMATETC@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.QueryGetData(Windows.Win32.System.Com.FORMATETC*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.QueryGetData(Windows.Win32.System.Com.FORMATETC*)">
            <summary>Determines whether the data object is capable of rendering the data as specified. Objects attempting a paste or drop operation can call this method before calling IDataObject::GetData to get an indication of whether the operation may be successful.</summary>
            <param name="pformatetc">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure defining the format, medium, and target device to use for the query.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>The client of a data object calls <b>QueryGetData</b> to determine whether passing the specified <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure to a subsequent call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">IDataObject::GetData</a> is likely to be successful. A successful return from this method does not necessarily ensure the success of the subsequent paste or drop operation.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.GetCanonicalFormatEtc(Windows.Win32.System.Com.FORMATETC@,Windows.Win32.System.Com.FORMATETC@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.GetCanonicalFormatEtc(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.FORMATETC*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.GetCanonicalFormatEtc(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.FORMATETC*)">
            <summary>Provides a potentially different but logically equivalent FORMATETC structure. You use this method to determine whether two different FORMATETC structures would return the same data, removing the need for duplicate rendering.</summary>
            <param name="pformatectIn">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure that defines the format, medium, and target device that the caller would like to use to retrieve data in a subsequent call such as <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">IDataObject::GetData</a>. The <b>tymed</b> member is not significant in this case and should be ignored.</param>
            <param name="pformatetcOut">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure that contains the most general information possible for a specific rendering, making it canonically equivalent to <i>pformatetcIn</i>. The caller must allocate this structure and the <b>GetCanonicalFormatEtc</b> method must fill in the data. To retrieve data in a subsequent call like <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">IDataObject::GetData</a>, the caller uses the specified value of <i>pformatetcOut</i>, unless the value specified is <b>NULL</b>. This value is <b>NULL</b> if the method returns DATA_S_SAMEFORMATETC. The <b>tymed</b> member is not significant in this case and should be ignored.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>If a data object can supply exactly the same data for more than one requested <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure, <b>GetCanonicalFormatEtc</b> can supply a "canonical", or standard <b>FORMATETC</b> that gives the same rendering as a set of more complicated <b>FORMATETC</b> structures. For example, it is common for the data returned to be insensitive to the target device specified in any one of a set of otherwise similar <b>FORMATETC</b> structures. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> A call to this method can determine whether two calls to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">IDataObject::GetData</a> on a data object, specifying two different <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structures, would actually produce the same renderings, thus eliminating the need for the second call and improving performance. If the call to <b>GetCanonicalFormatEtc</b> results in a canonical format being written to the <i>pformatetcOut</i> parameter, the caller then uses that structure in a subsequent call to <b>IDataObject::GetData</b>. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Conceptually, it is possible to think of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structures in groups defined by a canonical <b>FORMATETC</b> that provides the same results as each of the group members. In constructing the canonical <b>FORMATETC</b>, you should make sure it contains the most general information possible that still produces a specific rendering. For data objects that never provide device-specific renderings, the simplest implementation of this method is to copy the input <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> to the output <b>FORMATETC</b>, store a <b>NULL</b> in the <b>ptd</b> member of the output <b>FORMATETC</b>, and return DATA_S_SAMEFORMATETC.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-idataobject-getcanonicalformatetc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.SetData(Windows.Win32.System.Com.FORMATETC@,Windows.Win32.System.Com.STGMEDIUM@,Windows.Win32.Foundation.BOOL)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.SetData(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*,Windows.Win32.Foundation.BOOL)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.SetData(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*,Windows.Win32.Foundation.BOOL)">
            <summary>Called by an object containing a data source to transfer data to the object that implements this method.</summary>
            <param name="pformatetc">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure defining the format used by the data object when interpreting the data contained in the storage medium.</param>
            <param name="pmedium">A pointer to the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> structure defining the storage medium in which the data is being passed.</param>
            <param name="fRelease">If <b>TRUE</b>, the data object called, which implements <b>SetData</b>, owns the storage medium after the call returns. This means it must free the medium after it has been used by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-releasestgmedium">ReleaseStgMedium</a> function. If <b>FALSE</b>, the caller retains ownership of the storage medium and the data object called uses the storage medium for the duration of the call only.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><b>SetData</b> allows another object to attempt to send data to the implementing data object. A data object implements this method if it supports receiving data from another object. If it does not support this, it should be implemented to return E_NOTIMPL. The caller allocates the storage medium indicated by the <i>pmedium</i> parameter, in which the data is passed. The data object called does not take ownership of the data until it has successfully received it and no error code is returned. The value of the <i>fRelease</i> parameter indicates the ownership of the medium after the call returns. <b>FALSE</b> indicates the caller still owns the medium, and the data object only has the use of it during the call; <b>TRUE</b> indicates that the data object now owns it and must release it when it is no longer needed. The type of medium specified in the <i>pformatetc</i> and <i>pmedium</i> parameters must be the same. For example, one cannot be a global handle and the other a stream.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-idataobject-setdata#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.EnumFormatEtc(System.UInt32,Windows.Win32.System.Com.IEnumFORMATETC**)">
            <summary>Creates an object to enumerate the formats supported by a data object.</summary>
            <param name="dwDirection">
            <para>The direction of the data.  Possible values come from the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-datadir">DATADIR</a> enumeration. The value DATADIR_GET enumerates the formats that can be passed in to a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-getdata">IDataObject::GetData</a>. The value DATADIR_SET enumerates those formats that can be passed in to a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-setdata">IDataObject::SetData</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="ppenumFormatEtc">A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumformatetc">IEnumFORMATETC</a> pointer variable that receives the interface pointer to the new enumerator object.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><b>EnumFormatEtc</b> creates an enumerator object that can be used to determine all of the ways the data object can describe data in a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure, and provides a pointer to its <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumformatetc">IEnumFORMATETC</a> interface. This is one of the standard enumerator interfaces. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Having obtained the pointer, the caller can enumerate the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structures by calling the enumeration methods of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumformatetc">IEnumFORMATETC</a>. Because the formats can change over time, there is no guarantee that an enumerated format is currently supported because the formats can change over time. Accordingly, applications should treat the enumeration as a hint of the format types that can be passed. The caller is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> when it is finished with the enumerator. <b>EnumFormatEtc</b> is called when one of the following actions occurs: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.DAdvise(Windows.Win32.System.Com.FORMATETC@,System.UInt32,Windows.Win32.System.Com.IAdviseSink*,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.DAdvise(Windows.Win32.System.Com.FORMATETC*,System.UInt32,Windows.Win32.System.Com.IAdviseSink*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.DAdvise(Windows.Win32.System.Com.FORMATETC*,System.UInt32,Windows.Win32.System.Com.IAdviseSink*,System.UInt32*)">
            <summary>Called by an object supporting an advise sink to create a connection between a data object and the advise sink. This enables the advise sink to be notified of changes in the data of the object.</summary>
            <param name="pformatetc">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure that defines the format, target device, aspect, and medium that will be used for future notifications. For example, one sink may want to know only when the bitmap representation of the data in the data object changes. Another sink may be interested in only the metafile format of the same object. Each advise sink is notified when the data of interest changes. This data is passed back to the advise sink when notification occurs.</param>
            <param name="advf">
            <para>A group of flags for controlling the advisory connection. Possible values are from the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-advf">ADVF</a> enumeration. However, only some of the possible <b>ADVF</b> values are relevant for this method. The following table briefly describes the relevant values. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-idataobject-dadvise#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pAdvSink">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-iadvisesink">IAdviseSink</a> interface on the advisory sink that will receive the change notification.</param>
            <param name="pdwConnection">A token that identifies this connection. You can use this token later to delete the advisory connection (by passing it to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-dunadvise">IDataObject::DUnadvise</a>). If this value is 0, the connection was not established.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><b>DAdvise</b> creates a change notification connection between a data object and the caller. The caller provides an advisory sink to which the notifications can be sent when the object's data changes. Objects used simply for data transfer typically do not support advisory notifications and return OLE_E_ADVISENOTSUPPORTED from <b>DAdvise</b>. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> The object supporting the advise sink calls <b>DAdvise</b> to set up the connection, specifying the format, aspect, medium, and/or target device of interest in the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure passed in. If the data object does not support one or more of the requested attributes or the sending of notifications at all, it can refuse the connection by returning OLE_E_ADVISENOTSUPPORTED. Containers of linked objects can set up advisory connections directly with the bound link source or indirectly through the standard OLE link object that manages the connection. Connections set up with the bound link source are not automatically deleted. The container must explicitly call <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-dunadvise">IDataObject::DUnadvise</a> on the bound link source to delete an advisory connection. The OLE link object, manipulated through the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-iolelink">IOleLink</a> interface, is implemented in the default handler. Connections set up through the OLE link object are destroyed when the link object is deleted. The OLE default link object creates a "wildcard advise" with the link source so OLE can maintain the time of last change. This advise is specifically used to note the time that anything changed. OLE ignores all data formats that may have changed, noting only the time of last change. To allow wildcard advises, set the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> members as follows before calling <b>DAdvise</b>:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-idataobject-dadvise#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.DUnadvise(System.UInt32)">
            <summary>Destroys a notification connection that had been previously set up.</summary>
            <param name="dwConnection">A token that specifies the connection to be removed. Use the value returned by <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-dadvise">IDataObject::DAdvise</a> when the connection was originally established.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>This methods destroys a notification created with a call to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-dadvise">IDataObject::DAdvise</a> method. If the advisory connection being deleted was initially set up by delegating the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-dadvise">IDataObject::DAdvise</a> call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataadviseholder-advise">IDataAdviseHolder::Advise</a>, you must delegate this call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataadviseholder-unadvise">IDataAdviseHolder::Unadvise</a> to delete it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-idataobject-dunadvise#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IDataObject.EnumDAdvise(Windows.Win32.System.Com.IEnumSTATDATA**)">
            <summary>Creates an object that can be used to enumerate the current advisory connections.</summary>
            <param name="ppenumAdvise">A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstatdata">IEnumSTATDATA</a> pointer variable that receives the interface pointer to the new enumerator object. If the implementation sets *<i>ppenumAdvise</i> to <b>NULL</b>, there are no connections to advise sinks at this time.</param>
            <returns>
            <para>This method returns S_OK if the enumerator object is successfully instantiated or there are no connections. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The enumerator object created by this method implements the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstatdata">IEnumSTATDATA</a> interface. <b>IEnumSTATDATA</b> permits the enumeration of the data stored in an array of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statdata">STATDATA</a> structures. Each of these structures provides information on a single advisory connection, and includes <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> and <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-advf">ADVF</a> information, as well as the pointer to the advise sink and the token representing the connection. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> It is recommended that you use the OLE data advise holder object to handle advisory connections. With the pointer obtained through a call to <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-createdataadviseholder">CreateDataAdviseHolder</a>, implementing <b>IDataObject::EnumDAdvise</b> becomes a simple matter of delegating the call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataadviseholder-enumadvise">IDataAdviseHolder::EnumAdvise</a>. This creates the enumerator and supplies the pointer to the OLE implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstatdata">IEnumSTATDATA</a>. At that point, you can call its methods to enumerate the current advisory connections.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-idataobject-enumdadvise#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IDataObject.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0000010e-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumFORMATETC.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumFORMATETC.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumFORMATETC.Next(System.Span{Windows.Win32.System.Com.FORMATETC},System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumFORMATETC.Next(System.UInt32,Windows.Win32.System.Com.FORMATETC*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumFORMATETC.Next(System.UInt32,Windows.Win32.System.Com.FORMATETC*,System.UInt32*)">
            <summary>Retrieves the specified number of items in the enumeration sequence. (IEnumFORMATETC.Next)</summary>
            <param name="celt">The number of items to be retrieved. If there are fewer than the requested number of items left in the sequence, this method retrieves the remaining elements.</param>
            <param name="rgelt">
            <para>An array of enumerated items. The enumerator is responsible for allocating any memory, and the caller is responsible for freeing it. If <i>celt</i> is greater than 1, the caller must also pass a non-<b>NULL</b> pointer passed to <i>pceltFetched</i> to know how many pointers to release.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumformatetc-next#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pceltFetched">The number of items that were retrieved. This parameter is always less than or equal to the number of items requested. This parameter can be <b>NULL</b> if <i>celt</i> is 1.</param>
            <returns>If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumformatetc-next">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumFORMATETC.Skip(System.UInt32)">
            <summary>Skips over the specified number of items in the enumeration sequence. (IEnumFORMATETC.Skip)</summary>
            <param name="celt">The number of items to be skipped.</param>
            <returns>If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumformatetc-skip">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumFORMATETC.Reset">
            <summary>Resets the enumeration sequence to the beginning. (IEnumFORMATETC.Reset)</summary>
            <returns>This method returns S_OK on success.</returns>
            <remarks>There is no guarantee that the same set of objects will be enumerated after the reset operation has completed. A static collection is reset to the beginning, but it can be too expensive for some collections, such as files in a directory, to guarantee this condition.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumFORMATETC.Clone(Windows.Win32.System.Com.IEnumFORMATETC**)">
            <summary>Creates a new enumerator that contains the same enumeration state as the current one. (IEnumFORMATETC.Clone)</summary>
            <param name="ppenum">Address of an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumformatetc">IEnumFORMATETC</a> pointer variable that receives the interface pointer to the enumeration object. If the method is unsuccessful, the value of this output variable is undefined.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumformatetc-clone">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IEnumFORMATETC.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000103-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumMoniker.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumMoniker.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumMoniker.Next(System.UInt32,Windows.Win32.System.Com.IMoniker**,System.UInt32*)">
            <summary>Retrieves the specified number of items in the enumeration sequence. (IEnumMoniker.Next)</summary>
            <param name="celt">The number of items to be retrieved. If there are fewer than the requested number of items left in the sequence, this method retrieves the remaining elements.</param>
            <param name="rgelt">
            <para>An array of enumerated items. The enumerator is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a>, and the caller is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> through each pointer enumerated. If <i>celt</i> is greater than 1, the caller must also pass a non-<b>NULL</b> pointer passed to <i>pceltFetched</i> to know how many pointers to release.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienummoniker-next#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pceltFetched">The number of items that were retrieved. This parameter is always less than or equal to the number of items requested. This parameter can be <b>NULL</b> if <i>celt</i> is 1.</param>
            <returns>If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienummoniker-next">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumMoniker.Skip(System.UInt32)">
            <summary>Skips over the specified number of items in the enumeration sequence. (IEnumMoniker.Skip)</summary>
            <param name="celt">The number of items to be skipped.</param>
            <returns>If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienummoniker-skip">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumMoniker.Reset">
            <summary>Resets the enumeration sequence to the beginning. (IEnumMoniker.Reset)</summary>
            <returns>This method returns S_OK on success.</returns>
            <remarks>There is no guarantee that the same set of objects will be enumerated after the reset operation has completed. A static collection is reset to the beginning, but it can be too expensive for some collections, such as files in a directory, to guarantee this condition.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumMoniker.Clone(Windows.Win32.System.Com.IEnumMoniker**)">
            <summary>Creates a new enumerator that contains the same enumeration state as the current one. (IEnumMoniker.Clone)</summary>
            <param name="ppenum">Address of an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienummoniker">IEnumMoniker</a> pointer variable that receives the interface pointer to the enumeration object. If the method is unsuccessful, the value of this output variable is undefined.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienummoniker-clone">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IEnumMoniker.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000102-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumSTATDATA.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumSTATDATA.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumSTATDATA.Next(System.Span{Windows.Win32.System.Com.STATDATA},System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumSTATDATA.Next(System.UInt32,Windows.Win32.System.Com.STATDATA*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumSTATDATA.Next(System.UInt32,Windows.Win32.System.Com.STATDATA*,System.UInt32*)">
            <summary>Retrieves the specified number of items in the enumeration sequence. (IEnumSTATDATA.Next)</summary>
            <param name="celt">The number of items to be retrieved. If there are fewer than the requested number of items left in the sequence, this method retrieves the remaining elements.</param>
            <param name="rgelt">
            <para>An array of enumerated items. The enumerator is responsible for allocating any memory, and the caller is responsible for freeing it. If <i>celt</i> is greater than 1, the caller must also pass a non-<b>NULL</b> pointer passed to <i>pceltFetched</i> to know how many pointers to release.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumstatdata-next#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pceltFetched">The number of items that were retrieved. This parameter is always less than or equal to the number of items requested. This parameter can be <b>NULL</b> if <i>celt</i> is 1.</param>
            <returns>If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumstatdata-next">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumSTATDATA.Skip(System.UInt32)">
            <summary>Skips over the specified number of items in the enumeration sequence. (IEnumSTATDATA.Skip)</summary>
            <param name="celt">The number of items to be skipped.</param>
            <returns>If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumstatdata-skip">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumSTATDATA.Reset">
            <summary>Resets the enumeration sequence to the beginning. (IEnumSTATDATA.Reset)</summary>
            <returns>This method returns S_OK on success.</returns>
            <remarks>There is no guarantee that the same set of objects will be enumerated after the reset operation has completed. A static collection is reset to the beginning, but it can be too expensive for some collections, such as files in a directory, to guarantee this condition.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumSTATDATA.Clone(Windows.Win32.System.Com.IEnumSTATDATA**)">
            <summary>Creates a new enumerator that contains the same enumeration state as the current one. (IEnumSTATDATA.Clone)</summary>
            <param name="ppenum">A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstatdata">IEnumSTATDATA</a> pointer variable that receives the interface pointer to the enumeration object. If the method is unsuccessful, the value of this output variable is undefined.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ienumstatdata-clone">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IEnumSTATDATA.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000105-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumString.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumString.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumString.Next(System.Span{Windows.Win32.Foundation.PWSTR},System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumString.Next(System.UInt32,Windows.Win32.Foundation.PWSTR*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumString.Next(System.UInt32,Windows.Win32.Foundation.PWSTR*,System.UInt32*)">
            <summary>The IEnumString::Next (objidlbase.h) method retrieves the specified number of items in the enumeration sequence.</summary>
            <param name="celt">The number of items to be retrieved. If there are fewer than the requested number of items left in the sequence, this method retrieves the remaining elements.</param>
            <param name="rgelt">
            <para>An array of enumerated items. The enumerator is responsible for allocating any memory, and the caller is responsible for freeing it. If <i>celt</i> is greater than 1, the caller must also pass a non-NULL pointer passed to <i>pceltFetched</i> to know how many pointers to release.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidlbase/nf-objidlbase-ienumstring-next#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pceltFetched">The number of items that were retrieved. This parameter is always less than or equal to the number of items requested.</param>
            <returns>If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidlbase/nf-objidlbase-ienumstring-next">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumString.Skip(System.UInt32)">
            <summary>The IEnumString::Skip (objidlbase.h) method skips over the specified number of items in the enumeration sequence.</summary>
            <param name="celt">The number of items to be skipped.</param>
            <returns>If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidlbase/nf-objidlbase-ienumstring-skip">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumString.Reset">
            <summary>The IEnumString::Reset (objidlbase.h) method resets the enumeration sequence to the beginning.</summary>
            <returns>The return value is S_OK.</returns>
            <remarks>There is no guarantee that the same set of objects will be enumerated after the reset operation has completed. A static collection is reset to the beginning, but it can be too expensive for some collections, such as files in a directory, to guarantee this condition.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumString.Clone(Windows.Win32.System.Com.IEnumString**)">
            <summary>The IEnumString::Clone (objidlbase.h) method creates a new enumerator that contains the same enumeration state as the current one.</summary>
            <param name="ppenum">A pointer to the cloned enumerator object.</param>
            <returns>This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidlbase/nf-objidlbase-ienumstring-clone">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IEnumString.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000101-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumUnknown.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumUnknown.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumUnknown.Next(System.UInt32,Windows.Win32.System.Com.IUnknown**,System.UInt32*)">
            <summary>The IEnumUnknown::Next (objidlbase.h) method retrieves the specified number of items in the enumeration sequence.</summary>
            <param name="celt">The number of items to be retrieved. If there are fewer than the requested number of items left in the sequence, this method retrieves the remaining elements.</param>
            <param name="rgelt">
            <para>An array of enumerated items. The enumerator is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a>, and the caller is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> through each pointer enumerated. If <i>celt</i> is greater than 1, the caller must also pass a non-NULL pointer passed to <i>pceltFetched</i> to know how many pointers to release.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidlbase/nf-objidlbase-ienumunknown-next#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pceltFetched">The number of items that were retrieved. This parameter is always less than or equal to the number of items requested.</param>
            <returns>If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidlbase/nf-objidlbase-ienumunknown-next">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumUnknown.Skip(System.UInt32)">
            <summary>The IEnumUnknown::Skip (objidlbase.h) method skips over the specified number of items in the enumeration sequence.</summary>
            <param name="celt">The number of items to be skipped.</param>
            <returns>If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidlbase/nf-objidlbase-ienumunknown-skip">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumUnknown.Reset">
            <summary>The IEnumUnknown::Reset (objidlbase.h) method resets the enumeration sequence to the beginning.</summary>
            <returns>The return value is S_OK.</returns>
            <remarks>There is no guarantee that the same set of objects will be enumerated after the reset operation has completed. A static collection is reset to the beginning, but it can be too expensive for some collections, such as files in a directory, to guarantee this condition.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IEnumUnknown.Clone(Windows.Win32.System.Com.IEnumUnknown**)">
            <summary>The IEnumUnknown::Clone (objidlbase.h) method creates a new enumerator that contains the same enumeration state as the current one.</summary>
            <param name="ppenum">A pointer to the cloned enumerator object.</param>
            <returns>This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidlbase/nf-objidlbase-ienumunknown-clone">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IEnumUnknown.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000100-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IGlobalInterfaceTable.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IGlobalInterfaceTable.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IGlobalInterfaceTable.RegisterInterfaceInGlobal(Windows.Win32.System.Com.IUnknown*,System.Guid@,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IGlobalInterfaceTable.RegisterInterfaceInGlobal(Windows.Win32.System.Com.IUnknown*,System.Guid*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IGlobalInterfaceTable.RegisterInterfaceInGlobal(Windows.Win32.System.Com.IUnknown*,System.Guid*,System.UInt32*)">
            <summary>Registers the specified interface on an object residing in one apartment of a process as a global interface, enabling other apartments access to that interface.</summary>
            <param name="pUnk">An interface pointer of type <i>riid</i> on the object on which the interface to be registered as global is implemented.</param>
            <param name="riid">The IID of the interface to be registered as global.</param>
            <param name="pdwCookie">An identifier that can be used by another apartment to get access to a pointer to the interface being registered. The value of an invalid cookie is 0.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>Called in the apartment in which an object resides to register one of the object's interfaces as a global interface. This method supplies a pointer to a cookie that other apartments can use in a call to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-iglobalinterfacetable-getinterfacefromglobal">GetInterfaceFromGlobal</a> method to get a pointer to that interface. The interface pointer may be a pointer to an in-process object, or it may be a pointer to a proxy for an object residing in another apartment, in another process, or on another computer. The apartment that calls this method must remain alive until the corresponding call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-iglobalinterfacetable-revokeinterfacefromglobal">RevokeInterfaceFromGlobal</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidlbase/nf-objidlbase-iglobalinterfacetable-registerinterfaceinglobal#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IGlobalInterfaceTable.RevokeInterfaceFromGlobal(System.UInt32)">
            <summary>Revokes the registration of an interface in the global interface table.</summary>
            <param name="dwCookie">Identifies the interface whose global registration is to be revoked.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>Call this method when an interface registered in the global interface table object no longer needs to be accessed by other apartments in the same process. This method can be called by any apartment in the process, including apartments other than the one that registered the interface in the global interface table.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IGlobalInterfaceTable.GetInterfaceFromGlobal(System.UInt32,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IGlobalInterfaceTable.GetInterfaceFromGlobal(System.UInt32,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IGlobalInterfaceTable.GetInterfaceFromGlobal(System.UInt32,System.Guid*,System.Void**)">
            <summary>Retrieves a pointer to an interface on an object that is usable by the calling apartment. This interface must be currently registered in the global interface table.</summary>
            <param name="dwCookie">Identifies the interface (and its object), and is retrieved through a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-iglobalinterfacetable-registerinterfaceinglobal">IGlobalInterfaceTable::RegisterInterfaceInGlobal</a>.</param>
            <param name="riid">The IID of the interface.</param>
            <param name="ppv">A pointer to the pointer for the requested interface.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>After an interface has been registered in the global interface table, an apartment can get a pointer to this interface by calling the <b>GetInterfaceFromGlobal</b> method with the supplied cookie. This pointer to the interface can be used in the calling apartment but not by other apartments in the process. The application is responsible for coordinating access to the global variable during calls to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-iglobalinterfacetable-revokeinterfacefromglobal">IGlobalInterfaceTable::RevokeInterfaceFromGlobal</a>. That is, the application should ensure that one thread does not call <b>RevokeInterfaceFromGlobal</b> while another thread is calling <b>GetInterfaceFromGlobal</b> with the same cookie. Multiple calls to <b>GetInterfaceFromGlobal</b> for the same cookie are permitted. The <b>GetInterfaceFromGlobal</b> method calls <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the pointer obtained in the <i>ppv</i> parameter. It is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> on this pointer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidlbase/nf-objidlbase-iglobalinterfacetable-getinterfacefromglobal#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IGlobalInterfaceTable.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000146-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.GetClassID(System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.GetClassID(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.GetSizeMax(System.UInt64@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.GetSizeMax(System.UInt64*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.BindToObject(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.BindToObject(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.BindToObject(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Guid*,System.Void**)">
            <summary>Binds to the specified object. The binding process involves finding the object, putting it into the running state if necessary, and providing the caller with a pointer to a specified interface on the identified object.</summary>
            <param name="pbc">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface on the bind context object, which is used in this binding operation. The bind context caches objects bound during the binding process, contains parameters that apply to all operations using the bind context, and provides the means by which the moniker implementation should retrieve information about its environment.</param>
            <param name="pmkToLeft">If the moniker is part of a composite moniker, pointer to the moniker to the left of this moniker. This parameter is primarily used by moniker implementers to enable cooperation between the various components of a composite moniker. Moniker clients should use <b>NULL</b>.</param>
            <param name="riidResult">The IID of the interface the client wishes to use to communicate with the object that the moniker identifies.</param>
            <param name="ppvResult">The address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful return, *<i>ppvResult</i> contains the requested interface pointer to the object the moniker identifies. When successful, the implementation must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the moniker. It is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If an error occurs, *<i>ppvResult</i> should be <b>NULL</b>.</param>
            <returns>
            <para>This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><b>BindToObject</b> implements the primary function of a moniker, which is to locate the object identified by the moniker and return a pointer to one of its interfaces. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> If you are using a moniker as a persistent connection between two objects, you activate the connection by calling <b>BindToObject</b>. You typically call <b>BindToObject</b> during the following process: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-bindtoobject#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.BindToStorage(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.BindToStorage(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.BindToStorage(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Guid*,System.Void**)">
            <summary>Binds to the storage for the specified object. Unlike the IMoniker::BindToObject method, this method does not activate the object identified by the moniker.</summary>
            <param name="pbc">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface on the bind context object, which is used in this binding operation. The bind context caches objects bound during the binding process, contains parameters that apply to all operations using the bind context, and provides the means by which the moniker implementation should retrieve information about its environment.</param>
            <param name="pmkToLeft">If the moniker is part of a composite moniker, pointer to the moniker to the left of this moniker. This parameter is primarily used by moniker implementers to enable cooperation between the various components of a composite moniker. Moniker clients should use <b>NULL</b>.</param>
            <param name="riid">A reference to the identifier of the storage interface requested, whose pointer will be returned in <i>ppvObj</i>. Storage interfaces commonly requested include <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ilockbytes">ILockBytes</a>.</param>
            <param name="ppvObj">The address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful return, *<i>ppvObj</i> contains the requested interface pointer to the storage of the object the moniker identifies. When successful, the implementation must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the storage. It is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If an error occurs, *<i>ppvObj</i> should be <b>NULL</b>.</param>
            <returns>
            <para>This method can return the standard return values E_UNEXPECTED, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>There is an important difference between the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-bindtoobject">BindToObject</a> and <b>BindToStorage</b> methods. If, for example, you have a moniker that identifies a spreadsheet object, calling <b>BindToObject</b> provides access to the spreadsheet object itself, while calling <b>BindToStorage</b> provides access to the storage object in which the spreadsheet resides. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Although none of the COM moniker classes call this method in their binding operations, it might be appropriate to call it in the implementation of a new moniker class. You could call this method in an implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-bindtoobject">BindToObject</a> that requires information from the object identified by the <i>pmkToLeft</i> parameter and can get it from the persistent storage of the object without activation. For example, if your monikers are used to identify objects that can be activated without activating their containers, you may find this method useful. A client that can read the storage of the object its moniker identifies could also call this method. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Your implementation should locate the persistent storage for the object identified by the current moniker and return the desired interface pointer. Some types of monikers represent pseudo-objects, which are objects that do not have their own persistent storage. Such objects comprise some portion of the internal state of its container, for example, a range of cells in a spreadsheet. If your moniker class identifies this type of object, your implementation of <b>BindToStorage</b> should return the error MK_E_NOSTORAGE. If the bind context's <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-bind_opts">BIND_OPTS</a> structure specifies the BINDFLAGS_JUSTTESTEXISTENCE flag, your implementation has the option of returning <b>NULL</b> in <i>ppvObj</i> (although you can also ignore the flag and perform the complete binding operation). <h3><a id="Implementation-specific_Notes"></a><a id="implementation-specific_notes"></a><a id="IMPLEMENTATION-SPECIFIC_NOTES"></a>Implementation-specific Notes</h3> </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-bindtostorage#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.Reduce(Windows.Win32.System.Com.IBindCtx*,System.UInt32,Windows.Win32.System.Com.IMoniker**,Windows.Win32.System.Com.IMoniker**)">
            <summary>Reduces a moniker to its simplest form.</summary>
            <param name="pbc">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface on the bind context to be used in this binding operation. The bind context caches objects bound during the binding process, contains parameters that apply to all operations using the bind context, and provides the means by which the moniker implementation should retrieve information about its environment.</param>
            <param name="dwReduceHowFar">Specifies how far this moniker should be reduced. This parameter must be one of the values from the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ne-objidl-mkrreduce">MKRREDUCE</a> enumeration.</param>
            <param name="ppmkToLeft">
            <para>On entry, a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> pointer variable that contains the interface pointer to moniker to the left of this moniker. This parameter is used primarily by moniker implementers to enable cooperation between the various components of a composite moniker; moniker clients can usually pass <b>NULL</b>. On return, *<i>ppmkToLeft</i> is usually set to <b>NULL</b>, indicating no change in the original moniker to the left. In rare situations, *<i>ppmkToLeft</i> indicates a moniker, indicating that the previous moniker to the left should be disregarded and the moniker returned through *<i>ppmkToLeft</i> is the replacement. In such a situation, the implementation must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> on the old moniker to the left of this moniker and must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the new returned moniker; the caller must release it later. If an error occurs, the implementation can either leave the interface pointer unchanged or set it to <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-reduce#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="ppmkReduced">A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> pointer variable that receives the interface pointer to the reduced form of this moniker, which can be <b>NULL</b> if an error occurs or if this moniker is reduced to nothing. If this moniker cannot be reduced, *<i>ppmkReduced</i> is simply set to this moniker and the return value is MK_S_REDUCED_TO_SELF. If *<i>ppmkReduced</i> is non-<b>NULL</b>, the implementation must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the new moniker; it is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. (This is true even if *<i>ppmkReduced</i> is set to this moniker.)</param>
            <returns>
            <para>This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>This method is intended for the following uses: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-reduce#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.ComposeWith(Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.BOOL,Windows.Win32.System.Com.IMoniker**)">
            <summary>Creates a new composite moniker by combining the current moniker with the specified moniker.</summary>
            <param name="pmkRight">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on the moniker to compose onto the end of this moniker.</param>
            <param name="fOnlyIfNotGeneric">If <b>TRUE</b>, the caller requires a nongeneric composition, so the operation should proceed only if <i>pmkRight</i> is a moniker class that this moniker can compose with in some way other than forming a generic composite. If <b>FALSE</b>, the method can create a generic composite if necessary. Most callers should set this parameter to <b>FALSE</b>.</param>
            <param name="ppmkComposite">A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> pointer variable that receives the composite moniker pointer. When successful, the implementation must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the resulting moniker; it is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If an error occurs or if the monikers compose to nothing (for example, composing an anti-moniker with an item moniker or a file moniker), *<i>ppmkComposite</i> should be set to <b>NULL</b>.</param>
            <returns>
            <para>This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>Joining two monikers together is called <i>composition</i>. Sometimes two monikers of the same class can be combined in what is called nongeneric composition. For example, a file moniker representing an incomplete path and another file moniker representing a relative path can be combined to form a single file moniker representing the complete path. Nongeneric composition for a given moniker class can be handled only in the implementation of <b>ComposeWith</b> for that moniker class. Combining two monikers of any class is called <i>generic composition</i>, which can be accomplished through a call to the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-creategenericcomposite">CreateGenericComposite</a> function. Composition of monikers is an associative operation. That is, if A, B, and C are monikers, then, where Comp() represents the composition operation, Comp( Comp( A, B ), C ) is always equal to Comp( A, Comp( B, C ) ). <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> To combine two monikers, you should call <b>ComposeWith</b> rather than calling the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-creategenericcomposite">CreateGenericComposite</a> function to give the first moniker a chance to perform a nongeneric composition. An object that provides item monikers to identify its objects would call <b>ComposeWith</b> to provide a moniker that completely identifies the location of the object. This would apply, for example, to a server that supports linking to portions of a document, or to a container that supports linking to embedded objects within its documents. In such a situation, you would do the following: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-composewith#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.Enum(Windows.Win32.Foundation.BOOL,Windows.Win32.System.Com.IEnumMoniker**)">
            <summary>Retrieves a pointer to an enumerator for the components of a composite moniker.</summary>
            <param name="fForward">If <b>TRUE</b>, enumerates the monikers from left to right. If <b>FALSE</b>, enumerates from right to left.</param>
            <param name="ppenumMoniker">A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienummoniker">IEnumMoniker</a> pointer variable that receives the interface pointer to the enumerator object for the moniker. When successful, the implementation must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the enumerator object. It is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If an error occurs or if the moniker has no enumerable components, the implementation sets *<i>ppenumMoniker</i> to <b>NULL</b>.</param>
            <returns>This method can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.</returns>
            <remarks>
            <para>This method must supply an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienummoniker">IEnumMoniker</a> pointer to an enumerator that can enumerate the components of a moniker. For example, the implementation of the <b>IMoniker::Enum</b> method for a generic composite moniker creates an enumerator that can determine the individual monikers that make up the composite, while the <b>IMoniker::Enum</b> method for a file moniker creates an enumerator that returns monikers representing each of the components in the path. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Call this method to examine the components that make up a composite moniker. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> If the new moniker class has no discernible internal structure, your implementation of this method can simply return S_OK and set <i>ppenumMoniker</i> to <b>NULL</b>. <h3><a id="Implementation-specific_Notes"></a><a id="implementation-specific_notes"></a><a id="IMPLEMENTATION-SPECIFIC_NOTES"></a>Implementation-specific Notes</h3> </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-enum#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.IsEqual(Windows.Win32.System.Com.IMoniker*)">
            <summary>Determines whether this moniker is identical to the specified moniker.</summary>
            <param name="pmkOtherMoniker">A  pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on the moniker to be used for comparison with this one (the one from which this method is called).</param>
            <returns>This method returns S_OK to indicate that the two monikers are identical, and S_FALSE otherwise.</returns>
            <remarks>
            <para>Previous implementations of the running object table (ROT) called this method. The current implementation of the ROT uses the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-irotdata">IROTData</a> interface instead. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Call this method to determine whether two monikers are identical. The reduced form of a moniker is considered different from the unreduced form. You should call the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-reduce">IMoniker::Reduce</a> method before calling <b>IsEqual</b>, because a reduced moniker is in its most specific form. <b>IsEqual</b> may return S_FALSE on two monikers before they are reduced, and S_OK after they are reduced. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Your implementation should not reduce the current moniker before performing the comparison. It is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-reduce">IMoniker::Reduce</a> to compare reduced monikers. Two monikers that compare as equal must hash to the same value using <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-hash">IMoniker::Hash</a>. <h3><a id="Implementation-specific_Notes"></a><a id="implementation-specific_notes"></a><a id="IMPLEMENTATION-SPECIFIC_NOTES"></a>Implementation-specific Notes</h3> </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-isequal#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.Hash(System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.Hash(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.Hash(System.UInt32*)">
            <summary>Creates a hash value using the internal state of the moniker.</summary>
            <param name="pdwHash">A pointer to a variable that receives the hash value.</param>
            <returns>This method returns S_OK to indicate that the hash value was retrieved successfully.</returns>
            <remarks>
            <para><h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> You can use the value returned by this method to maintain a hash table of monikers. The hash value determines a hash bucket in the table. To search such a table for a specified moniker, calculate its hash value and then compare it to the monikers in that hash bucket using <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-isequal">IMoniker::IsEqual</a>. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> The hash value must be constant for the lifetime of the moniker. Two monikers that compare as equal using <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-isequal">IMoniker::IsEqual</a> must hash to the same value. Marshaling and then unmarshaling a moniker should have no effect on its hash value. Consequently, your implementation of <b>IMoniker::Hash</b> should rely only on the internal state of the moniker, not on its memory address. <h3><a id="Implementation-specific_Notes"></a><a id="implementation-specific_notes"></a><a id="IMPLEMENTATION-SPECIFIC_NOTES"></a>Implementation-specific Notes</h3> </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-hash#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.IsRunning(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.System.Com.IMoniker*)">
            <summary>Determines whether the object identified by this moniker is currently loaded and running.</summary>
            <param name="pbc">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface on the bind context to be used in this binding operation. The bind context caches objects bound during the binding process, contains parameters that apply to all operations using the bind context, and provides the means by which the moniker implementation should retrieve information about its environment.</param>
            <param name="pmkToLeft">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on the moniker to the left of this moniker if this moniker is part of a composite. This parameter is used primarily by moniker implementers to enable cooperation between the various components of a composite moniker; moniker clients can usually pass <b>NULL</b>.</param>
            <param name="pmkNewlyRunning">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on the moniker most recently added to the running object table (ROT). This can be <b>NULL</b>. If non-<b>NULL</b>, the implementation can return the results of calling <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-isequal">IMoniker::IsEqual</a> on the <i>pmkNewlyRunning</i> parameter, passing the current moniker. This parameter is intended to enable <b>IsRunning</b> implementations that are more efficient than just searching the ROT, but the implementation can choose to ignore <i>pmkNewlyRunning</i> without causing any harm.</param>
            <returns>
            <para>This method can return the standard return values E_UNEXPECTED, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> If speed is important when you're requesting services from the object identified by the moniker, you may want those services only if the object is already running (because loading an object into the running state may be time-consuming). In such a situation, you should call <b>IsRunning</b> to determine whether the object is running. For the monikers stored within linked objects, <b>IsRunning</b> is primarily called by the default handler's implementation of <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-iolelink-bindifrunning">IOleLink::BindIfRunning</a>. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> To get a pointer to the ROT, your implementation should call <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-getrunningobjecttable">IBindCtx::GetRunningObjectTable</a> on the <i>pbc</i> parameter. Your implementation can then call <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-isrunning">IRunningObjectTable::IsRunning</a> to determine whether the object identified by the moniker is running. The object identified by the moniker must have registered itself with the ROT when it first began running. <h3><a id="Implementation-specific_Notes"></a><a id="implementation-specific_notes"></a><a id="IMPLEMENTATION-SPECIFIC_NOTES"></a>Implementation-specific Notes</h3> </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-isrunning#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.GetTimeOfLastChange(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.GetTimeOfLastChange(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.GetTimeOfLastChange(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Runtime.InteropServices.ComTypes.FILETIME*)">
            <summary>Retrieves the time at which the object identified by this moniker was last changed.</summary>
            <param name="pbc">A pointer to the bind context to be used in this binding operation. The bind context caches objects bound during the binding process, contains parameters that apply to all operations using the bind context, and provides the means by which the moniker implementation should retrieve information about its environment. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>.</param>
            <param name="pmkToLeft">If the moniker is part of a composite moniker, pointer to the moniker to the left of this moniker. This parameter is primarily used by moniker implementers to enable cooperation between the various components of a composite moniker. Moniker clients should pass <b>NULL</b>.</param>
            <param name="pFileTime">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the time of last change. A value of {0xFFFFFFFF,0x7FFFFFFF} indicates an error (for example, exceeded time limit, information not available).</param>
            <returns>
            <para>This method can return the standard return values E_OUTOFMEMORY, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>To be precise, the time returned is the earliest time COM can identify after which no change has occurred, so this time may be later than the time of the last change to the object. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> If you're caching information returned by the object identified by the moniker, you may want to ensure that your information is up-to-date. To do so, you would call <b>GetTimeOfLastChange</b> and compare the time returned with the time you last retrieved information from the object.</para>
            <para>For the monikers stored within linked objects, <b>GetTimeOfLastChange</b> is primarily called by the default handler's implementation of <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-ioleobject-isuptodate">IOleObject::IsUpToDate</a>. Container applications call <b>IOleObject::IsUpToDate</b> to determine if a linked object (or an embedded object containing linked objects) is up-to-date without actually binding to the object. This enables an application to determine quickly which linked objects require updating when the end user opens a document. The application can then bind only those linked objects that need updating (after prompting the end user to determine whether they should be updated) instead of binding every linked object in the document. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> It is important to perform this operation quickly because, for linked objects, this method is called when a user first opens a compound document. Consequently, your <b>GetTimeOfLastChange</b> implementation should not bind to any objects. In addition, your implementation should check the deadline parameter in the bind context and return MK_E_EXCEEDEDDEADLINE if the operation cannot be completed by the specified time. Following are some strategies you can use in your implementations:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-gettimeoflastchange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.Inverse(Windows.Win32.System.Com.IMoniker**)">
            <summary>Creates a moniker that is the inverse of this moniker. When composed to the right of this moniker or one of similar structure, the moniker will compose to nothing.</summary>
            <param name="ppmk">The address of an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> pointer variable that receives the interface pointer to a moniker that is the inverse of this moniker. When successful, the implementation must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the new inverse moniker. It is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If an error occurs, the implementation should set *<i>ppmk</i> to <b>NULL</b>.</param>
            <returns>
            <para>This method can return the standard return values E_OUTOFMEMORY, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The inverse of a moniker is analogous to the ".." directory in MS-DOS file systems; the ".." directory acts as the inverse to any other directory name, because appending ".." to a directory name results in an empty path. In the same way, the inverse of a moniker typically is also the inverse of all monikers in the same class. However, it is not necessarily the inverse of a moniker of a different class. The inverse of a composite moniker is a composite consisting of the inverses of the components of the original moniker, arranged in reverse order. For example, if the inverse of A is Inv( A ) and the composite of A, B, and C is Comp( A, B, C ), then Inv( Comp( A, B, C ) ) is equal to Comp( Inv( C ), Inv( B ), Inv( A ) ). Not all monikers have inverses. Most monikers that are themselves inverses, such as anti-monikers, do not have inverses. Monikers that have no inverse cannot have relative monikers formed from inside the objects they identify to other objects outside. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> An object that is using a moniker to locate another object usually does not know the class of the moniker it is using. To get the inverse of a moniker, you should always call <b>IMoniker::Inverse</b> rather than the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-createantimoniker">CreateAntiMoniker</a> function, because you cannot be certain that the moniker you're using considers an anti-moniker to be its inverse.</para>
            <para>The <b>Inverse</b> method is also called by the implementation of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-relativepathto">IMoniker::RelativePathTo</a> method, to assist in constructing a relative moniker. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> If your monikers have no internal structure, you can call the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-createantimoniker">CreateAntiMoniker</a> function in to get an anti-moniker in your implementation of <b>IMoniker::Inverse</b>. In your implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-composewith">IMoniker::ComposeWith</a>, you need to check for the inverse you supply in the implementation of <b>Inverse</b>. <h3><a id="Implementation-specific_Notes"></a><a id="implementation-specific_notes"></a><a id="IMPLEMENTATION-SPECIFIC_NOTES"></a>Implementation-specific Notes</h3> </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-inverse#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.CommonPrefixWith(Windows.Win32.System.Com.IMoniker*,Windows.Win32.System.Com.IMoniker**)">
            <summary>Creates a new moniker based on the prefix that this moniker has in common with the specified moniker.</summary>
            <param name="pmkOther">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on another moniker to be compared with this one to determine whether there is a common prefix.</param>
            <param name="ppmkPrefix">The address of an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a>* pointer variable that receives the interface pointer to the moniker that is the common prefix of this moniker and pmkOther. When successful, the implementation must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the resulting moniker; it is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If an error occurs or if there is no common prefix, the implementation should set *<i>ppmkPrefix</i> to <b>NULL</b>.</param>
            <returns>
            <para>This method can return the standard return values E_OUTOFMEMORY, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><b>CommonPrefixWith</b> creates a new moniker that consists of the common prefixes of the moniker on this moniker object and another moniker. For example, if one moniker represents the path "c:\projects\secret\art\pict1.bmp" and another moniker represents the path "c:\projects\secret\docs\chap1.txt", the common prefix of these two monikers would be a moniker representing the path "c:\projects\secret". <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> The <b>CommonPrefixWith</b> method is primarily called in the implementation of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-relativepathto">IMoniker::RelativePathTo</a> method. Clients using a moniker to locate an object rarely need to call this method.</para>
            <para>Call this method only if <i>pmkOther</i> and this moniker are both absolute monikers. An absolute moniker is either a file moniker or a generic composite whose leftmost component is a file moniker that represents an absolute path. Do not call this method on relative monikers because it would not produce meaningful results.</para>
            <para><h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Your implementation should first determine whether <i>pmkOther</i> is a moniker of a class that you recognize and for which you can provide special handling (for example, if it is of the same class as this moniker). If so, your implementation should determine the common prefix of the two monikers. Otherwise, it should pass both monikers in a call to the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-monikercommonprefixwith">MonikerCommonPrefixWith</a> function, which correctly handles the generic case.</para>
            <para><h3><a id="Implementation-specific_Notes"></a><a id="implementation-specific_notes"></a><a id="IMPLEMENTATION-SPECIFIC_NOTES"></a>Implementation-specific Notes</h3> </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-commonprefixwith#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.RelativePathTo(Windows.Win32.System.Com.IMoniker*,Windows.Win32.System.Com.IMoniker**)">
            <summary>Creates a relative moniker between this moniker and the specified moniker.</summary>
            <param name="pmkOther">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on the moniker to which a relative path should be taken.</param>
            <param name="ppmkRelPath">A pointer to an  <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> pointer variable that receives the interface pointer to the relative moniker. When successful, the implementation must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the new moniker; it is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If an error occurs, the implementation sets *<i>ppmkRelPath</i> to <b>NULL</b>.</param>
            <returns>
            <para>This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>A relative moniker is analogous to a relative path (such as "..\backup"). For example, suppose you have one moniker that represents the path "c:\projects\secret\art\pict1.bmp" and another moniker that represents the path "c:\projects\secret\docs\chap1.txt". Calling <b>RelativePathTo</b> on the first moniker, passing the second one as the <i>pmkOther</i> parameter, would create a relative moniker representing the path "..\docs\chap1.txt". <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Moniker clients typically do not need to call <b>RelativePathTo</b>. This method is called primarily by the default handler for linked objects. Linked objects contain both an absolute and a relative moniker to identify the link source. (This enables link tracking if the user moves a directory tree containing both the container and source files.) The default handler calls this method to create a relative moniker from the container document to the link source. (That is, it calls <b>RelativePathTo</b> on the moniker identifying the container document, passing the moniker identifying the link source as the <i>pmkOther</i> parameter.) If you do call <b>RelativePathTo</b>, call it only on absolute monikers, for example, a file moniker or a composite moniker whose leftmost component is a file moniker, where the file moniker represents an absolute path. Do not call this method on relative monikers. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Your implementation of <b>RelativePathTo</b> should first determine whether <i>pmkOther</i> is a moniker of a class that you recognize and for which you can provide special handling (for example, if it is of the same class as this moniker). If so, your implementation should determine the relative path. Otherwise, it should pass both monikers in a call to the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-monikerrelativepathto">MonikerRelativePathTo</a> function, which correctly handles the generic case. The first step in determining a relative path is determining the common prefix of this moniker and <i>pmkOther</i>. The next step is to break this moniker and <i>pmkOther</i> into two parts each, say (P, myTail) and (P, otherTail) respectively, where P is the common prefix. The correct relative path is then the inverse of myTail composed with otherTail: Comp( Inv( myTail ), otherTail ) where Comp() represents the composition operation and Inv() represents the inverse operation. For certain types of monikers, you cannot use your <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-inverse">IMoniker::Inverse</a> method to construct the inverse of myTail. For example, a file moniker returns an anti-moniker as an inverse, while its <b>RelativePathTo</b> method must use one or more file monikers that each represent the path ".." to construct the inverse of myTail. <h3><a id="Implementation-specific_Notes"></a><a id="implementation-specific_notes"></a><a id="IMPLEMENTATION-SPECIFIC_NOTES"></a>Implementation-specific Notes</h3> </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-relativepathto#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.GetDisplayName(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.PWSTR@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.GetDisplayName(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.PWSTR*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.GetDisplayName(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.PWSTR*)">
            <summary>Retrieves the display name for the moniker.</summary>
            <param name="pbc">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface on the bind context to be used in this operation. The bind context caches objects bound during the binding process, contains parameters that apply to all operations using the bind context, and provides the means by which the moniker implementation should retrieve information about its environment.</param>
            <param name="pmkToLeft">If the moniker is part of a composite moniker, pointer to the moniker to the left of this moniker. This parameter is used primarily by moniker implementers to enable cooperation between the various components of a composite moniker. Moniker clients should pass <b>NULL</b>.</param>
            <param name="ppszDisplayName">The address of a pointer variable that receives a pointer to the display name string for the moniker. The implementation must use <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imalloc-alloc">IMalloc::Alloc</a> to allocate the string returned in <i>ppszDisplayName</i>, and the caller is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imalloc-free">IMalloc::Free</a> to free it. Both the caller and the implementation of this method use the COM task allocator returned by <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetmalloc">CoGetMalloc</a>. If an error occurs, the implementation must set *<i>ppszDisplayName</i> should be set to <b>NULL</b>.</param>
            <returns>
            <para>This method can return the standard return values E_OUTOFMEMORY, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><b>GetDisplayName</b> provides a string that is a displayable representation of the moniker. A display name is not a complete representation of a moniker's internal state; it is simply a form that can be read by users. As a result, it is possible (though rare) for two different monikers to have the same display name. While there is no guarantee that the display name of a moniker can be parsed back into that moniker when calling the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-mkparsedisplayname">MkParseDisplayName</a> function with it, failure to do so is rare. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> It is possible that retrieving a moniker's display name may be an expensive operation. For efficiency, you may want to cache the results of the first successful call to <b>GetDisplayName</b>, rather than making repeated calls. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> If you are writing a moniker class in which the display name does not change, simply cache the display name and supply the cached name when requested. If the display name can change over time, getting the current display name might mean that the moniker has to access the object's storage or bind to the object, either of which can be expensive operations. If this is the case, your implementation of <b>GetDisplayName</b> should return MK_E_EXCEEDEDDEADLINE if the name cannot be retrieved by the time specified in the bind context's <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-bind_opts">BIND_OPTS</a> structure. A moniker that is intended to be part of a generic composite moniker should include any preceding delimiter (such as '\') as part of its display name. For example, the display name returned by an item moniker includes the delimiter specified when it was created with the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-createitemmoniker">CreateItemMoniker</a> function. The display name for a file moniker does not include a delimiter because file monikers are always expected to be the leftmost component of a composite. <h3><a id="Implementation-specific_Notes"></a><a id="implementation-specific_notes"></a><a id="IMPLEMENTATION-SPECIFIC_NOTES"></a>Implementation-specific Notes</h3> </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-getdisplayname#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.ParseDisplayName(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.PWSTR,System.UInt32@,Windows.Win32.System.Com.IMoniker**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.ParseDisplayName(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.PWSTR,System.UInt32*,Windows.Win32.System.Com.IMoniker**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.ParseDisplayName(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.PWSTR,System.UInt32*,Windows.Win32.System.Com.IMoniker**)">
            <summary>Converts a display name into a moniker.</summary>
            <param name="pbc">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface on the bind context to be used in this binding operation. The bind context caches objects bound during the binding process, contains parameters that apply to all operations using the bind context, and provides the means by which the moniker implementation should retrieve information about its environment.</param>
            <param name="pmkToLeft">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on the moniker that has been built out of the display name up to this point.</param>
            <param name="pszDisplayName">The remaining display name to be parsed.</param>
            <param name="pchEaten">A pointer to a variable that receives the number of characters in <i>pszDisplayName</i> that were consumed in this step.</param>
            <param name="ppmkOut">A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> pointer variable that receives the interface pointer to the moniker that was built from <i>pszDisplayName</i>. When successful, the implementation must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the new moniker; it is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If an error occurs, the implementation sets *<i>ppmkOut</i> to <b>NULL</b>.</param>
            <returns>
            <para>This method can return the standard return valuesE_OUTOFMEMORY and E_UNEXPECTED, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Moniker clients do not typically call <b>ParseDisplayName</b> directly. Instead, they call the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-mkparsedisplayname">MkParseDisplayName</a> function when they want to convert a display name into a moniker (for example, in implementing the <b>Links</b> dialog box for a container application, or for implementing a macro language that supports references to objects outside the document). That function first parses the initial portion of the display name itself. It then calls <b>ParseDisplayName</b> on the moniker it has just created, passing the remainder of the display name and getting a new moniker in return; this step is repeated until the entire display name has been parsed. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Your implementation may be able to perform this parsing by itself if your moniker class is designed to designate only certain kinds of objects. Otherwise, you must get an <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-iparsedisplayname">IParseDisplayName</a> interface pointer for the object identified by the moniker-so-far (that is, the composition of <i>pmkToLeft</i> and this moniker) and then return the results of calling <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-iparsedisplayname-parsedisplayname">IParseDisplayName::ParseDisplayName</a>. There are different strategies for getting an <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-iparsedisplayname">IParseDisplayName</a> pointer, as follows: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-parsedisplayname#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.IsSystemMoniker(System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.IsSystemMoniker(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IMoniker.IsSystemMoniker(System.UInt32*)">
            <summary>Determines whether this moniker is one of the system-provided moniker classes.</summary>
            <param name="pdwMksys">A pointer to a variables that receives one of the values from the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-mksys">MKSYS</a> enumeration and refers to one of the COM moniker classes. This parameter cannot be <b>NULL</b>.</param>
            <returns>This method returns S_OK to indicate that the moniker is a system moniker, and S_FALSE otherwise.</returns>
            <remarks>
            <para><h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> New values of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-mksys">MKSYS</a> enumeration may be defined in the future; therefore, you should explicitly test for each value you are interested in. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Your implementation of this method must return MKSYS_NONE. You cannot use this function to identify your own monikers (for example, in your implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-composewith">IMoniker::ComposeWith</a>). Instead, you should use your moniker's implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersist-getclassid">IPersist::GetClassID</a> or use <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)">QueryInterface</a> to test for your own private interface. <h3><a id="Implementation-specific_Notes"></a><a id="implementation-specific_notes"></a><a id="IMPLEMENTATION-SPECIFIC_NOTES"></a>Implementation-specific Notes</h3> </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-imoniker-issystemmoniker#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IMoniker.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0000000f-0000-0000-c000-000000000046}</value>
        </member>
        <member name="T:Windows.Win32.System.Com.INVOKEKIND">
            <summary>Specifies the way a function is invoked.</summary>
            <remarks>In C, value assignment is written as *pobj1 = *pobj2, while reference assignment is written as pobj1 = pobj2. Other languages have other syntactic conventions. A property or data member can support only a value assignment, a reference assignment, or both. The INVOKEKIND enumeration constants are the same constants that are passed to <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-invoke">IDispatch::Invoke</a> to specify the way in which a function is invoked.</remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.INVOKEKIND.INVOKE_FUNC">
            <summary>The member is called using a normal function invocation syntax.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.INVOKEKIND.INVOKE_PROPERTYGET">
            <summary>The function is invoked using a normal property-access syntax.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.INVOKEKIND.INVOKE_PROPERTYPUT">
            <summary>The function is invoked using a property value assignment syntax. Syntactically, a typical programming language might represent changing a property in the same way as assignment. For example: object.property : = value.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.INVOKEKIND.INVOKE_PROPERTYPUTREF">
            <summary>The function is invoked using a property reference assignment syntax.</summary>
        </member>
        <member name="M:Windows.Win32.System.Com.IPersist.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IPersist.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IPersist.GetClassID(System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IPersist.GetClassID(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IPersist.GetClassID(System.Guid*)">
            <summary>Retrieves the class identifier (CLSID) of the object.</summary>
            <param name="pClassID">A pointer to the location that receives the CLSID on return. The CLSID is a globally unique identifier (GUID) that uniquely represents an object class that defines the code that can manipulate the object's data.</param>
            <returns>If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.</returns>
            <remarks>
            <para>The <b>GetClassID</b> method retrieves the class identifier (CLSID) for an object, used in later operations to load object-specific code into the caller's context. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> A container application might call this method to retrieve the original CLSID of an object that it is treating as a different class. Such a call would be necessary if a user performed an editing operation that required the object to be saved. If the container were to save it using the treat-as CLSID, the original application would no longer be able to edit the object. Typically, in this case, the container calls the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-olesave">OleSave</a> helper function, which performs all the necessary steps. For this reason, most container applications have no need to call this method directly. The exception would be a container that provides an object handler for certain objects. In particular, a container application should not get an object's CLSID and then use it to retrieve class specific information from the registry. Instead, the container should use <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-ioleobject">IOleObject</a> and <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interfaces to retrieve such class-specific information directly from the object. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Typically, implementations of this method simply supply a constant CLSID for an object. If, however, the object's <b><a href="https://docs.microsoft.com/windows/desktop/com/treatas">TreatAs</a></b> registry key has been set by an application that supports emulation (and so is treating the object as one of a different class), a call to <b>GetClassID</b> must supply the CLSID specified in the <b><a href="https://docs.microsoft.com/windows/desktop/com/treatas">TreatAs</a></b> key. For more information on emulation, see <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-cotreatasclass">CoTreatAsClass</a>. When an object is in the running state, the default handler calls an implementation of <b>GetClassID</b> that delegates the call to the implementation in the object. When the object is not running, the default handler instead calls the <a href="https://docs.microsoft.com/windows/desktop/api/coml2api/nf-coml2api-readclassstg">ReadClassStg</a> function to read the CLSID that is saved in the object's storage. If you are writing a custom object handler for your object, you might want to simply delegate this method to the default handler implementation (see <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-olecreatedefaulthandler">OleCreateDefaultHandler</a>).</para>
            <para><h3><a id="URL_Moniker_Notes"></a><a id="url_moniker_notes"></a><a id="URL_MONIKER_NOTES"></a>URL Moniker Notes</h3> This method returns CLSID_StdURLMoniker.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersist-getclassid#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IPersist.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0000010c-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IPersistStream.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IPersistStream.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IPersistStream.GetClassID(System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IPersistStream.GetClassID(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IPersistStream.IsDirty">
            <summary>Determines whether an object has changed since it was last saved to its stream. (IPersistStream.IsDirty)</summary>
            <returns>This method returns S_OK to indicate that the object has changed. Otherwise, it returns S_FALSE.</returns>
            <remarks>
            <para>Use this method to determine whether an object should be saved before closing it. The dirty flag for an object is conditionally cleared in the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersiststream-save">IPersistStream::Save</a> method. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> You should treat any error return codes as an indication that the object has changed. Unless this method explicitly returns S_FALSE, assume that the object must be saved. Note that the OLE-provided implementations of the <b>IPersistStream::IsDirty</b> method in the OLE-provided moniker interfaces always return S_FALSE because their internal state never changes.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersiststream-isdirty#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IPersistStream.Load(Windows.Win32.System.Com.IStream*)">
            <summary>Initializes an object from the stream where it was saved previously. (IPersistStream.Load)</summary>
            <param name="pStm">An <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> pointer to the stream from which the object should be loaded.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>This method loads an object from its associated stream. The seek pointer is set as it was in the most recent <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersiststream-save">IPersistStream::Save</a> method. This method can seek and read from the stream, but cannot write to it. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Rather than calling <b>IPersistStream::Load</b> directly, you typically call the <a href="https://docs.microsoft.com/windows/desktop/api/ole/nf-ole-oleloadfromstream">OleLoadFromStream</a> function does the following: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersiststream-load#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IPersistStream.Save(Windows.Win32.System.Com.IStream*,Windows.Win32.Foundation.BOOL)">
            <summary>Saves an object to the specified stream. (IPersistStream.Save)</summary>
            <param name="pStm">An <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> pointer to the stream into which the object should be saved.</param>
            <param name="fClearDirty">Indicates whether to clear the dirty flag after the save is complete. If <b>TRUE</b>, the flag should be cleared. If <b>FALSE</b>, the flag should be left unchanged.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><b>IPersistStream::Save</b> saves an object into the specified stream and indicates whether the object should reset its dirty flag. The seek pointer is positioned at the location in the stream at which the object should begin writing its data. The object calls the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-isequentialstream-write">ISequentialStream::Write</a> method to write its data. On exit, the seek pointer must be positioned immediately past the object data. The position of the seek pointer is undefined if an error returns. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Rather than calling <b>IPersistStream::Save</b> directly, you typically call the <a href="https://docs.microsoft.com/windows/desktop/api/ole/nf-ole-olesavetostream">OleSaveToStream</a> helper function which does the following: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersiststream-save#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IPersistStream.GetSizeMax(System.UInt64@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IPersistStream.GetSizeMax(System.UInt64*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IPersistStream.GetSizeMax(System.UInt64*)">
            <summary>Retrieves the size of the stream needed to save the object. (IPersistStream.GetSizeMax)</summary>
            <param name="pcbSize">The size in bytes of the stream needed to save this object, in bytes.</param>
            <returns>This method returns S_OK to indicate that the size was retrieved successfully.</returns>
            <remarks>
            <para>This method returns the size needed to save an object. You can call this method to determine the size and set the necessary buffers before calling the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersiststream-save">IPersistStream::Save</a> method. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> The <b>GetSizeMax</b> implementation should return a conservative estimate of the necessary size because the caller might call the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersiststream-save">IPersistStream::Save</a> method with a non-growable stream. <h3><a id="URL_Moniker_Notes"></a><a id="url_moniker_notes"></a><a id="URL_MONIKER_NOTES"></a>URL Moniker Notes</h3> This method retrieves the maximum number of bytes in the stream that will be required by a subsequent call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersiststream-save">IPersistStream::Save</a>. This value is sizeof(ULONG)==4 plus sizeof(WCHAR)*n where n is the length of the full or partial URL string, including the NULL terminator.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersiststream-getsizemax#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IPersistStream.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000109-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IRunningObjectTable.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.Register(Windows.Win32.System.Com.ROT_FLAGS,Windows.Win32.System.Com.IUnknown*,Windows.Win32.System.Com.IMoniker*,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IRunningObjectTable.Register(Windows.Win32.System.Com.ROT_FLAGS,Windows.Win32.System.Com.IUnknown*,Windows.Win32.System.Com.IMoniker*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.Register(Windows.Win32.System.Com.ROT_FLAGS,Windows.Win32.System.Com.IUnknown*,Windows.Win32.System.Com.IMoniker*,System.UInt32*)">
            <summary>Registers an object and its identifying moniker in the running object table (ROT).</summary>
            <param name="grfFlags">
            <para>Specifies whether the ROT's reference to punkObject is weak or strong and controls access to the object through its entry in the ROT. For details, see the Remarks section. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-irunningobjecttable-register#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="punkObject">A pointer to the object that is being registered as running.</param>
            <param name="pmkObjectName">A pointer to the moniker that identifies <i>punkObject</i>.</param>
            <param name="pdwRegister">An identifier for this ROT entry that can be used in subsequent calls to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-revoke">IRunningObjectTable::Revoke</a> or <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-notechangetime">IRunningObjectTable::NoteChangeTime</a>. The caller cannot specify <b>NULL</b> for this parameter. If an error occurs, *<i>pdwRegister</i> is set to zero.</param>
            <returns>
            <para>This method can return the standard return values E_INVALIDARG and E_OUTOFMEMORY, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>This method registers a pointer to an object under a moniker that identifies the object. The moniker is used as the key when the table is searched with <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-getobject">IRunningObjectTable::GetObject</a>. When an object is registered, the ROT always calls <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the object. For a weak registration (ROTFLAGS_REGISTRATIONKEEPSALIVE not set), the ROT will release the object whenever the last strong reference to the object is released. For a strong registration (ROTFLAGS_REGISTRATIONKEEPSALIVE set), the ROT prevents the object from being destroyed until the object's registration is explicitly revoked. A server registered as either LocalService or RunAs can set the ROTFLAGS_ALLOWANYCLIENT flag in its call to <b>Register</b> to allow any client to connect to it. A server setting this bit must have its executable name in the AppID section of the registry that refers to the AppID for the executable. An "activate as activator" server (not registered as LocalService or RunAs) must not set this flag in its call to <b>Register</b>. For details on installing services, see <a href="https://docs.microsoft.com/windows/desktop/com/installing-as-a-service-application">Installing as a Service Application</a>. Registering a second object with the same moniker, or re-registering the same object with the same moniker, creates a second entry in the ROT. In this case, <b>Register</b> returns MK_S_MONIKERALREADYREGISTERED. Each call to <b>Register</b> must be matched by a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-revoke">IRunningObjectTable::Revoke</a> because even duplicate entries have different <i>pdwRegister</i> identifiers. A problem with duplicate registrations is that there is no way to determine which object will be returned if the moniker is specified in a subsequent call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-isrunning">IRunningObjectTable::IsRunning</a>. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> If you are a moniker provider (that is, you hand out monikers identifying your objects to make them accessible to others), you must call the <b>Register</b> method to register your objects when they begin running. You must also call this method if you rename your objects while they are loaded.</para>
            <para>The most common type of moniker provider is a compound-document link source. This includes server applications that support linking to their documents (or portions of a document) and container applications that support linking to embeddings within their documents. Server applications that do not support linking can also use the ROT to cooperate with container applications that support linking to embeddings.</para>
            <para>If you are writing a server application, you should register an object with the ROT when it begins running, typically in your implementation of <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-ioleobject-doverb">IOleObject::DoVerb</a>. The object must be registered under its full moniker, which requires getting the moniker of its container document using <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-ioleclientsite-getmoniker">IOleClientSite::GetMoniker</a>. You should also revoke and re-register the object in your implementation of <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-ioleobject-setmoniker">IOleObject::SetMoniker</a>, which is called if the container document is renamed. If you are writing a container application that supports linking to embeddings, you should register your document with the ROT when it is loaded. If your document is renamed, you should revoke and re-register it with the ROT and call <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-ioleobject-setmoniker">IOleObject::SetMoniker</a> for any embedded objects in the document to give them an opportunity to re-register themselves. Objects registered in the ROT must be explicitly revoked when the object is no longer running or when its moniker changes. This revocation is important because there is no way for the system to automatically remove entries from the ROT. You must cache the identifier that is written through pdwRegister and use it in a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-revoke">IRunningObjectTable::Revoke</a> to revoke the registration. For a strong registration, a strong reference is released when the objects registration is revoked. As of Windows Server 2003, if there are stale entries that remain in the ROT due to unexpected server problems, COM will automatically remove these stale entries from the ROT. The system's implementation of <b>Register</b> calls <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-reduce">IMoniker::Reduce</a> on the <i>pmkObjectName</i> parameter to ensure that the moniker is fully reduced before registration. If an object is known by more than one fully reduced moniker, it should be registered under all such monikers.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-irunningobjecttable-register#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.Revoke(System.UInt32)">
            <summary>Removes an entry from the running object table (ROT) that was previously registered by a call to IRunningObjectTable::Register.</summary>
            <param name="dwRegister">The identifier of the ROT entry to be revoked.</param>
            <returns>This method can return the standard return values E_INVALIDARG and S_OK.</returns>
            <remarks>
            <para>This method undoes the effect of a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-register">IRunningObjectTable::Register</a>, removing both the moniker and the pointer to the object identified by that moniker. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> A moniker provider (hands out monikers identifying its objects to make them accessible to others) must call the <b>Revoke</b> method to revoke the registration of its objects when it stops running. It must have previously called <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-register">IRunningObjectTable::Register</a> and stored the identifier returned by that method; it uses that identifier when calling <b>Revoke</b>. The most common type of moniker provider is a compound-document link source. This includes server applications that support linking to their documents (or portions of a document) and container applications that support linking to embeddings within their documents. Server applications that do not support linking can also use the ROT to cooperate with container applications that support linking to embeddings. If you are writing a container application, you must revoke a document's registration when the document is closed. You must also revoke a document's registration before re-registering it when it is renamed.</para>
            <para>If you are writing a server application, you must revoke an object's registration when the object is closed. You must also revoke an object's registration before re-registering it when its container document is renamed (see <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-ioleobject-setmoniker">IOleObject::SetMoniker</a>).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-irunningobjecttable-revoke#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.IsRunning(Windows.Win32.System.Com.IMoniker*)">
            <summary>Determines whether the object identified by the specified moniker is currently running.</summary>
            <param name="pmkObjectName">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on the moniker.</param>
            <returns>If the object is in the running state, the return value is <b>TRUE</b>. Otherwise, it is <b>FALSE</b>.</returns>
            <remarks>
            <para>This method simply indicates whether a object is running. To retrieve a pointer to a running object, use the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-getobject">IRunningObjectTable::GetObject</a> method. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Generally, you call the <b>IsRunning</b> method only if you are writing your own moniker class (that is, implementing the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface). You typically call this method from your implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-isrunning">IMoniker::IsRunning</a>. However, you should do so only if the <i>pmkToLeft</i> parameter of <b>IMoniker::IsRunning</b> is <b>NULL</b>. Otherwise, you should call <b>IMoniker::IsRunning</b> on your <i>pmkToLeft</i> parameter instead.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-irunningobjecttable-isrunning#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.GetObject(Windows.Win32.System.Com.IMoniker*,Windows.Win32.System.Com.IUnknown**)">
            <summary>Determines whether the object identified by the specified moniker is running, and if it is, retrieves a pointer to that object.</summary>
            <param name="pmkObjectName">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on the moniker.</param>
            <param name="ppunkObject">A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> pointer variable that receives the interface pointer to the running object. When successful, the implementation calls <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the object; it is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If the object is not running or if an error occurs, the implementation sets *<i>ppunkObject</i> to <b>NULL</b>.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>This method checks the ROT for the moniker specified by <i>pmkObjectName</i>. If that moniker had previously been registered with a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-register">IRunningObjectTable::Register</a>, this method returns the pointer that was registered at that time. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Generally, you call the <b>IRunningObjectTable::GetObject</b> method only if you are writing your own moniker class (that is, implementing the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface). You typically call this method from your implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-bindtoobject">IMoniker::BindToObject</a>. However, note that not all implementations of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-bindtoobject">IMoniker::BindToObject</a> need to call this method. If you expect your moniker to have a prefix (indicated by a non-<b>NULL</b><i>pmkToLeft</i> parameter to <b>IMoniker::BindToObject</b>), you should not check the ROT. The reason for this is that only complete monikers are registered with the ROT, and if your moniker has a prefix, your moniker is part of a composite and thus not complete. Instead, your moniker should request services from the object identified by the prefix (for example, the container of the object identified by your moniker).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-irunningobjecttable-getobject#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.NoteChangeTime(System.UInt32,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IRunningObjectTable.NoteChangeTime(System.UInt32,System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.NoteChangeTime(System.UInt32,System.Runtime.InteropServices.ComTypes.FILETIME*)">
            <summary>Records the time that a running object was last modified. The object must have previously been registered with the running object table (ROT). This method stores the time of last change in the ROT.</summary>
            <param name="dwRegister">The identifier of the ROT entry of the changed object. This value was previously returned by <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-register">IRunningObjectTable::Register</a>.</param>
            <param name="pfiletime">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure containing the object's last change time.</param>
            <returns>This method can return the standard return values E_INVALIDARG and S_OK.</returns>
            <remarks>
            <para>The time recorded by this method can be retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-gettimeoflastchange">IRunningObjectTable::GetTimeOfLastChange</a>. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> A moniker provider (hands out monikers identifying its objects to make them accessible to others) must call the <b>NoteChangeTime</b> method whenever its objects are modified. It must have previously called <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-register">IRunningObjectTable::Register</a> and stored the identifier returned by that method; it uses that identifier when calling <b>NoteChangeTime</b>.</para>
            <para>The most common type of moniker provider is a compound-document link source. This includes server applications that support linking to their documents (or portions of a document) and container applications that support linking to embeddings within their documents. Server applications that do not support linking can also use the ROT to cooperate with container applications that support linking to embeddings.</para>
            <para>When an object is first registered in the ROT, the ROT records its last change time as the value returned by calling <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-gettimeoflastchange">IMoniker::GetTimeOfLastChange</a> on the moniker being registered.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-irunningobjecttable-notechangetime#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.GetTimeOfLastChange(Windows.Win32.System.Com.IMoniker*,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IRunningObjectTable.GetTimeOfLastChange(Windows.Win32.System.Com.IMoniker*,System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.GetTimeOfLastChange(Windows.Win32.System.Com.IMoniker*,System.Runtime.InteropServices.ComTypes.FILETIME*)">
            <summary>Retrieves the time that an object was last modified.</summary>
            <param name="pmkObjectName">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface on the moniker.</param>
            <param name="pfiletime">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that receives the object's last change time.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>This method returns the change time that was last reported for this object by a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-notechangetime">IRunningObjectTable::NoteChangeTime</a>. If <b>NoteChangeTime</b> has not been called previously, the method returns the time that was recorded when the object was registered. This method is provided to enable checking whether a connection between two objects (represented by one object holding a moniker that identifies the other) is up-to-date. For example, if one object is holding cached information about the other object, this method can be used to check whether the object has been modified since the cache was last updated. See <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-gettimeoflastchange">IMoniker::GetTimeOfLastChange</a>. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Generally, you call <b>GetTimeOfLastChange</b> only if you are writing your own moniker class (that is, implementing the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface). You typically call this method from your implementation of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-gettimeoflastchange">IMoniker::GetTimeOfLastChange</a>. However, you should do so only if the <i>pmkToLeft</i> parameter of <b>IMoniker::GetTimeOfLastChange</b> is <b>NULL</b>. Otherwise, you should call <b>IMoniker::GetTimeOfLastChange</b> on your <i>pmkToLeft</i> parameter instead.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-irunningobjecttable-gettimeoflastchange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IRunningObjectTable.EnumRunning(Windows.Win32.System.Com.IEnumMoniker**)">
            <summary>Creates and returns a pointer to an enumerator that can list the monikers of all the objects currently registered in the running object table (ROT).</summary>
            <param name="ppenumMoniker">A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienummoniker">IEnumMoniker</a> pointer variable that receives the interface pointer to the new enumerator for the ROT. When successful, the implementation calls <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> on the enumerator; it is the caller's responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a>. If an error occurs; the implementation sets *<i>ppenumMoniker</i> to <b>NULL</b>.</param>
            <returns>This method can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para><b>IRunningObjectTable::EnumRunning</b> must create and return a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienummoniker">IEnumMoniker</a> interface on an enumerator object. The standard enumerator methods can then be called to enumerate the monikers currently registered in the registry. The enumerator cannot be used to enumerate monikers that are registered in the ROT after the enumerator has been created. The <b>EnumRunning</b> method is intended primarily for the use by the system in implementing the alert object table. Note that OLE 2 does not include an implementation of the alert object table.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-irunningobjecttable-enumrunning#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IRunningObjectTable.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000010-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.ISequentialStream.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ISequentialStream.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ISequentialStream.Read(System.Void*,System.UInt32,System.UInt32*)">
            <summary>Reads a specified number of bytes from the stream object into memory, starting at the current seek pointer.</summary>
            <param name="pv">A pointer to the buffer which the stream data is read into.</param>
            <param name="cb">The number of bytes of data to read from the stream object.</param>
            <param name="pcbRead">
            <para>A pointer to a <b>ULONG</b> variable that receives the actual number of bytes read from the stream object. <div class="alert"><b>Note</b>  The number of bytes read may be zero.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-isequentialstream-read#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | All of the requested data was successfully read from the stream object; the number of bytes requested in *cb* is the same as the number of bytes returned in *pcbRead*.| |S_FALSE | The value returned in *pcbRead* is less than the number of bytes requested in *cb*. This indicates the end of the stream has been reached. The number of bytes read indicates how much of the *pv* buffer has been filled.| |E_PENDING | Asynchronous storage only: Part or all of the data to be read is currently unavailable. | |STG_E_ACCESSDENIED | The caller does not have permissions required to read this stream object.| |STG_E_INVALIDPOINTER | One of the pointer values is invalid.| |STG_E_REVERTED | The object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para>This method reads bytes from this stream object into memory. The stream object must be opened in <b>STGM_READ</b> mode. This method adjusts the seek pointer by the actual number of bytes read. The number of bytes actually read is also returned in the <i>pcbRead</i> parameter. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> The actual number of bytes read can be less than the number of bytes requested if an error occurs or if the end of the stream is reached during the read operation.  The number of bytes returned should always  be compared to the number of bytes requested.  If the number of bytes returned is less than the number of bytes requested, it usually means the <b>Read</b> method attempted to read  past the end of the stream. The application should handle both a returned error  and <b>S_OK</b> return values on end-of-stream read operations.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-isequentialstream-read#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ISequentialStream.Write(System.Void*,System.UInt32,System.UInt32*)">
            <summary>Writes a specified number of bytes into the stream object starting at the current seek pointer.</summary>
            <param name="pv">A pointer to the buffer that contains the data that is to be written to the stream. A valid pointer must be provided for this parameter even when <i>cb</i> is zero.</param>
            <param name="cb">The number of bytes of data to attempt to write into the stream. This value can be zero.</param>
            <param name="pcbWritten">A pointer to a <b>ULONG</b> variable where this method writes the actual number of bytes written to the stream object. The caller can set this pointer to <b>NULL</b>, in which case this method does not provide the actual number of bytes written.</param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The data was successfully written to the stream object.| |E_PENDING | Asynchronous Storage only: Part or all of the data to be written is currently unavailable.| |STG_E_MEDIUMFULL | The write operation failed because there is no space left on the storage device.| |STG_E_ACCESSDENIED | The caller does not have the required  permissions for writing to this stream object.| |STG_E_CANTSAVE | Data cannot be written for reasons other than improper access or insufficient space.| |STG_E_INVALIDPOINTER | One of the pointer values is not valid. The *pv* parameter must contain a valid pointer even if *cb* is zero.| |STG_E_REVERTED | The object has been invalidated by a revert operation above it in the transaction tree.| |STG_E_WRITEFAULT | The write operation failed due to a disk error. This value is also returned when this method attempts to write to a stream that was opened in simple mode (using the STGM_SIMPLE flag).|</para>
            </returns>
            <remarks>
            <para><b>ISequentialStream::Write</b> writes the specified data to a stream object. The seek pointer is adjusted for the number of bytes actually written. The number of bytes actually written is returned in the <i>pcbWritten</i> parameter. If the byte count is zero bytes, the write operation has no effect. If the seek pointer is currently past the end of the stream and the byte count is nonzero, this method increases the size of the stream to the seek pointer and writes the specified bytes starting at the seek pointer. The fill bytes written to the stream are not initialized to any particular value. This is the same as the end-of-file behavior in the MS-DOS FAT file system. With a zero byte count and a seek pointer past the end of the stream, this method does not create the fill bytes to increase the stream to the seek pointer. In this case, you must call the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-setsize">IStream::SetSize</a> method to increase the size of the stream and write the fill bytes. The <i>pcbWritten</i> parameter can have a value even if an error occurs. In the COM-provided implementation, stream objects are not sparse. Any fill bytes are eventually allocated on the disk and assigned to the stream.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-isequentialstream-write#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.ISequentialStream.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0c733a30-2a1c-11ce-ade5-00aa0044773d}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IServiceProvider.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IServiceProvider.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IServiceProvider.QueryService(System.Guid@,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IServiceProvider.QueryService(System.Guid*,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IServiceProvider.QueryService(System.Guid*,System.Guid*,System.Void**)">
            <summary>Acts as the factory method for any services exposed through an implementation of IServiceProvider. Accepts a CLSID parameter.</summary>
            <param name="guidService">The unique identifier of the service (an SID).</param>
            <param name="riid">The unique identifier of the interface that the caller wants to receive for the service.</param>
            <param name="ppvObject">The address of the caller-allocated variable to receive the interface pointer of the service on successful return from this function. The caller becomes responsible for calling [Release](../unknwn/nf-unknwn-iunknown-release.md) through this interface pointer when the service is no longer required.</param>
            <returns>S_OK on success.</returns>
            <remarks>**QueryService** creates or accesses the implementation of the service identified with guidService. In ppv, it returns the address of the interface that is specified by riid.</remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IServiceProvider.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{6d5140c1-7436-11ce-8034-00aa006009fa}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IStream.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.Seek(System.Int64,System.IO.SeekOrigin,System.UInt64*)">
            <summary>Changes the seek pointer to a new location. The new location is relative to either the beginning of the stream, the end of the stream, or the current seek pointer.</summary>
            <param name="dlibMove">The displacement to be added to the location indicated by the <i>dwOrigin</i> parameter. If <i>dwOrigin</i> is <b>STREAM_SEEK_SET</b>, this is interpreted as an unsigned value rather than a signed value.</param>
            <param name="dwOrigin">The origin for the displacement specified in <i>dlibMove</i>. The origin can be the beginning of the file (<b>STREAM_SEEK_SET</b>), the current seek pointer (<b>STREAM_SEEK_CUR</b>), or the end of the file (<b>STREAM_SEEK_END</b>). For more information about values, see the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-stream_seek">STREAM_SEEK</a> enumeration.</param>
            <param name="plibNewPosition">
            <para>A pointer to the location where this method writes the value of the new seek pointer from the beginning of the stream. You can set this pointer to <b>NULL</b>. In this case, this method does not provide the new seek pointer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-seek#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The seek pointer was successfully adjusted.| |E_PENDING | Asynchronous Storage only: Part or all of the stream data is currently unavailable. | |STG_E_INVALIDPOINTER | Indicates that *plibNewPosition* points to invalid memory, because *plibNewPosition* is not read.| |STG_E_INVALIDFUNCTION | The *dwOrigin* parameter contains an invalid value, or the *dlibMove* parameter contains a bad offset value. For example, the result of the seek pointer is a negative offset value.| |STG_E_REVERTED | The object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para><b>IStream::Seek</b> changes the seek pointer so that subsequent read and write operations can be performed at a different location in the stream object. It is an error to seek before the beginning of the stream. It is not, however, an error to seek past the end of the stream. Seeking past the end of the stream is useful for subsequent write operations, as the stream byte range will be extended to the new seek position immediately before the write is complete. You can also use this method to obtain the current value of the seek pointer by calling this method with the <i>dwOrigin</i> parameter set to <b>STREAM_SEEK_CUR</b> and the <i>dlibMove</i> parameter set to 0 so that the seek pointer is not changed. The current seek pointer is returned in the <i>plibNewPosition</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-seek#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.SetSize(System.UInt64)">
            <summary>Changes the size of the stream object.</summary>
            <param name="libNewSize">Specifies the new size, in bytes, of the stream.</param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The size of the stream object was successfully changed.| |E_PENDING | Asynchronous Storage only: Part or all of the stream's data is currently unavailable.| |STG_E_MEDIUMFULL | The stream size is not changed because there is no space left on the storage device.| |STG_E_INVALIDFUNCTION | The value of the *libNewSize* parameter is not supported by the implementation. Not all streams support greater than 232 bytes. If a stream does not support more than 232 bytes, the high DWORD data type of *libNewSize* must be zero. If it is nonzero, the implementation may return STG_E_INVALIDFUNCTION. In general, COM-based implementations of the IStream interface do not support streams larger than 232 bytes.| |STG_E_REVERTED | The object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para><b>IStream::SetSize</b> changes the size of the stream object. Call this method to preallocate space for the stream. If the <i>libNewSize</i> parameter is larger than the current stream size, the stream is extended to the indicated size by filling the intervening space with bytes of undefined value. This operation is similar to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-isequentialstream-write">ISequentialStream::Write</a> method if the seek pointer is past the current end of the stream. If the <i>libNewSize</i> parameter is smaller than the current stream, the stream is truncated to the indicated size. The seek pointer is not affected by the change in stream size. Calling <b>IStream::SetSize</b> can be an effective way to obtain a large chunk of contiguous space.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-setsize#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.CopyTo(Windows.Win32.System.Com.IStream*,System.UInt64,System.UInt64*,System.UInt64*)">
            <summary>Copies a specified number of bytes from the current seek pointer in the stream to the current seek pointer in another stream.</summary>
            <param name="pstm">A pointer to the destination stream. The stream pointed to by <i>pstm</i> can be a new stream or a clone of the source stream.</param>
            <param name="cb">The number of bytes to copy from the source stream.</param>
            <param name="pcbRead">A pointer to the location where this method writes the actual number of bytes read from the source. You can set this pointer to <b>NULL</b>. In this case, this method does not provide the actual number of bytes read.</param>
            <param name="pcbWritten">A pointer to the location where this method writes the actual number of bytes written to the destination. You can set this pointer to <b>NULL</b>. In this case, this method does not provide the actual number of bytes written.</param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The stream object was successfully copied.| |E_PENDING | Asynchronous Storage only: Part or all of the data to be copied is currently unavailable. | |STG_E_INVALIDPOINTER | The value of one of the pointer parameters is invalid.| |STG_E_MEDIUMFULL | The stream is not copied because there is no space left on the storage device.| |STG_E_REVERTED | The object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para>The <b>CopyTo</b> method copies the specified bytes from one stream to another. It can also be used to copy a stream to itself. The seek pointer in each stream instance is adjusted for the number of bytes read or written. This method is equivalent to reading <i>cb</i> bytes into memory using <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-isequentialstream-read">ISequentialStream::Read</a> and then immediately writing them to the destination stream using <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-isequentialstream-write">ISequentialStream::Write</a>, although <b>IStream::CopyTo</b> will be more efficient. The destination stream can be a clone of the source stream created by calling the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-clone">IStream::Clone</a> method. If <b>IStream::CopyTo</b> returns an error, you cannot assume that the seek pointers are valid for either the source or destination. Additionally, the values of <i>pcbRead</i> and <i>pcbWritten</i> are not meaningful even though they are returned. If <b>IStream::CopyTo</b> returns successfully, the actual number of bytes read and written are the same. To copy the remainder of the source from the current seek pointer, specify the maximum large integer value for the <i>cb</i> parameter. If the seek pointer is the beginning of the stream, this operation copies the entire stream.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-copyto#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.Commit(System.UInt32)">
            <summary>The Commit method ensures that any changes made to a stream object open in transacted mode are reflected in the parent storage.</summary>
            <param name="grfCommitFlags">
            <para>Controls how the changes for the stream object are committed. See the <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ne-wtypes-stgc">STGC</a> enumeration for a definition of these values.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-commit#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | Changes to the stream object were successfully committed to the parent level.| |E_PENDING | Asynchronous Storage only: Part or all of the stream's data is currently unavailable. | |STG_E_MEDIUMFULL | The commit operation failed due to lack of space on the storage device.| |STG_E_REVERTED | The object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para>The <b>Commit</b>  method ensures that changes to a stream object opened in transacted mode are reflected in the parent storage. Changes that have been made to the stream since it was opened or last committed are reflected to the parent storage object. If the parent is opened in transacted mode, the parent may revert at a later time, rolling back the changes to this stream object. The compound file implementation does not support the opening of streams in transacted mode, so this method has very little effect other than to flush memory buffers. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Stg/istream-compound-file-implementation">IStream - Compound File Implementation</a>. If the stream is open in direct mode, this method ensures that any memory buffers have been flushed out to the underlying storage object. This is much like a flush in traditional file systems. The <b>IStream::Commit</b> method is useful on a direct mode stream when the implementation of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface is a wrapper for underlying file system APIs. In this case, <b>IStream::Commit</b> would be connected to the file system's flush call.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-commit#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.Revert">
            <summary>The Revert method discards all changes that have been made to a transacted stream since the last IStream::Commit call. On streams open in direct mode and streams using the COM compound file implementation of IStream::Revert, this method has no effect.</summary>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The stream was successfully reverted to its previous version.| |E_PENDING | Asynchronous Storage only: Part or all of the stream's data is currently unavailable. |</para>
            </returns>
            <remarks>The <b>Revert</b> method discards changes made to a transacted stream since the last commit operation.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.LockRegion(System.UInt64,System.UInt64,System.UInt32)">
            <summary>The LockRegion method restricts access to a specified range of bytes in the stream.</summary>
            <param name="libOffset">Integer that specifies the byte offset for the beginning of the range.</param>
            <param name="cb">Integer that specifies the length of the range, in bytes, to be restricted.</param>
            <param name="dwLockType">Specifies the restrictions being requested on accessing the range.</param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The specified range of bytes was locked.| |E_PENDING | Asynchronous Storage only: Part or all of the stream's data is currently unavailable. | |STG_E_INVALIDFUNCTION | Locking is not supported at all or the specific type of lock requested is not supported.| |STG_E_LOCKVIOLATION | Requested lock is supported, but cannot be granted because of an existing lock.| |STG_E_REVERTED | The object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para>The byte range of the stream can be extended.  Locking an extended range for the stream is useful as a method of communication between different instances of the stream without changing data that is actually part of the stream. Three types of locking can be supported: locking to exclude other writers, locking to exclude other readers or writers, and locking that allows only one requester to obtain a lock on the given range, which is usually an alias for one of the other two lock types. A given stream instance might support either of the first two types, or both. The lock type is specified by <i>dwLockType</i>, using a value from the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-locktype">LOCKTYPE</a> enumeration. Any region locked with <b>IStream::LockRegion</b> must later be explicitly unlocked by calling <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-unlockregion">IStream::UnlockRegion</a> with exactly the same values for the <i>libOffset</i>, <i>cb</i>, and <i>dwLockType</i> parameters. The region must be unlocked before the stream is released. Two adjacent regions cannot be locked separately and then unlocked with a single unlock call. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> Since the type of locking supported is optional and can vary in different implementations of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>, you must provide code to deal with the STG_E_INVALIDFUNCTION error. The <b>LockRegion</b> method has no effect in the compound file implementation, because the implementation does not support range locking. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Support for this method is optional for implementations of stream objects since it may not be supported by the underlying file system. The type of locking supported is also optional. The STG_E_INVALIDFUNCTION error is returned if the requested type of locking is not supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-lockregion#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.UnlockRegion(System.UInt64,System.UInt64,System.UInt32)">
            <summary>The UnlockRegion method removes the access restriction on a range of bytes previously restricted with IStream::LockRegion.</summary>
            <param name="libOffset">Specifies the byte offset for the beginning of the range.</param>
            <param name="cb">Specifies, in bytes, the length of the range to be restricted.</param>
            <param name="dwLockType">Specifies the access restrictions previously placed on the range.</param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The byte range was unlocked.| |E_PENDING | Asynchronous Storage only: Part or all of the stream's data is currently unavailable.| |STG_E_INVALIDFUNCTION | Locking is not supported at all or the specific type of lock requested is not supported.| |STG_E_LOCKVIOLATION | The requested unlock operation cannot be granted.| |STG_E_REVERTED | The object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para><b>IStream::UnlockRegion</b> unlocks a region previously locked with the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-lockregion">IStream::LockRegion</a> method. Locked regions must later be explicitly unlocked by calling <b>IStream::UnlockRegion</b> with exactly the same values for the <i>libOffset</i>, <i>cb</i>, and <i>dwLockType</i> parameters. The region must be unlocked before the stream is released. Two adjacent regions cannot be locked separately and then unlocked with a single unlock call.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-unlockregion#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.Stat(Windows.Win32.System.Com.STATSTG@,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IStream.Stat(Windows.Win32.System.Com.STATSTG*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.Stat(Windows.Win32.System.Com.STATSTG*,System.UInt32)">
            <summary>The Stat method retrieves the STATSTG structure for this stream.</summary>
            <param name="pstatstg">
            <para>Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structure where this method places information about this stream object.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-stat#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="grfStatFlag">
            <para>Specifies that this method does not return some of the members in the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structure, thus saving a memory allocation operation. Values are taken from the <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ne-wtypes-statflag">STATFLAG</a> enumeration.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-stat#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The STATSTG structure was successfully returned at the specified location.| |E_PENDING | Asynchronous Storage only: Part or all of the stream's data is currently unavailable. | |STG_E_ACCESSDENIED | The caller does not have enough permissions for accessing statistics for this storage object.| |STG_E_INSUFFICIENTMEMORY | The STATSTG structure was not returned due to a lack of memory.| |STG_E_INVALIDFLAG | The value for the *grfStateFlag* parameter is not valid.| |STG_E_INVALIDPOINTER | The *pStatStg* pointer is not valid.| |STG_E_REVERTED | The object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para><b>IStream::Stat</b> retrieves a pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structure that contains information about this open stream. When this stream is within a structured storage and <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-enumelements">IStorage::EnumElements</a> is called, it creates an enumerator object with the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstatstg">IEnumSTATSTG</a> interface on it, which can be called to enumerate the storages and streams through the <b>STATSTG</b> structures associated with each of them.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-stat#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.IStream.Clone(Windows.Win32.System.Com.IStream**)">
            <summary>The Clone method creates a new stream object with its own seek pointer that references the same bytes as the original stream.</summary>
            <param name="ppstm">
            <para>When successful, pointer to the location of an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> pointer to the new stream object. If an error occurs, this parameter is <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-clone#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. | Return code | Description | |----------------|---------------| |S_OK | The stream was successfully cloned.| |E_PENDING | Asynchronous Storage only: Part or all of the stream's data is currently unavailable. | |STG_E_INSUFFICIENTMEMORY | The stream was not cloned due to a lack of memory.| |STG_E_INVALIDPOINTER | The ppStm pointer is not valid.| |STG_E_REVERTED | The object has been invalidated by a revert operation above it in the transaction tree.|</para>
            </returns>
            <remarks>
            <para>The <b>Clone</b> method creates a new stream object for accessing the same bytes but using a separate seek pointer. The new stream object sees the same data as the source-stream object. Changes written to one object are immediately visible in the other. Range locking is shared between the stream objects. The initial setting of the seek pointer in the cloned stream instance is the same as the current setting of the seek pointer in the original stream at the time of the clone operation.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-istream-clone#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.IStream.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0000000c-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeComp.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeComp.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeComp.Bind(Windows.Win32.Foundation.PWSTR,System.UInt32,System.UInt16,Windows.Win32.System.Com.ITypeInfo**,Windows.Win32.System.Com.DESCKIND@,Windows.Win32.System.Com.BINDPTR@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeComp.Bind(Windows.Win32.Foundation.PWSTR,System.UInt32,System.UInt16,Windows.Win32.System.Com.ITypeInfo**,Windows.Win32.System.Com.DESCKIND*,Windows.Win32.System.Com.BINDPTR*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeComp.Bind(Windows.Win32.Foundation.PWSTR,System.UInt32,System.UInt16,Windows.Win32.System.Com.ITypeInfo**,Windows.Win32.System.Com.DESCKIND*,Windows.Win32.System.Com.BINDPTR*)">
            <summary>Maps a name to a member of a type, or binds global variables and functions contained in a type library.</summary>
            <param name="szName">The name to be bound.</param>
            <param name="lHashVal">The hash value for the name computed by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-lhashvalofnamesys">LHashValOfNameSys</a>.</param>
            <param name="wFlags">One or more of the flags defined in the INVOKEKIND enumeration. Specifies whether the name was referenced as a method or a property. When binding to a variable, specify the flag INVOKE_PROPERTYGET. Specify zero to bind to any type of member.</param>
            <param name="ppTInfo">If a FUNCDESC or VARDESC was returned, then <i>ppTInfo</i> points to a pointer to the type description that contains the item to which it is bound.</param>
            <param name="pDescKind">Indicates whether the name bound to is a VARDESC, FUNCDESC, or TYPECOMP. If there was no match, DESCKIND_NONE.</param>
            <param name="pBindPtr">The bound-to VARDESC, FUNCDESC, or <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> interface.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>Use <b>Bind</b> for binding to the variables and methods of a type, or for binding to the global variables and methods in a type library. The returned DESCKIND pointer <i>pDescKind</i> indicates whether the name was bound to a VARDESC, a FUNCDESC, or to an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> instance. The returned <i>pBindPtr</i> points to the VARDESC, FUNCDESC, or <b>ITypeComp</b>. If a data member or method is bound to, then ppTInfopoints to the type description that contains the method or data member.</para>
            <para>If <b>Bind</b> binds the name to a nested binding context, it returns a pointer to an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> instance in <i>pBindPtr</i> and a null type description pointer in <i>ppTInfo</i>. For example, if the name of a type description is passed for a module (TKIND_MODULE), enumeration (TKIND_ENUM), or coclass (TKIND_COCLASS), Bind returns the <b>ITypeComp</b> instance of the type description for the module, enumeration, or coclass. This feature supports languages such as Visual Basic that allow references to members of a type description to be qualified by the name of the type description. For example, a function in a module can be referenced by <i>modulename</i>.<i>functionname.</i> The members of TKIND_ENUM, TKIND_MODULE, and TKIND_COCLASS types marked as Application objects can be bound to directly from <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a>, without specifying the name of the module. The <b>ITypeComp</b> of a coclass defers to the <b>ITypeComp</b> of its default interface.</para>
            <para>As with other methods of <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a>, <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</a>, and <b>ITypeInfo</b>, the calling code is responsible for releasing the returned object instances or structures. If a VARDESC or FUNCDESC is returned, the caller is responsible for deleting it with the returned type description and releasing the type description instance itself. Otherwise, if an <b>ITypeComp</b> instance is returned, the caller must release it.</para>
            <para>Special rules apply if you call a type library's <b>Bind</b> method, passing it the name of a member of an Application object class (a class that has the TYPEFLAG_FAPPOBJECT flag set). In this case, Bind returns DESCKIND_IMPLICITAPPOBJ in <i>pDescKind</i>, a VARDESC that describes the Application object in <i>pBindPtr</i>, and the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</a> of the Application object class in <i>ppTInfo</i>. To bind to the object, <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypeinfo-gettypecomp">ITypeInfo::GetTypeComp</a> must make a call to get the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> of the Application object class, and then reinvoke its <b>Bind</b> method with the name initially passed to the type library's <b>ITypeComp</b>.</para>
            <para>The caller should use the returned <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</a> pointer (<i>ppTInfo</i>) to get the address of the member.</para>
            <para><div class="alert"><b>Note</b>  The <i>wflags</i> parameter is the same as the <i>wflags</i> parameter in <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-invoke">IDispatch::Invoke</a>. </div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypecomp-bind#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeComp.BindType(Windows.Win32.Foundation.PWSTR,System.UInt32,Windows.Win32.System.Com.ITypeInfo**,Windows.Win32.System.Com.ITypeComp**)">
            <summary>Binds to the type descriptions contained within a type library.</summary>
            <param name="szName">The name to be bound.</param>
            <param name="lHashVal">The hash value for the name computed by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-lhashvalofname">LHashValOfName</a>.</param>
            <param name="ppTInfo">An <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</a> of the type to which the name was bound.</param>
            <param name="ppTComp">Passes a valid pointer, such as the address of an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> variable.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>Use the function <b>BindType</b> for binding a type name to the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</a> that describes the type. This function is invoked on the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> that is returned by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypelib-gettypecomp">ITypeLib::GetTypeComp</a> to bind to types defined within that library. It can also be used in the future for binding to nested types.</remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.ITypeComp.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00020403-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetTypeInfoCount">
            <summary>Provides the number of type descriptions that are in a type library.</summary>
            <returns>The number of type descriptions in the type library.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypelib-gettypeinfocount">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetTypeInfo(System.UInt32,Windows.Win32.System.Com.ITypeInfo**)">
            <summary>Retrieves the specified type description in the library.</summary>
            <param name="index">The index of the interface to be returned.</param>
            <param name="ppTInfo">If successful, returns a pointer to the pointer to the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</a> interface.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>For dual interfaces, <b>GetTypeInfo</b> returns only the TKIND_DISPATCH type information. To get the TKIND_INTERFACE type information, <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypeinfo-getreftypeofimpltype">GetRefTypeOfImplType</a> can be called on the TKIND_DISPATCH type information, passing an index of –1. Then, the returned type information handle can be passed to <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypeinfo-getreftypeinfo">GetRefTypeInfo</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetTypeInfoType(System.UInt32,Windows.Win32.System.Com.TYPEKIND@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.GetTypeInfoType(System.UInt32,Windows.Win32.System.Com.TYPEKIND*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetTypeInfoType(System.UInt32,Windows.Win32.System.Com.TYPEKIND*)">
            <summary>Retrieves the type of a type description.</summary>
            <param name="index">The index of the type description within the type library.</param>
            <param name="pTKind">The <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/ne-oaidl-typekind">TYPEKIND</a> enumeration value for the type description.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypelib-gettypeinfotype">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetTypeInfoOfGuid(System.Guid@,Windows.Win32.System.Com.ITypeInfo**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.GetTypeInfoOfGuid(System.Guid*,Windows.Win32.System.Com.ITypeInfo**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetTypeInfoOfGuid(System.Guid*,Windows.Win32.System.Com.ITypeInfo**)">
            <summary>Retrieves the type description that corresponds to the specified GUID.</summary>
            <param name="guid">The GUID of the type description.</param>
            <param name="ppTinfo">The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</a> interface.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypelib-gettypeinfoofguid">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetLibAttr(Windows.Win32.System.Com.TLIBATTR*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.GetLibAttr(Windows.Win32.System.Com.TLIBATTR**)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetLibAttr(Windows.Win32.System.Com.TLIBATTR**)">
            <summary>Retrieves the structure that contains the library's attributes.</summary>
            <param name="ppTLibAttr">The library's attributes.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>Use <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypelib-releasetlibattr">ITypeLib::ReleaseTLibAttr</a> to free the memory occupied by the TLIBATTR structure.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetTypeComp(Windows.Win32.System.Com.ITypeComp**)">
            <summary>Enables a client compiler to bind to the types, variables, constants, and global functions for a library.</summary>
            <param name="ppTComp">The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> instance for this <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypelib">ITypeLib</a>. A client compiler uses the methods in the <b>ITypeComp</b> interface to bind to types in <b>ITypeLib</b>, as well as to the global functions, variables, and constants defined in <b>ITypeLib</b></param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/nf-oaidl-itypecomp-bind">Bind</a> function of the returned <b>TypeComp</b> binds to global functions, variables, constants, enumerated values, and coclass members. The <b>Bind</b> function also binds the names of the TYPEKIND enumerations of TKIND_MODULE, TKIND_ENUM, and TKIND_COCLASS. These names shadow any global names defined within the type information. The members of TKIND_ENUM, TKIND_MODULE, and TKIND_COCLASS types marked as Application objects can be directly bound to from <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> without specifying the name of the module.</para>
            <para><a href="https://docs.microsoft.com/windows/desktop/api/oaidl/nf-oaidl-itypecomp-bind">ITypeComp::Bind</a> and <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypecomp-bindtype">ITypeComp::BindType</a> accept only unqualified names. <b>ITypeLib::GetTypeComp</b> returns a pointer to the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-itypecomp">ITypeComp</a> interface, which is then used to bind to global elements in the library. The names of some types (TKIND_ENUM, TKIND_MODULE, and TKIND_COCLASS) share the name space with variables, functions, constants, and enumerators. If a member requires qualification to differentiate it from other items in the name space, <b>GetTypeComp</b> can be called successively for each qualifier in order to bind to the desired member. This allows programming language compilers to access members of modules, enumerations, and coclasses, even though the member can't be bound to with a qualified name.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypelib-gettypecomp#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetDocumentation(System.Int32,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt32@,Windows.Win32.Foundation.BSTR*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.GetDocumentation(System.Int32,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt32*,Windows.Win32.Foundation.BSTR*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.GetDocumentation(System.Int32,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt32*,Windows.Win32.Foundation.BSTR*)">
            <summary>Retrieves the documentation string for the library, the complete Help file name and path, and the context identifier for the library Help topic in the Help file.</summary>
            <param name="index">The index of the type description whose documentation is to be returned. If <i>index</i> is -1, then the documentation for the library itself is returned.</param>
            <param name="pBstrName">The name of the specified item. If the caller does not need the item name, then <i>pBstrName</i> can be null.</param>
            <param name="pBstrDocString">The documentation string for the specified item. If the caller does not need the documentation string, then <i>pBstrDocString</i> can be null..</param>
            <param name="pdwHelpContext">The Help context identifier (ID) associated with the specified item. If the caller does not need the Help context ID, then <i>pdwHelpContext</i> can be null.</param>
            <param name="pBstrHelpFile">The fully qualified name of the Help file. If the caller does not need the Help file name, then <i>pBstrHelpFile</i> can be null.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>The caller should free the parameters <i>pBstrName</i>, <i>pBstrDocString</i>, and <i>pBstrHelpFile</i>.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.IsName(System.Span{System.Char}@,System.UInt32,Windows.Win32.Foundation.BOOL@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.IsName(Windows.Win32.Foundation.PWSTR,System.UInt32,Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.IsName(Windows.Win32.Foundation.PWSTR,System.UInt32,Windows.Win32.Foundation.BOOL*)">
            <summary>Indicates whether a passed-in string contains the name of a type or member described in the library.</summary>
            <param name="szNameBuf">The string to test. If this method is successful, <i>szNameBuf</i> is modified to match the case (capitalization) found in the type library.</param>
            <param name="lHashVal">The hash value of <i>szNameBuf</i>.</param>
            <param name="pfName">True if <i>szNameBuf</i> was found in the type library; otherwise false.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypelib-isname">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.FindName(System.Span{System.Char}@,System.UInt32,Windows.Win32.System.Com.ITypeInfo**,System.Int32*,System.UInt16@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.FindName(Windows.Win32.Foundation.PWSTR,System.UInt32,Windows.Win32.System.Com.ITypeInfo**,System.Int32*,System.UInt16*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.FindName(Windows.Win32.Foundation.PWSTR,System.UInt32,Windows.Win32.System.Com.ITypeInfo**,System.Int32*,System.UInt16*)">
            <summary>Finds occurrences of a type description in a type library. This may be used to quickly verify that a name exists in a type library.</summary>
            <param name="szNameBuf">The name to search for.</param>
            <param name="lHashVal">A hash value to speed up the search, computed by the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-lhashvalofnamesys">LHashValOfNameSys</a> function. If <i>lHashVal</i> = 0, a value is computed.</param>
            <param name="ppTInfo">An array of pointers to the type descriptions that contain the name specified in <i>szNameBuf</i>. This parameter cannot be null.</param>
            <param name="rgMemId">An array of the found items; <i>rgMemId</i>[<i>i</i>] is the MEMBERID that indexes into the type description specified by <i>ppTInfo</i>[<i>i</i>]. This parameter cannot be null.</param>
            <param name="pcFound">
            <para>On entry, indicates how many instances to look for. For example, *<i>pcFound</i> = 1 can be called to find the first occurrence. The search stops when one is found. On exit, indicates the number of instances that were found. If the in and out values of *<i>pcFound</i> are identical, there may be more type descriptions that contain the name.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypelib-findname#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>Passing *<i>pcFound</i> = <i>n</i> indicates that there is enough room in the <i>ppTInfo</i> and <i>rgMemId</i> arrays for <i>n</i> (<i>ptinfo</i>, <i>memid</i>) pairs. The function returns MEMBERID_NIL in <i>rgMemId</i>[<i>i</i>], if the name in <i>szNameBuf</i> is the name of the type information in <i>ppTInfo</i>[<i>i</i>].</remarks>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.ReleaseTLibAttr(Windows.Win32.System.Com.TLIBATTR@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.ReleaseTLibAttr(Windows.Win32.System.Com.TLIBATTR*)"/>
        </member>
        <member name="M:Windows.Win32.System.Com.ITypeLib.ReleaseTLibAttr(Windows.Win32.System.Com.TLIBATTR*)">
            <summary>Releases the TLIBATTR originally obtained from GetLibAttr.</summary>
            <param name="pTLibAttr">The TLIBATTR to be freed.</param>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-itypelib-releasetlibattr">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.ITypeLib.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00020402-0000-0000-c000-000000000046}</value>
        </member>
        <member name="T:Windows.Win32.System.Com.LOCKTYPE">
            <summary>The LOCKTYPE enumeration values indicate the type of locking requested for the specified range of bytes. The values are used in the ILockBytes::LockRegion and IStream::LockRegion methods.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ne-objidl-locktype">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.LOCKTYPE.LOCK_WRITE">
            <summary>If this lock is granted, the specified range of bytes can be opened and read any number of times, but writing to the locked range is prohibited except for the owner that was granted this lock.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.LOCKTYPE.LOCK_EXCLUSIVE">
            <summary>If this lock is granted, writing to the specified range of bytes is prohibited except by the owner that was granted this lock.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.LOCKTYPE.LOCK_ONLYONCE">
            <summary>If this lock is granted, no other <b>LOCK_ONLYONCE</b> lock can be obtained on the range. Usually this lock type is an alias for some other lock type. Thus, specific implementations can have additional behavior associated with this lock type.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.SAFEARRAYBOUND">
            <summary>Represents the bounds of one dimension of the array.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-safearraybound">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.SAFEARRAYBOUND.cElements">
            <summary>The number of elements in the dimension.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.SAFEARRAYBOUND.lLbound">
            <summary>The lower bound of the dimension.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.STATDATA">
            <summary>Contains information used to specify each advisory connection.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ns-objidl-statdata">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.STATDATA.formatetc">
            <summary>The <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structure for the data of interest to the advise sink. The advise sink receives notification of changes to the data specified by this <b>FORMATETC</b> structure.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATDATA.advf">
            <summary>The <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-advf">ADVF</a> enumeration value that determines when the advisory sink is notified of changes in the data.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATDATA.pAdvSink">
            <summary>The pointer for the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-iadvisesink">IAdviseSink</a> interface that will receive change notifications.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATDATA.dwConnection">
            <summary>The token that uniquely identifies the advisory connection. This token is returned by the method that sets up the advisory connection.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.STATFLAG">
            <summary>Indicate whether the method should try to return a name in the pwcsName member of the STATSTG structure.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypes/ne-wtypes-statflag">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.STATFLAG.STATFLAG_DEFAULT">
            <summary>
            <para>Requests that the statistics include the <b>pwcsName</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypes/ne-wtypes-statflag#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATFLAG.STATFLAG_NONAME">
            <summary>
            <para>Requests that the statistics not include the <b>pwcsName</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structure. If the name is omitted, there is no need for the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ilockbytes-stat">ILockBytes::Stat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-stat">IStorage::Stat</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-stat">IStream::Stat</a> methods methods to allocate and free memory for the string value of the name, therefore the method reduces time and resources used in an allocation and free operation.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypes/ne-wtypes-statflag#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATFLAG.STATFLAG_NOOPEN">
            <summary>Not implemented.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.STATSTG">
            <summary>Contains statistical data about an open storage, stream, or byte-array object.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ns-objidl-statstg">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.STATSTG.pwcsName">
            <summary>
            <para>A pointer to a <b>NULL</b>-terminated Unicode string that contains the name. Space for this string is allocated by the method called and freed by the caller (for more information, see <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>). To  not return this member, specify the STATFLAG_NONAME value when you call a method that returns a <b>STATSTG</b> structure, except for calls to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumstatstg">IEnumSTATSTG::Next</a>, which provides no way to specify this value.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ns-objidl-statstg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATSTG.type">
            <summary>
            <para>Indicates the type of storage object. This is one of the values from the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ne-objidl-stgty">STGTY</a> enumeration.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ns-objidl-statstg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATSTG.cbSize">
            <summary>Specifies the size, in bytes, of the stream or byte array.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATSTG.mtime">
            <summary>Indicates the last modification time for this storage, stream, or byte array.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATSTG.ctime">
            <summary>Indicates the creation time for this storage, stream, or byte array.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATSTG.atime">
            <summary>Indicates the last access time for this storage, stream, or byte array.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATSTG.grfMode">
            <summary>
            <para>Indicates the access mode specified when the object was opened. This member is only valid in calls to <b>Stat</b> methods.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ns-objidl-statstg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATSTG.clsid">
            <summary>Indicates the class identifier for the storage object; set to CLSID_NULL for new storage objects. This member is not used for streams or byte arrays.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATSTG.grfStateBits">
            <summary>
            <para>Indicates the current state bits of the storage object; that is, the value most recently set by the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istorage-setstatebits">IStorage::SetStateBits</a> method. This member is not valid for streams or byte arrays.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ns-objidl-statstg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STATSTG.reserved">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.STGM">
            <summary>Flags that indicate conditions for creating and deleting the object and access modes for the object.</summary>
            <remarks>You can combine these flags, but you can only choose one flag from each group of related flags. Typically one flag from each of the access and sharing groups must be specified for all functions and methods which use these constants. Flags from other groups are optional.</remarks>
        </member>
        <member name="T:Windows.Win32.System.Com.STGTY">
            <summary>The STGTY enumeration values are used in the type member of the STATSTG structure to indicate the type of the storage element. A storage element is a storage object, a stream object, or a byte-array object (LOCKBYTES).</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/ne-objidl-stgty">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.STGTY.STGTY_STORAGE">
            <summary>Indicates that the storage element is a storage object.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STGTY.STGTY_STREAM">
            <summary>Indicates that the storage element is a stream object.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STGTY.STGTY_LOCKBYTES">
            <summary>Indicates that the storage element is a byte-array object.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.STGTY.STGTY_PROPERTY">
            <summary>Indicates that the storage element is a property storage object.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.SYSKIND">
            <summary>Identifies the target operating system platform.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ne-oaidl-syskind">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.SYSKIND.SYS_WIN16">
            <summary>The target operating system for the type library is 16-bit Windows. By default, data members are packed.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.SYSKIND.SYS_WIN32">
            <summary>The target operating system for the type library is 32-bit Windows. By default, data members are naturally aligned (for example, 2-byte integers are aligned on even-byte boundaries; 4-byte integers are aligned on quad-word boundaries, and so on).</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.SYSKIND.SYS_MAC">
            <summary>The target operating system for the type library is Apple Macintosh. By default, all data members are aligned on even-byte boundaries.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.SYSKIND.SYS_WIN64">
            <summary>The target operating system for the type library is 64-bit Windows.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.TLIBATTR">
            <summary>Contains information about a type library. Information from this structure is used to identify the type library and to provide national language support for member names.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-tlibattr">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.TLIBATTR.guid">
            <summary>The globally unique identifier.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TLIBATTR.lcid">
            <summary>The locale identifier.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TLIBATTR.syskind">
            <summary>The target hardware platform.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TLIBATTR.wMajorVerNum">
            <summary>The major version number.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TLIBATTR.wMinorVerNum">
            <summary>The minor version number.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TLIBATTR.wLibFlags">
            <summary>The library flags.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.TYMED">
            <summary>Indicates the type of storage medium being used in a data transfer. They are used in the STGMEDIUM or FORMATETC structures.</summary>
            <remarks>During data transfer operations, a storage medium is specified. This medium must be released after the data transfer operation. The provider of the medium indicates its choice of ownership scenarios in the value it provides in the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> structure. A <b>NULL</b> value for the <b>pUnkForRelease</b> member indicates that the receiving body of code owns and can free the medium. A non-<b>NULL</b> pointer specifies that <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-releasestgmedium">ReleaseStgMedium</a> can always be called to free the medium.</remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.TYMED.TYMED_HGLOBAL">
            <summary>The storage medium is a global memory handle (<b>HGLOBAL</b>). Allocate the global handle with the GMEM_MOVEABLE flag. If the <b>punkForRelease</b> member of <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> is <b>NULL</b>, the destination process should use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalfree">GlobalFree</a> to release the memory.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYMED.TYMED_FILE">
            <summary>The storage medium is a disk file identified by a path. If the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> <b>punkForRelease</b> member is <b>NULL</b>, the destination process should use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openfile">OpenFile</a> to delete the file.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYMED.TYMED_ISTREAM">
            <summary>The storage medium is a stream object identified by an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> pointer. Use <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-isequentialstream-read">ISequentialStream::Read</a> to read the data. If the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> <b>punkForRelease</b> member is not <b>NULL</b>, the destination process should use <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> to release the stream component.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYMED.TYMED_ISTORAGE">
            <summary>The storage medium is a storage component identified by an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> pointer. The data is in the streams and storages contained by this <b>IStorage</b> instance. If the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> <b>punkForRelease</b> member is not <b>NULL</b>, the destination process should use <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> to release the storage component.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYMED.TYMED_GDI">
            <summary>The storage medium is a GDI component (<b>HBITMAP</b>). If the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> <b>punkForRelease</b> member is <b>NULL</b>, the destination process should use <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a> to delete the bitmap.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYMED.TYMED_MFPICT">
            <summary>The storage medium is a metafile (<b>METAFILEPICT</b>). Use the GDI functions to access the metafile's data. If the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> <b>punkForRelease</b> member is <b>NULL</b>, the destination process should use <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deletemetafile">DeleteMetaFile</a> to delete the bitmap.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYMED.TYMED_ENHMF">
            <summary>The storage medium is an enhanced metafile (<b>HENHMETAFILE</b>). If the <a href="https://docs.microsoft.com/windows/win32/api/objidl/ns-objidl-ustgmedium-r1">STGMEDIUM</a> <b>punkForRelease</b> member is <b>NULL</b>, the destination process should use <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteenhmetafile">DeleteEnhMetaFile</a> to delete the bitmap.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYMED.TYMED_NULL">
            <summary>No data is being passed.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.TYPEATTR">
            <summary>Contains attributes of a type.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-typeattr">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.guid">
            <summary>The GUID of the type information.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.lcid">
            <summary>The locale of member names and documentation strings.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.dwReserved">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.memidConstructor">
            <summary>The constructor ID, or MEMBERID_NIL if none.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.memidDestructor">
            <summary>The destructor ID, or MEMBERID_NIL if none.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.lpstrSchema">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.cbSizeInstance">
            <summary>The size of an instance of this type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.typekind">
            <summary>The kind of type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.cFuncs">
            <summary>The number of functions.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.cVars">
            <summary>The number of variables or data members.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.cImplTypes">
            <summary>The number of implemented interfaces.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.cbSizeVft">
            <summary>The size of this type's VTBL.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.cbAlignment">
            <summary>The byte alignment for an instance of this type. A value of 0 indicates alignment on the 64K boundary; 1 indicates no special alignment. For other values, <i>n</i> indicates aligned on byte <i>n</i>.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.wTypeFlags">
            <summary>The type flags. See <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/ne-oaidl-typeflags">TYPEFLAGS</a>.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.wMajorVerNum">
            <summary>The major version number.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.wMinorVerNum">
            <summary>The minor version number.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.tdescAlias">
            <summary>If <b>typekind</b> is TKIND_ALIAS, specifies the type for which this type is an alias.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEATTR.idldescType">
            <summary>The IDL attributes of the described type.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.TYPEDESC">
            <summary>Describes the type of a variable, the return type of a function, or the type of a function parameter.</summary>
            <remarks>If the variable is VT_SAFEARRAY or VT_PTR, the union portion of the TYPEDESC contains a pointer to a TYPEDESC that specifies the element type.</remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEDESC.vt">
            <summary>The variant type.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.TYPEKIND">
            <summary>Specifies a type.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ne-oaidl-typekind">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEKIND.TKIND_ENUM">
            <summary>A set of enumerators.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEKIND.TKIND_RECORD">
            <summary>A structure with no methods.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEKIND.TKIND_MODULE">
            <summary>A module that can only have static functions and data (for example, a DLL).</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEKIND.TKIND_INTERFACE">
            <summary>A type that has virtual and pure functions.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEKIND.TKIND_DISPATCH">
            <summary>A set of methods and properties that are accessible through <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-invoke">IDispatch::Invoke</a>. By default, dual interfaces return TKIND_DISPATCH.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEKIND.TKIND_COCLASS">
            <summary>A set of implemented component object interfaces.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEKIND.TKIND_ALIAS">
            <summary>A type that is an alias for another type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEKIND.TKIND_UNION">
            <summary>A union, all of whose members have an offset of zero.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.TYPEKIND.TKIND_MAX">
            <summary>End of enum marker.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.VARDESC">
            <summary>Describes a variable, constant, or data member.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-vardesc">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.VARDESC.memid">
            <summary>The member ID.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARDESC.lpstrSchema">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARDESC.elemdescVar">
            <summary>The variable type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARDESC.wVarFlags">
            <summary>The variable flags. See <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/ne-oaidl-varflags">VARFLAGS</a>.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARDESC.varkind">
            <summary>The variable type.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.VARFLAGS">
            <summary>Specifies variable flags.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ne-oaidl-varflags">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FREADONLY">
            <summary>Assignment to the variable should not be allowed.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FSOURCE">
            <summary>The variable returns an object that is a source of events.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FBINDABLE">
            <summary>The variable supports data binding.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FREQUESTEDIT">
            <summary>When set, any attempt to directly change the property results in a call to <b>IPropertyNotifySink::OnRequestEdit</b>. The implementation of <b>OnRequestEdit</b> determines if the change is accepted.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FDISPLAYBIND">
            <summary>The variable is displayed to the user as bindable. VARFLAG_FBINDABLE must also be set.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FDEFAULTBIND">
            <summary>The variable is the single property that best represents the object. Only one variable in type information can have this attribute.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FHIDDEN">
            <summary>The variable should not be displayed to the user in a browser, although it exists and is bindable.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FRESTRICTED">
            <summary>The variable should not be accessible from macro languages. This flag is intended for system-level variables or variables that you do not want type browsers to display.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FDEFAULTCOLLELEM">
            <summary>Permits an optimization in which the compiler looks for a member named "xyz" on the type of abc. If such a member is found and is flagged as an accessor function for an element of the default collection, then a call is generated to that member function. Permitted on members in dispinterfaces and interfaces; not permitted on modules.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FUIDEFAULT">
            <summary>The variable is the default display in the user interface.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FNONBROWSABLE">
            <summary>The variable appears in an object browser, but not in a properties browser.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FREPLACEABLE">
            <summary>Tags the interface as having default behaviors.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARFLAGS.VARFLAG_FIMMEDIATEBIND">
            <summary>The variable is mapped as individual bindable properties.</summary>
        </member>
        <member name="T:Windows.Win32.System.Com.VARKIND">
            <summary>Specifies the variable type.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ne-oaidl-varkind">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Com.VARKIND.VAR_PERINSTANCE">
            <summary>The variable is a field or member of the type. It exists at a fixed offset within each instance of the type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARKIND.VAR_STATIC">
            <summary>There is only one instance of the variable.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARKIND.VAR_CONST">
            <summary>The VARDESC describes a symbolic constant. There is no memory associated with it.</summary>
        </member>
        <member name="F:Windows.Win32.System.Com.VARKIND.VAR_DISPATCH">
            <summary>The variable can only be accessed through <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-idispatch-invoke">IDispatch::Invoke</a>.</summary>
        </member>
        <member name="T:Windows.Win32.System.Ole.ARRAYDESC">
            <summary>Describes an array, its element type, and its dimension.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-arraydesc">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Ole.ARRAYDESC.tdescElem">
            <summary>The element type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Ole.ARRAYDESC.cDims">
            <summary>The dimension count.</summary>
        </member>
        <member name="F:Windows.Win32.System.Ole.ARRAYDESC.rgbounds">
            <summary>A variable-length array containing one element for each dimension.</summary>
        </member>
        <member name="M:Windows.Win32.System.Ole.ARRAYDESC.SizeOf(System.Int32)">
            <summary>Computes the amount of memory that must be allocated to store this struct, including the specified number of elements in the variable length inline array at the end.</summary>
        </member>
        <member name="T:Windows.Win32.System.Ole.DROPEFFECT">
            <summary>Represents information about the effects of a drag-and-drop operation.</summary>
            <remarks>
            <para>Your application should always mask values from the **DROPEFFECT** enumeration to ensure compatibility with future implementations. Presently, only some of the positions in a **DROPEFFECT** value have meaning. In the future, more interpretations for the bits will be added. Drag sources and drop targets should carefully mask these values appropriately before comparing. They should never compare a **DROPEFFECT** against, say, DROPEFFECT\_COPY by doing the following: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/com/dropeffect-constants#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDispatchEx.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDispatchEx.GetTypeInfoCount(System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.GetTypeInfoCount(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDispatchEx.GetIDsOfNames(System.Guid@,System.ReadOnlySpan{Windows.Win32.Foundation.PWSTR},System.UInt32,System.Span{System.Int32})">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.GetIDsOfNames(System.Guid*,Windows.Win32.Foundation.PWSTR*,System.UInt32,System.UInt32,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDispatchEx.Invoke(System.Int32,System.Guid@,System.UInt32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS@,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.Invoke(System.Int32,System.Guid*,System.UInt32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS*,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDispatchEx.GetDispID(Windows.Win32.Foundation.BSTR,System.UInt32,System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.GetDispID(Windows.Win32.Foundation.BSTR,System.UInt32,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDispatchEx.InvokeEx(System.Int32,System.UInt32,System.UInt16,Windows.Win32.System.Com.DISPPARAMS@,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,Windows.Win32.System.Com.IServiceProvider*)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.InvokeEx(System.Int32,System.UInt32,System.UInt16,Windows.Win32.System.Com.DISPPARAMS*,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,Windows.Win32.System.Com.IServiceProvider*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDispatchEx.GetMemberProperties(System.Int32,System.UInt32,Windows.Win32.System.Ole.FDEX_PROP_FLAGS@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.GetMemberProperties(System.Int32,System.UInt32,Windows.Win32.System.Ole.FDEX_PROP_FLAGS*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDispatchEx.GetNextDispID(System.UInt32,System.Int32,System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.GetNextDispID(System.UInt32,System.Int32,System.Int32*)"/>
        </member>
        <member name="F:Windows.Win32.System.Ole.IDispatchEx.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{a6ef9860-c720-11d0-9337-00a0c90dcaa9}</value>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropSource.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDropSource.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropSource.QueryContinueDrag(Windows.Win32.Foundation.BOOL,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS)">
            <summary>Determines whether a drag-and-drop operation should be continued, canceled, or completed. You do not call this method directly. The OLE DoDragDrop function calls this method during a drag-and-drop operation.</summary>
            <param name="fEscapePressed">Indicates whether the Esc key has been pressed since the previous call to <b>QueryContinueDrag</b> or to <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> if this is the first call to <b>QueryContinueDrag</b>. A <b>TRUE</b> value indicates the end user has pressed the escape key; a <b>FALSE</b> value indicates it has not been pressed.</param>
            <param name="grfKeyState">The current state of the keyboard modifier keys on the keyboard. Possible values can be a combination of any of the flags MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.</param>
            <returns>
            <para>This method can return the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>The <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> function calls <b>QueryContinueDrag</b> whenever it detects a change in the keyboard or mouse button state during a drag-and-drop operation. <b>QueryContinueDrag</b> must determine whether the drag-and-drop operation should be continued, canceled, or completed based on the contents of the parameters <i>grfKeyState</i> and <i>fEscapePressed</i>.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropSource.GiveFeedback(Windows.Win32.System.Ole.DROPEFFECT)">
            <summary>Enables a source application to give visual feedback to the end user during a drag-and-drop operation by providing the DoDragDrop function with an enumeration value specifying the visual effect.</summary>
            <param name="dwEffect">The <a href="https://docs.microsoft.com/windows/desktop/com/dropeffect-constants">DROPEFFECT</a> value returned by the most recent call to <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragenter">IDropTarget::DragEnter</a>, <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragover">IDropTarget::DragOver</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragleave">IDropTarget::DragLeave</a>.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>When your application detects that the user has started a drag-and-drop operation, it should call the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> function. <b>DoDragDrop</b> enters a loop, calling <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragenter">IDropTarget::DragEnter</a> when the mouse first enters a drop target window, <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragover">IDropTarget::DragOver</a> when the mouse changes its position within the target window, and <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragleave">IDropTarget::DragLeave</a> when the mouse leaves the target window. For every call to either <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragenter">IDropTarget::DragEnter</a> or <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragover">IDropTarget::DragOver</a>, <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> calls <b>IDropSource::GiveFeedback</b>, passing it the DROPEFFECT value returned from the drop target call.</para>
            <para><a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> calls <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragleave">IDropTarget::DragLeave</a> when the mouse has left the target window. Then, <b>DoDragDrop</b> calls <b>IDropSource::GiveFeedback</b> and passes the DROPEFFECT_NONE value in the <i>dwEffect</i> parameter. The <i>dwEffect</i> parameter can include DROPEFFECT_SCROLL, indicating that the source should put up the drag-scrolling variation of the appropriate pointer. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> This function is called frequently during the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> loop, so you can gain performance advantages if you optimize your implementation as much as possible. <b>IDropSource::GiveFeedback</b> is responsible for changing the cursor shape or for changing the highlighted source based on the value of the <i>dwEffect</i> parameter. If you are using default cursors, you can return DRAGDROP_S_USEDEFAULTCURSORS, which causes OLE to update the cursor for you, using its defaults.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Ole.IDropSource.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000121-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropSourceNotify.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDropSourceNotify.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropSourceNotify.DragEnterTarget(Windows.Win32.Foundation.HWND)">
            <summary>OLE calls this method when the user drags the mouse cursor into a potential drop target window.</summary>
            <param name="hwndTarget">The window handle of the potential drop target window.</param>
            <returns>This method returns S_OK on success.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleidl/nf-oleidl-idropsourcenotify-dragentertarget">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropSourceNotify.DragLeaveTarget">
            <summary>OLE calls this method when the user drags the mouse cursor out of a potential drop target window.</summary>
            <returns>This method returns S_OK on success.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleidl/nf-oleidl-idropsourcenotify-dragleavetarget">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Ole.IDropSourceNotify.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0000012b-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropTarget.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDropTarget.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropTarget.DragEnter(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDropTarget.DragEnter(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropTarget.DragEnter(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT*)">
            <summary>Indicates whether a drop can be accepted, and, if so, the effect of the drop.</summary>
            <param name="pDataObj">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface on the data object. This data object contains the data being transferred in the drag-and-drop operation. If the drop occurs, this data object will be incorporated into the target.</param>
            <param name="grfKeyState">The current state of the keyboard modifier keys on the keyboard. Possible values can be a combination of any of the flags MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.</param>
            <param name="pt">A <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-pointl">POINTL</a> structure containing the current cursor coordinates in screen coordinates.</param>
            <param name="pdwEffect">On input, pointer to the value of the <i>pdwEffect</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> function. On return, must contain one of the <a href="https://docs.microsoft.com/windows/desktop/com/dropeffect-constants">DROPEFFECT</a> flags, which indicates what the result of the drop operation would be.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>You do not call <b>DragEnter</b> directly; instead the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> function calls it to determine the effect of a drop the first time the user drags the mouse into the registered window of a drop target. To implement <b>DragEnter</b>, you must determine whether the target can use the data in the source data object by checking three things: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropTarget.DragOver(Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDropTarget.DragOver(Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropTarget.DragOver(Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT*)">
            <summary>Provides target feedback to the user and communicates the drop's effect to the DoDragDrop function so it can communicate the effect of the drop back to the source.</summary>
            <param name="grfKeyState">The current state of the keyboard modifier keys on the keyboard. Valid values can be a combination of any of the flags MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.</param>
            <param name="pt">A <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-pointl">POINTL</a> structure containing the current cursor coordinates in screen coordinates.</param>
            <param name="pdwEffect">On input, pointer to the value of the <i>pdwEffect</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> function. On return, must contain one of the <a href="https://docs.microsoft.com/windows/desktop/com/dropeffect-constants">DROPEFFECT</a> flags, which indicates what the result of the drop operation would be.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>You do not call <b>DragOver</b> directly. The <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> function calls this method each time the user moves the mouse across a given target window. <b>DoDragDrop</b> exits the loop if the drag-and-drop operation is canceled, if the user drags the mouse out of the target window, or if the drop is completed. In implementing <b>IDropTarget::DragOver</b>, you must provide features similar to those in <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragenter">IDropTarget::DragEnter</a>. You must determine the effect of dropping the data on the target by examining the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> defining the data object's formats and medium, along with the state of the modifier keys. The mouse position may also play a role in determining the effect of a drop. The following modifier keys affect the result of the drop. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropTarget.DragLeave">
            <summary>Removes target feedback and releases the data object.</summary>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>You do not call this method directly. The <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> function calls this method in either of the following cases: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragleave#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropTarget.Drop(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDropTarget.Drop(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IDropTarget.Drop(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT*)">
            <summary>Incorporates the source data into the target window, removes target feedback, and releases the data object.</summary>
            <param name="pDataObj">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface on the data object being transferred in the drag-and-drop operation.</param>
            <param name="grfKeyState">The current state of the keyboard modifier keys on the keyboard. Possible values can be a combination of any of the flags MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.</param>
            <param name="pt">A <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-pointl">POINTL</a> structure containing the current cursor coordinates in screen coordinates.</param>
            <param name="pdwEffect">On input, pointer to the value of the <i>pdwEffect</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> function. On return, must contain one of the <a href="https://docs.microsoft.com/windows/desktop/com/dropeffect-constants">DROPEFFECT</a> flags, which indicates what the result of the drop operation would be.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>You do not call this method directly. The <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> function calls this method when the user completes the drag-and-drop operation. In implementing <b>Drop</b>, you must incorporate the data object into the target. Use the formats available in <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>, available through <i>pDataObj</i>, along with the current state of the modifier keys to determine how the data is to be incorporated, such as linking or embedding. In addition to incorporating the data, you must also clean up as you do in the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragleave">IDropTarget::DragLeave</a> method: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Ole.IDropTarget.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{00000122-0000-0000-c000-000000000046}</value>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_Handle(Windows.Win32.System.Ole.OLE_HANDLE@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.get_Handle(Windows.Win32.System.Ole.OLE_HANDLE*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_Handle(Windows.Win32.System.Ole.OLE_HANDLE*)">
            <summary>Retrieves the handle to the picture managed within this picture object to a specified location.</summary>
            <param name="pHandle">A pointer to a variable that receives the handle. The caller is responsible for this handle upon successful return. The variable is set to <b>NULL</b> on failure.</param>
            <returns>
            <para>This method supports the standard return values E_FAIL and E_OUTOFMEMORY, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><h3><a id="Notes_to_Callers_"></a><a id="notes_to_callers_"></a><a id="NOTES_TO_CALLERS_"></a>Notes to Callers </h3> The picture object may retain ownership of the picture. However, the caller can be assured that the picture will remain valid until either the caller specifically destroys the picture or the picture object is itself destroyed. The <i>fOwn</i> parameter to <a href="https://docs.microsoft.com/windows/desktop/api/olectl/nf-olectl-olecreatepictureindirect">OleCreatePictureIndirect</a> determines ownership when the picture object is created. <a href="https://docs.microsoft.com/windows/desktop/api/olectl/nf-olectl-oleloadpicture">OleLoadPicture</a> forces <i>fOwn</i> to <b>TRUE</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-get_handle#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_hPal(Windows.Win32.System.Ole.OLE_HANDLE@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.get_hPal(Windows.Win32.System.Ole.OLE_HANDLE*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_hPal(Windows.Win32.System.Ole.OLE_HANDLE*)">
            <summary>Retrieves a copy of the palette currently used by the picture object.</summary>
            <param name="phPal">A pointer to a variable that receives the palette handle. The variable is set to <b>NULL</b> on failure.</param>
            <returns>
            <para>This method supports the standard return values E_FAIL and E_OUTOFMEMORY, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> If the picture object has ownership of the picture, it also has ownership of the palette and will destroy it when the object is itself destroyed. Otherwise the caller owns the palette. The <i>fOwn</i> parameter to <a href="https://docs.microsoft.com/windows/desktop/api/olectl/nf-olectl-olecreatepictureindirect">OleCreatePictureIndirect</a> determines ownership. <a href="https://docs.microsoft.com/windows/desktop/api/olectl/nf-olectl-oleloadpicture">OleLoadPicture</a> sets <i>fOwn</i> to <b>TRUE</b> to indicate that the picture object owns the palette.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-get_hpal#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_Type(Windows.Win32.System.Ole.PICTYPE@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.get_Type(Windows.Win32.System.Ole.PICTYPE*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_Type(Windows.Win32.System.Ole.PICTYPE*)">
            <summary>Retrieves the current type of the picture contained in the picture object.</summary>
            <param name="pType">Pointer to a variable that receives the picture type. The Type property can have any one of the values contained in the <a href="https://docs.microsoft.com/windows/desktop/com/pictype-constants">PICTYPE</a> enumeration.</param>
            <returns>
            <para>This method supports the standard return value E_FAIL, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-get_type">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_Width(System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.get_Width(System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_Width(System.Int32*)">
            <summary>Retrieves the current width of the picture in the picture object.</summary>
            <param name="pWidth">A pointer to a variable that receives the width.</param>
            <returns>
            <para>This method supports the standard return value E_FAIL, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-get_width">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_Height(System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.get_Height(System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_Height(System.Int32*)">
            <summary>Retrieves the current height of the picture in the picture object.</summary>
            <param name="pHeight">A pointer to a variable that receives the height.</param>
            <returns>
            <para>This method supports the standard return value E_FAIL, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-get_height">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.Render(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.RECT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Render(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.RECT*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.Render(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.RECT*)">
            <summary>Renders (draws) a specified portion of the picture defined by the offset (xSrc,ySrc) of the source picture and the dimensions to copy (cxSrc,xySrc).</summary>
            <param name="hDC">A handle of the device context on which to render the image.</param>
            <param name="x">The horizontal coordinate in <i>hdc</i> at which to place the rendered image.</param>
            <param name="y">The vertical coordinate in <i>hdc</i> at which to place the rendered image.</param>
            <param name="cx">The horizontal dimension (width) of the destination rectangle.</param>
            <param name="cy">The vertical dimension (height) of the destination rectangle</param>
            <param name="xSrc">The horizontal offset in the source picture from which to start copying.</param>
            <param name="ySrc">The vertical offset in the source picture from which to start copying.</param>
            <param name="cxSrc">The horizontal extent to copy from the source picture.</param>
            <param name="cySrc">The vertical extent to copy from the source picture.</param>
            <param name="pRcWBounds">A pointer to a rectangle containing the position of the destination within a metafile device context if <i>hdc</i> is a metafile DC. Cannot be <b>NULL</b> in such cases.</param>
            <returns>
            <para>This method supports the standard return values E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY, as well as the following: </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-render">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.set_hPal(Windows.Win32.System.Ole.OLE_HANDLE)">
            <summary>Assigns a GDI palette to the picture contained in the picture object.</summary>
            <param name="hPal">A handle to the GDI palette assigned to the picture.</param>
            <returns>This method supports the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</returns>
            <remarks>
            <para><h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Ownership of the palette passed to this method depends on how the picture object was created, as specified by the <i>fOwn</i> parameter to <a href="https://docs.microsoft.com/windows/desktop/api/olectl/nf-olectl-olecreatepictureindirect">OleCreatePictureIndirect</a>. <a href="https://docs.microsoft.com/windows/desktop/api/olectl/nf-olectl-oleloadpicture">OleLoadPicture</a> forces <i>fOwn</i> to <b>TRUE</b>; if the object owns the picture, then it takes over ownership of this palette.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-set_hpal#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_CurDC(Windows.Win32.Graphics.Gdi.HDC@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.get_CurDC(Windows.Win32.Graphics.Gdi.HDC*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_CurDC(Windows.Win32.Graphics.Gdi.HDC*)">
            <summary>Retrieves the handle of the current device context. This property is valid only for bitmap pictures.</summary>
            <param name="phDC">A pointer a variable that receives the device context.</param>
            <returns>
            <para>This method supports the standard return value E_FAIL, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The CurDC property and the <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nf-ocidl-ipicture-selectpicture">IPicture::SelectPicture</a> method exist to circumvent restrictions in Windows; specifically, that an object can only be selected into exactly one device context at a time. In some cases, a picture object may be permanently selected into a particular device context (for example, a control may use a certain picture for a background). To use this picture property elsewhere, it must be temporarily deselected from its old device context, selected into the new device context for the operation, then reselected back into the old device context. The <b>IPicture::get_CurDC</b> method returns the device context handle into which the picture is currently selected. The <b>IPicture::SelectPicture</b> method selects the picture into a new device context, returning the old device context and the picture's GDI handle. The caller should select the picture back into the old device context when the caller is done with it, as is normal for Windows code. <h3><a id="Notes_to_Callers_"></a><a id="notes_to_callers_"></a><a id="NOTES_TO_CALLERS_"></a>Notes to Callers </h3> The caller always owns any device contexts passed between it and the picture object. Because the picture object maintains a copy of the HDC, the caller should use a memory device context (created with the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createcompatibledc">CreateCompatibleDC</a> function) and not a screen device context (from <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdc">GetDC</a>, <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createdca">CreateDC</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-beginpaint">BeginPaint</a>), because the screen device contexts are a limited system resource.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-get_curdc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.SelectPicture(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HDC@,Windows.Win32.System.Ole.OLE_HANDLE@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.SelectPicture(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HDC*,Windows.Win32.System.Ole.OLE_HANDLE*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.SelectPicture(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HDC*,Windows.Win32.System.Ole.OLE_HANDLE*)">
            <summary>Selects a bitmap picture into a given device context, and returns the device context in which the picture was previously selected as well as the picture's GDI handle. This method works in conjunction with IPicture::get_CurDC.</summary>
            <param name="hDCIn">A handle for the device context in which to select the picture.</param>
            <param name="phDCOut">A pointer to a variable that receives the previous device context. This parameter can be <b>NULL</b> if the caller does not need this information. Ownership of the device context is always the responsibility of the caller.</param>
            <param name="phBmpOut">A pointer to a variable that receives the GDI handle of the picture. This parameter can be <b>NULL</b> if the caller does not need the handle. Ownership of this handle is determined by the <i>fOwn</i> parameter passed to <a href="https://docs.microsoft.com/windows/desktop/api/olectl/nf-olectl-olecreatepictureindirect">OleCreatePictureIndirect</a>. Pictures loaded from a stream always own their resources.</param>
            <returns>This method supports the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-selectpicture">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_KeepOriginalFormat(Windows.Win32.Foundation.BOOL@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.get_KeepOriginalFormat(Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_KeepOriginalFormat(Windows.Win32.Foundation.BOOL*)">
            <summary>Retrieves the current value of the picture's KeepOriginalFormat property.</summary>
            <param name="pKeep">A pointer to a variable that receives the value of the property.</param>
            <returns>
            <para>This method supports the standard return value E_FAIL, as well as the following value. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-get_keeporiginalformat">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.put_KeepOriginalFormat(Windows.Win32.Foundation.BOOL)">
            <summary>Sets the value of the picture's KeepOriginalFormat property.</summary>
            <param name="keep">Specifies the new value to assign to the property.</param>
            <returns>This method returns S_OK on success and E_FAIL otherwise.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-put_keeporiginalformat">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.PictureChanged">
            <summary>Notifies the picture object that its picture resource has changed. This method only calls IPropertyNotifySink::OnChanged with DISPID_PICT_HANDLE for any connected sinks.</summary>
            <returns>This method S_OK if it succeeds and E_FAIL if the picture object is uninitialized.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-picturechanged">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.SaveAsFile(Windows.Win32.System.Com.IStream*,Windows.Win32.Foundation.BOOL,System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.SaveAsFile(Windows.Win32.System.Com.IStream*,Windows.Win32.Foundation.BOOL,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.SaveAsFile(Windows.Win32.System.Com.IStream*,Windows.Win32.Foundation.BOOL,System.Int32*)">
            <summary>Saves the picture's data into a stream in the same format that it would save itself into a file. Bitmaps use the BMP file format, metafiles the WMF format, and icons the ICO format.</summary>
            <param name="pStream">A pointer to the stream into which the picture writes its data.</param>
            <param name="fSaveMemCopy">A flag indicating whether to save a copy of the picture in memory.</param>
            <param name="pCbSize">Pointer to a variable that receives the number of bytes written into the stream. This value can be <b>NULL</b>, indicating that the caller does not require this information.</param>
            <returns>This method supports the standard return values E_FAIL, E_INVALIDARG, and S_OK.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-saveasfile">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_Attributes(System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.get_Attributes(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPicture.get_Attributes(System.UInt32*)">
            <summary>Retrieves the current set of the picture's bit attributes.</summary>
            <param name="pDwAttr">
            <para>A pointer to a variable that receives the value of the Attributes property. The Attributes property can contain any combination of the values from the <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/ne-ocidl-pictureattributes">PICTUREATTRIBUTES</a> enumeration.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-get_attributes#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_FAIL, as well as the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ipicture-get_attributes">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Ole.IPicture.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{7bf80980-bf32-101a-8bbb-00aa00300cab}</value>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPictureDisp.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPictureDisp.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPictureDisp.GetTypeInfoCount(System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPictureDisp.GetTypeInfoCount(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPictureDisp.GetIDsOfNames(System.Guid@,System.ReadOnlySpan{Windows.Win32.Foundation.PWSTR},System.UInt32,System.Span{System.Int32})">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPictureDisp.GetIDsOfNames(System.Guid*,Windows.Win32.Foundation.PWSTR*,System.UInt32,System.UInt32,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IPictureDisp.Invoke(System.Int32,System.Guid@,System.UInt32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS@,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPictureDisp.Invoke(System.Int32,System.Guid*,System.UInt32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS*,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,System.UInt32*)"/>
        </member>
        <member name="F:Windows.Win32.System.Ole.IPictureDisp.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{7bf80981-bf32-101a-8bbb-00aa00300cab}</value>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.RecordInit(System.Void*)">
            <summary>Initializes a new instance of a record.</summary>
            <param name="pvNew">An instance of a record.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The caller must allocate the memory of the record by its appropriate size using the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-irecordinfo-getsize">GetSize</a> method. <b>RecordInit</b> sets all contents of the record to 0 and the record should hold no resources.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-recordinit#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.RecordClear(System.Void*)">
            <summary>Releases object references and other values of a record without deallocating the record.</summary>
            <param name="pvExisting">The record to be cleared.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks><b>RecordClear</b> releases memory blocks held by VT_PTR or VT_SAFEARRAY instance fields. The caller needs to free the instance fields memory, <b>RecordClear</b> will do nothing if there are no resources held.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.RecordCopy(System.Void*,System.Void*)">
            <summary>Copies an existing record into the passed in buffer.</summary>
            <param name="pvExisting">The current record instance.</param>
            <param name="pvNew">The destination where the record will be copied.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks><b>RecordCopy</b> will release the resources in the destination first. The caller is responsible for allocating sufficient memory in the destination by calling <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-irecordinfo-getsize">GetSize</a> or  <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-irecordinfo-recordcreate">RecordCreate</a>. If <b>RecordCopy</b> fails to copy any of the fields then all fields will be cleared, as though <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-irecordinfo-recordclear">RecordClear</a> had been called.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetGuid(System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.GetGuid(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetGuid(System.Guid*)">
            <summary>Gets the GUID of the record type.</summary>
            <param name="pguid">The class GUID of the TypeInfo that describes the UDT.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-getguid">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetName(Windows.Win32.Foundation.BSTR*)">
            <summary>Gets the name of the record type.</summary>
            <param name="pbstrName">The name.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>The caller must free the BSTR by calling <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-sysfreestring">SysFreeString</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetSize(System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.GetSize(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetSize(System.UInt32*)">
            <summary>Gets the number of bytes of memory necessary to hold the record instance.</summary>
            <param name="pcbSize">The size of a record instance, in bytes.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-getsize">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetTypeInfo(Windows.Win32.System.Com.ITypeInfo**)">
            <summary>Retrieves the type information that describes a UDT or safearray of UDTs.</summary>
            <param name="ppTypeInfo">The information type of the record.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks><b>AddRef</b> is called on the pointer <i>ppTypeInfo</i>.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetField(System.Void*,System.String,Windows.Win32.System.Variant.VARIANT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.GetField(System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetField(System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*)">
            <summary>Returns a pointer to the VARIANT containing the value of a given field name.</summary>
            <param name="pvData">The instance of a record.</param>
            <param name="szFieldName">The field name.</param>
            <param name="pvarField">The VARIANT that you want to hold the value of the field name, <i>szFieldName</i>. On return, places a copy of the field's value in the variant.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The VARIANT that you pass in contains a copy of the field's value upon return. If you modify the VARIANT then the underlying record field does not change. The caller allocates memory of the VARIANT. The method <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-variantclear">VariantClear</a> is called for <i>pvarField</i> before copying.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-getfield#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetFieldNoCopy(System.Void*,System.String,Windows.Win32.System.Variant.VARIANT@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.GetFieldNoCopy(System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetFieldNoCopy(System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*,System.Void**)">
            <summary>Returns a pointer to the value of a given field name without copying the value and allocating resources.</summary>
            <param name="pvData">The instance of a record.</param>
            <param name="szFieldName">The name of the field.</param>
            <param name="pvarField">The VARIANT that will contain the UDT upon return.</param>
            <param name="ppvDataCArray">Receives the value of the field upon return.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>Upon return, the VARIANT you pass contains a direct pointer to the record's field, <i>ppvDataCArray</i>. If you modify the VARIANT, then the underlying record field will change. The caller allocates memory of the VARIANT, but does not own the memory so cannot free <i>pvarField</i>. This method calls <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-variantclear">VariantClear</a> for <i>pvarField</i> before filling in the requested field.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-getfieldnocopy#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.PutField(System.UInt32,System.Void*,System.String,Windows.Win32.System.Variant.VARIANT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.PutField(System.UInt32,System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.PutField(System.UInt32,System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*)">
            <summary>Puts a variant into a field.</summary>
            <param name="wFlags">
            <para>The only legal values for the wFlags parameter is INVOKE_PROPERTYPUT or INVOKE_PROPERTYPUTREF. If INVOKE_PROPERTYPUTREF is passed in then <b>PutField</b> just assigns the value of the variant that is passed in to the field using normal coercion rules. If INVOKE_PROPERTYPUT is passed in then specific rules apply. If the field is declared as a class that derives from <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch</a> and the field's value is NULL then an error will be returned. If the field's value is not NULL then the variant will be passed to the default property supported by the object referenced by the field. If the field is not declared as a class derived from <b>IDispatch</b> then an error will be returned. If the field is declared as a variant of type VT_Dispatch then the default value of the object is assigned to the field. Otherwise, the variant's value is assigned to the field.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-putfield#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pvData">The pointer to an instance of the record.</param>
            <param name="szFieldName">The name of the field of the record.</param>
            <param name="pvarField">The pointer to the variant.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-putfield">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.PutFieldNoCopy(System.UInt32,System.Void*,System.String,Windows.Win32.System.Variant.VARIANT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.PutFieldNoCopy(System.UInt32,System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.PutFieldNoCopy(System.UInt32,System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*)">
            <summary>Passes ownership of the data to the assigned field by placing the actual data into the field.</summary>
            <param name="wFlags">The only legal values for the wFlags parameter is INVOKE_PROPERTYPUT or INVOKE_PROPERTYPUTREF.</param>
            <param name="pvData">An instance of the record described by <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-irecordinfo">IRecordInfo</a>.</param>
            <param name="szFieldName">The name of the field of the record.</param>
            <param name="pvarField">The variant to be put into the field.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-putfieldnocopy">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetFieldNames(System.UInt32@,Windows.Win32.Foundation.BSTR*)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.GetFieldNames(System.UInt32*,Windows.Win32.Foundation.BSTR*)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.GetFieldNames(System.UInt32*,Windows.Win32.Foundation.BSTR*)">
            <summary>Gets the names of the fields of the record.</summary>
            <param name="pcNames">The number of names to return.</param>
            <param name="rgBstrNames">
            <para>The name of the array of type BSTR. If the <i>rgBstrNames</i> parameter is NULL, then <i>pcNames</i> is returned with the number of field names. It the <i>rgBstrNames</i> parameter is not NULL, then the string names contained in <i>rgBstrNames</i> are returned. If the number of names in <i>pcNames</i> and <i>rgBstrNames</i> are not equal then the lesser number of the two is the number of returned field names. The caller needs to free the BSTRs inside the array returned in <i>rgBstrNames</i>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-getfieldnames#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The caller should allocate memory for the array of BSTRs. If the array is larger than needed, set the unused portion to 0. On return, the caller will need to free each contained BSTR using <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oleauto/nf-oleauto-sysfreestring">SysFreeString</a>. In case of out of memory, <i>pcNames</i> points to error code.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-getfieldnames#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.IsMatchingType(Windows.Win32.System.Ole.IRecordInfo*)">
            <summary>Determines whether the record that is passed in matches that of the current record information.</summary>
            <param name="pRecordInfo">The information of the record.</param>
            <returns>
            <para></para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-ismatchingtype">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.RecordCreate">
            <summary>Allocates memory for a new record, initializes the instance and returns a pointer to the record.</summary>
            <returns>This method returns a pointer to the created record.</returns>
            <remarks>
            <para>The memory is set to zeros before it is returned. The records created must be freed by calling <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-irecordinfo-recorddestroy">RecordDestroy</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-recordcreate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.RecordCreateCopy(System.Void*,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.RecordCreateCopy(System.Void*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.RecordCreateCopy(System.Void*,System.Void**)">
            <summary>Creates a copy of an instance of a record to the specified location.</summary>
            <param name="pvSource">An instance of the record to be copied.</param>
            <param name="ppvDest">The new record with data copied from <i>pvSource</i>.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>The records created must be freed by calling <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-irecordinfo-recorddestroy">RecordDestroy</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.System.Ole.IRecordInfo.RecordDestroy(System.Void*)">
            <summary>Releases the resources and deallocates the memory of the record.</summary>
            <param name="pvRecord">An instance of the record to be destroyed.</param>
            <returns>
            <para>This method can return one of these values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-irecordinfo-recordclear">RecordClear</a> is called to release the resources held by the instance of a record without deallocating memory. <div class="alert"><b>Note</b>  This method can only be called on records allocated through <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-irecordinfo-recordcreate">RecordCreate</a> and <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nf-oaidl-irecordinfo-recordcreatecopy">RecordCreateCopy</a>. If you allocate the record yourself, you cannot call this method.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/nf-oaidl-irecordinfo-recorddestroy#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Ole.IRecordInfo.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{0000002f-0000-0000-c000-000000000046}</value>
        </member>
        <member name="T:Windows.Win32.System.Ole.PARAMDESC">
            <summary>Contains information needed for transferring a structure element, parameter, or function return value between processes.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-paramdesc">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Ole.PARAMDESC.pparamdescex">
            <summary>The default value for the parameter, if PARAMFLAG_FHASDEFAULT is specified in <b>wParamFlags</b>.</summary>
        </member>
        <member name="F:Windows.Win32.System.Ole.PARAMDESC.wParamFlags">
            <summary>The parameter flags. See <a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/paramflags">PARAMFLAG Constants</a>.</summary>
        </member>
        <member name="T:Windows.Win32.System.Ole.PARAMDESCEX">
            <summary>Contains information about the default value of a parameter.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-paramdescex">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Ole.PARAMDESCEX.cBytes">
            <summary>The size of the structure.</summary>
        </member>
        <member name="F:Windows.Win32.System.Ole.PARAMDESCEX.varDefaultValue">
            <summary>The default value of the parameter.</summary>
        </member>
        <member name="T:Windows.Win32.System.Ole.PICTDESC">
            <summary>Contains parameters to create a picture object through the OleCreatePictureIndirect function.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/olectl/ns-olectl-pictdesc">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Ole.PICTDESC.cbSizeofstruct">
            <summary>The size of the structure, in bytes.</summary>
        </member>
        <member name="T:Windows.Win32.System.Ole.PICTYPE">
            <summary>Describe the type of a picture object as returned by IPicture get\_Type, as well as to describe the type of picture in the picType member of the PICTDESC structure that is passed to OleCreatePictureIndirect.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/com/pictype-constants">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.System.Variant.VARIANT">
            <summary>VARIANTARG describes arguments passed within DISPPARAMS, and VARIANT to specify variant data that cannot be passed by reference.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/oaidl/ns-oaidl-variant">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.System.Variant.VARIANT.FromObject(System.Object)">
            <summary>
             Converts the given object to <see cref="T:Windows.Win32.System.Variant.VARIANT"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.System.Variant.VARENUM">
            <summary>Specifies the variant types.</summary>
            <remarks>
            <para>The following table shows where these values can be used. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypes/ne-wtypes-varenum#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_EMPTY">
            <summary>Not specified.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_NULL">
            <summary>Null.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_I2">
            <summary>A 2-byte integer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_I4">
            <summary>A 4-byte integer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_R4">
            <summary>A 4-byte real.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_R8">
            <summary>An 8-byte real.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_CY">
            <summary>Currency.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_DATE">
            <summary>A date.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_BSTR">
            <summary>A string.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_DISPATCH">
            <summary>An <a href="https://docs.microsoft.com/previous-versions/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch</a> pointer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_ERROR">
            <summary>An SCODE value.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_BOOL">
            <summary>A Boolean value. True is -1 and false is 0.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_VARIANT">
            <summary>A variant pointer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_UNKNOWN">
            <summary>An <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> pointer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_DECIMAL">
            <summary>A 16-byte fixed-pointer value.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_I1">
            <summary>A character.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_UI1">
            <summary>An unsigned character.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_UI2">
            <summary>An unsigned short.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_UI4">
            <summary>An unsigned long.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_I8">
            <summary>A 64-bit integer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_UI8">
            <summary>A 64-bit unsigned integer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_INT">
            <summary>An integer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_UINT">
            <summary>An unsigned integer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_VOID">
            <summary>A C-style void.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_HRESULT">
            <summary>An HRESULT value.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_PTR">
            <summary>A pointer type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_SAFEARRAY">
            <summary>A safe array. Use VT_ARRAY in VARIANT.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_CARRAY">
            <summary>A C-style array.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_USERDEFINED">
            <summary>A user-defined type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_LPSTR">
            <summary>A null-terminated string.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_LPWSTR">
            <summary>A wide null-terminated string.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_RECORD">
            <summary>A user-defined type.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_INT_PTR">
            <summary>A signed machine register size width.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_UINT_PTR">
            <summary>An unsigned machine register size width.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_FILETIME">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> value.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_BLOB">
            <summary>Length-prefixed bytes.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_STREAM">
            <summary>The name of the stream follows.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_STORAGE">
            <summary>The name of the storage follows.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_STREAMED_OBJECT">
            <summary>The stream contains an object.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_STORED_OBJECT">
            <summary>The storage contains an object.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_BLOB_OBJECT">
            <summary>The blob contains an object.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_CF">
            <summary>A clipboard format.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_CLSID">
            <summary>A class ID.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_VERSIONED_STREAM">
            <summary>A stream with a GUID version.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_BSTR_BLOB">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_VECTOR">
            <summary>A simple counted array.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_ARRAY">
            <summary>A SAFEARRAY pointer.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_BYREF">
            <summary>A void pointer for local use.</summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_RESERVED">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_ILLEGAL">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_ILLEGALMASKED">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.System.Variant.VARENUM.VT_TYPEMASK">
            <summary></summary>
        </member>
        <member name="T:Windows.Win32.System.Rpc.RPC_STATUS">
            <summary>The data type RPC\_STATUS represents a platform-specific status code type.</summary>
            <remarks>The **RPC\_STATUS** type is returned by most RPC functions and is part of the [**RPC\_OBJECT\_INQ\_FN**](/windows/desktop/api/Rpcdce/nc-rpcdce-rpc_object_inq_fn) function type definition.</remarks>
        </member>
        <member name="P:Windows.Win32.ComHelpers.BuiltInComSupported">
            <summary>
             Returns <see langword="true"/> if built-in COM interop is supported. When using AOT or trimming this will
             return <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.ComHelpers.GetComScope``1(System.Object)">
            <summary>
             Gets a pointer for the specified <typeparamref name="T"/> for the given <paramref name="object"/>. Throws if
             the desired pointer can not be obtained.
            </summary>
        </member>
        <member name="M:Windows.Win32.ComHelpers.TryGetComScope``1(System.Object)">
            <summary>
             Attempts to get a pointer for the specified <typeparamref name="T"/> for the given <paramref name="object"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.ComHelpers.TryGetComScope``1(System.Object,Windows.Win32.Foundation.HRESULT@)">
            <summary>
             Attempts to get a pointer for the specified <typeparamref name="T"/> for the given <paramref name="object"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.ComHelpers.GetComPointer``1(System.Object)">
            <summary>
             Gets the specified <typeparamref name="T"/> interface for the given <paramref name="object"/>. Throws if
             the desired pointer can not be obtained.
            </summary>
        </member>
        <member name="M:Windows.Win32.ComHelpers.TryGetComPointer``1(System.Object)">
            <summary>
             Attempts to get the specified <typeparamref name="T"/> interface for the given <paramref name="object"/>.
            </summary>
            <returns>The requested pointer or <see langword="null"/> if unsuccessful.</returns>
        </member>
        <member name="M:Windows.Win32.ComHelpers.SupportsInterface``1(System.Object)">
            <summary>
             Queries for the given interface and releases it.
             Note that this method should only be used for the purposes of checking if the object supports a given interface.
             If that interface is needed, it is best try to get the ComScope directly to avoid querying twice.
            </summary>
        </member>
        <member name="M:Windows.Win32.ComHelpers.TryGetComPointer``1(System.Object,Windows.Win32.Foundation.HRESULT@)">
            <summary>
             Attempts to get the specified <typeparamref name="T"/> interface for the given <paramref name="object"/>.
            </summary>
            <param name="result">
             Typically either <see cref="F:Windows.Win32.Foundation.HRESULT.S_OK"/> or <see cref="F:Windows.Win32.Foundation.HRESULT.E_POINTER"/>. Check for success, not
             specific results.
            </param>
            <returns>The requested pointer or <see langword="null"/> if unsuccessful.</returns>
        </member>
        <member name="M:Windows.Win32.ComHelpers.TryUnwrapComWrapperCCW``1(Windows.Win32.System.Com.IUnknown*,``0@)">
            <summary>
             Attempts to unwrap a ComWrapper CCW as a particular managed object.
            </summary>
        </member>
        <member name="M:Windows.Win32.ComHelpers.TryGetObjectForIUnknown``2(Windows.Win32.Foundation.ComScope{``1},``0@)">
            <inheritdoc cref="M:Windows.Win32.ComHelpers.TryGetObjectForIUnknown``1(Windows.Win32.System.Com.IUnknown*,System.Boolean,``0@)"/>
        </member>
        <member name="M:Windows.Win32.ComHelpers.TryGetObjectForIUnknown``2(``1*,``0@)">
            <inheritdoc cref="M:Windows.Win32.ComHelpers.TryGetObjectForIUnknown``1(Windows.Win32.System.Com.IUnknown*,System.Boolean,``0@)"/>
        </member>
        <member name="M:Windows.Win32.ComHelpers.TryGetObjectForIUnknown``1(Windows.Win32.System.Com.IUnknown*,``0@)">
            <inheritdoc cref="M:Windows.Win32.ComHelpers.TryGetObjectForIUnknown``1(Windows.Win32.System.Com.IUnknown*,System.Boolean,``0@)"/>
        </member>
        <member name="M:Windows.Win32.ComHelpers.TryGetObjectForIUnknown``1(Windows.Win32.System.Com.IUnknown*,System.Boolean,``0@)">
            <summary>
             Attempts to get a managed wrapper of the specified type for the given COM interface.
            </summary>
            <param name="takeOwnership">
             When <see langword="true"/>, releases the original <paramref name="unknown"/> whether successful or not.
            </param>
        </member>
        <member name="M:Windows.Win32.ComHelpers.WrapsManagedObject``1(System.Object,``0*)">
            <summary>
             Returns <see langword="true"/> if the given <paramref name="object"/>
             is projected as the given <paramref name="comPointer"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.ComHelpers.GetObjectForIUnknown``1(``0*)">
            <inheritdoc cref="M:Windows.Win32.ComHelpers.GetObjectForIUnknown(Windows.Win32.System.Com.IUnknown*)"/>
        </member>
        <member name="M:Windows.Win32.ComHelpers.GetObjectForIUnknown``1(Windows.Win32.Foundation.ComScope{``0})">
            <inheritdoc cref="M:Windows.Win32.ComHelpers.GetObjectForIUnknown(Windows.Win32.System.Com.IUnknown*)"/>
        </member>
        <member name="M:Windows.Win32.ComHelpers.GetObjectForIUnknown(Windows.Win32.System.Com.IUnknown*)">
            <summary>
             <see cref="T:System.Runtime.InteropServices.ComWrappers"/> capable wrapper for <see cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="unknown"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Windows.Win32.ComHelpers.GetRegisteredTypeInfo(System.Guid,System.UInt16,System.UInt16,System.Guid)">
            <summary>
             Find the given interface's <see cref="T:Windows.Win32.System.Com.ITypeInfo"/> from the specified type library.
            </summary>
        </member>
        <member name="M:Windows.Win32.ComHelpers.PopulateIUnknownImpl``1(Windows.Win32.System.Com.IUnknown.Vtbl*)">
            <summary>
             <see cref="T:Windows.Win32.System.Com.IUnknown"/> vtable population hook for CsWin32's generated <see cref="T:Windows.Win32.IVTable"/> implementation.
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.Controls.Dialogs.DEVNAMES">
             <summary>
              Contains strings that identify the driver, device, and output port names for a printer.
             </summary>
             <remarks>
              <para>
               <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-devnames">
                Learn more about this API from https://learn.microsoft.com.
               </see>
              </para>
             </remarks>
             <devdoc>
              Manually copied from a 64 bit project CsWin32 generated wrapper. We can't directly use CsWin32 for this as it
              technically isn't compatible with AnyCPU. For our usages this works fine on both 32 bit and 64 bit.
            
              This is defined with single byte packing on 32 bit, but there are no gaps as everything naturally packs with no
              gaps on 32 bit. Issues would arise if this was contained in another native struct where it wouldn't start 32 bit
              aligned due to the single byte packing.
            
              https://github.com/microsoft/CsWin32/issues/882
             </devdoc>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.DEVNAMES.wDriverOffset">
            <summary>
             <para>
              Type: <b>WORD</b> The offset, in characters, from the beginning of this structure to a null-terminated string
              that contains the file name (without the extension) of the device driver. On input, this string is used to
              determine the printer to display initially in the dialog box.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-devnames#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.DEVNAMES.wDeviceOffset">
            <summary>
             <para>
              Type: <b>WORD</b> The offset, in characters, from the beginning of this structure to the null-terminated
              string that contains the name of the device.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-devnames#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.DEVNAMES.wOutputOffset">
            <summary>
             <para>
              Type: <b>WORD</b> The offset, in characters, from the beginning of this structure to the null-terminated
              string that contains the device name for the physical output medium (output port).
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-devnames#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.DEVNAMES.wDefault">
            <summary>
             <para>
              Type: <b>WORD</b> Indicates whether the strings contained in the <b>DEVNAMES</b> structure identify the
              default printer. This string is used to verify that the default printer has not changed since the last
              print operation. If any of the strings do not match, a warning message is displayed informing the user
              that the document may need to be reformatted. On output, the <b>wDefault</b> member is changed only if
              the <b>Print Setup</b> dialog box was displayed and the user chose the <b>OK</b> button.
              The <b>DN_DEFAULTPRN</b> flag is used if the default printer was selected. If a specific printer is selected,
              the flag is not used. All other flags in this member are reserved for internal use by the dialog box
              procedure for the <b>Print</b> property sheet or <b>Print</b> dialog box.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-devnames#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW">
             <summary>
              Contains information that the PrintDlgEx function uses to initialize the Print property sheet. After the user
              closes the property sheet, the system uses this structure to return information about the user's selections.
             </summary>
             <remarks>
              <para>
               <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#">
                Read more on https://learn.microsoft.com.
               </see>
              </para>
             </remarks>
             <devdoc>
              Manually copied from a 64 bit project CsWin32 generated wrapper. We can't directly use CsWin32 for this as it
              technically isn't compatible with AnyCPU. For our usages this works fine on both 32 bit and 64 bit.
            
              This is defined with single byte packing on 32 bit, but there are no gaps as everything naturally packs with no
              gaps on 32 bit. Issues would arise if this was contained in another native struct where it wouldn't start 32 bit
              aligned due to the single byte packing.
            
              https://github.com/microsoft/CsWin32/issues/882
             </devdoc>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.lStructSize">
            <summary>
             <para>Type: <b>DWORD</b> The structure size, in bytes.</para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.hwndOwner">
            <summary>
             <para>
              Type: <b>HWND</b> A handle to the window that owns the property sheet. This member must be a valid
              window handle; it cannot be <b>NULL</b>.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.hDevMode">
            <summary>
             <para>
              Type: <b>HGLOBAL</b> A handle to a movable global memory object that contains a
              <a href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodew">DEVMODE</a> structure.
              If <b>hDevMode</b> is not <b>NULL</b> on input, you must allocate a movable block of memory for the
              <b>DEVMODE</b> structure and initialize its members. The
              <a href="https://learn.microsoft.com/previous-versions/windows/desktop/legacy/ms646942(v=vs.85)">
              PrintDlgEx</a> function uses the input data to initialize the controls in the property sheet.
              When <b>PrintDlgEx</b> returns, the <b>DEVMODE</b> members indicate the user's input.
              If <b>hDevMode</b> is <b>NULL</b> on input,
              <a href="https://learn.microsoft.com/previous-versions/windows/desktop/legacy/ms646942(v=vs.85)">
              PrintDlgEx</a> allocates memory for the
              <a href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">
              DEVMODE</a> structure, initializes its members to indicate the user's input, and returns a handle that
              identifies it. For more information about the <b>hDevMode</b> and <b>hDevNames</b> members,
              see the Remarks section at the end of this topic.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.hDevNames">
            <summary>
             <para>
              Type: <b>HGLOBAL</b> A handle to a movable global memory object that contains a
              <a href="https://learn.microsoft.com/windows/desktop/api/commdlg/ns-commdlg-devnames">DEVNAMES</a> structure.
              If <b>hDevNames</b> is not <b>NULL</b> on input, you must allocate a movable block of memory
              for the <b>DEVNAMES</b> structure and initialize its members. The
              <a href="https://learn.microsoft.com/previous-versions/windows/desktop/legacy/ms646942(v=vs.85)">PrintDlgEx</a>
              function uses the input data to initialize the controls in the property sheet. When <b>PrintDlgEx</b> returns,
              the <b>DEVNAMES</b> members contain information for the printer chosen by the user. You can use this
              information to create a device context or an information context. The <b>hDevNames</b> member can be
              <b>NULL</b>, in which case,
              <a href="https://learn.microsoft.com/previous-versions/windows/desktop/legacy/ms646942(v=vs.85)">
              PrintDlgEx</a> allocates memory for the
              <a href="https://learn.microsoft.com/windows/desktop/api/commdlg/ns-commdlg-devnames">DEVNAMES</a>
              structure, initializes its members to indicate the user's input, and returns a handle that identifies it.
              For more information about the <b>hDevMode</b> and <b>hDevNames</b> members, see the Remarks section at the
              end of this topic.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.hDC">
            <summary>
             <para>
              Type: <b>HDC</b> A handle to a device context or an information context, depending on whether the <b>Flags</b>
              member specifies the <b>PD_RETURNDC</b> or <b>PC_RETURNIC</b> flag. If neither flag is specified, the value
              of this member is undefined. If both flags are specified, <b>PD_RETURNDC</b> has priority.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.Flags">
            <summary>Type: <b>DWORD</b></summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.Flags2">
            <summary>Type: <b>DWORD</b></summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.ExclusionFlags">
            <summary>
             <para>
              Type: <b>DWORD</b> A set of bit flags that can exclude items from the printer driver property pages in the
              <b>Print</b> property sheet. This value is used only if the <b>PD_EXCLUSIONFLAGS</b> flag is set in the
              <b>Flags</b> member. Exclusion flags should be used only if the item to be excluded will be included on
              either the <b>General</b> page or on an application-defined page in the <b>Print</b> property sheet.
              This member can specify the following flag.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.nPageRanges">
            <summary>
             <para>
              Type: <b>DWORD</b> On input, set this member to the initial number of page ranges specified in the
              <b>lpPageRanges</b> array. When the
              <a href="https://learn.microsoft.com/previous-versions/windows/desktop/legacy/ms646942(v=vs.85)">
              PrintDlgEx</a> function returns, <b>nPageRanges</b> indicates the number of user-specified page ranges stored
              in the <b>lpPageRanges</b> array. If the <b>PD_NOPAGENUMS</b> flag is specified, this value is not valid.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.nMaxPageRanges">
            <summary>
             <para>
              Type: <b>DWORD</b> The size, in array elements, of the <b>lpPageRanges</b> buffer. This value indicates
              the maximum number of page ranges that can be stored in the array. If the <b>PD_NOPAGENUMS</b> flag
              is specified, this value is not valid. If the <b>PD_NOPAGENUMS</b> flag is not specified, this
              value must be greater than zero.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.lpPageRanges">
            <summary>
             <para>
              Type: <b>LPPRINTPAGERANGE</b> Pointer to a buffer containing an array of
              <a href="https://learn.microsoft.com/windows/desktop/api/commdlg/ns-commdlg-printpagerange">PRINTPAGERANGE</a>
              structures. On input, the array contains the initial page ranges to display in the <b>Pages</b> edit control.
              When the <a href="https://learn.microsoft.com/previous-versions/windows/desktop/legacy/ms646942(v=vs.85)">
              PrintDlgEx</a> function returns, the array contains the page ranges specified by the user. If the
              <b>PD_NOPAGENUMS</b> flag is specified, this value is not valid. If the <b>PD_NOPAGENUMS</b> flag is not
              specified, <b>lpPageRanges</b> must be non-<b>NULL</b>.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.nMinPage">
            <summary>
             <para>
              Type: <b>DWORD</b> The minimum value for the page ranges specified in the <b>Pages</b> edit control.
              If the <b>PD_NOPAGENUMS</b> flag is specified, this value is not valid.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.nMaxPage">
            <summary>
             <para>
              Type: <b>DWORD</b> The maximum value for the page ranges specified in the <b>Pages</b> edit control.
              If the <b>PD_NOPAGENUMS</b> flag is specified, this value is not valid.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.nCopies">
            <summary>
             <para>
              Type: <b>DWORD</b> Contains the initial number of copies for the <b>Copies</b> edit control if <b>hDevMode</b>
              is <b>NULL</b>; otherwise, the <b>dmCopies</b> member of the
              <a href="https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-devmodea">DEVMODE</a> structure
              contains the initial value.
              When <a href="https://learn.microsoft.com/previous-versions/windows/desktop/legacy/ms646942(v=vs.85)">
              PrintDlgEx</a> returns, <b>nCopies</b> contains the actual number of copies the application must print.
              This value depends on whether the application or the printer driver is responsible for
              printing multiple copies. If the <b>PD_USEDEVMODECOPIESANDCOLLATE</b> flag is set in the <b>Flags</b>
              member, <b>nCopies</b> is always 1 on return, and the printer driver is responsible for printing
              multiple copies. If the flag is not set, the application is responsible for printing the number of copies
              specified by <b>nCopies</b>. For more information, see the description of the
              <b>PD_USEDEVMODECOPIESANDCOLLATE</b> flag.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.hInstance">
            <summary>
             <para>
              Type: <b>HINSTANCE</b> If the <b>PD_ENABLEPRINTTEMPLATE</b> flag is set in the <b>Flags</b> member,
              <b>hInstance</b> is a handle to the application or module instance that contains the dialog box
              template named by the <b>lpPrintTemplateName</b> member. If the <b>PD_ENABLEPRINTTEMPLATEHANDLE</b> flag
              is set in the <b>Flags</b> member, <b>hInstance</b> is a handle to a memory object containing a
              dialog box template. If neither of the template flags is set in the <b>Flags</b> member,
              <b>hInstance</b> should be <b>NULL</b>.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.lpPrintTemplateName">
            <summary>
             <para>
              Type: <b>LPCTSTR</b> The name of the dialog box template resource in the module identified by the
              <b>hInstance</b> member. This template replaces the default dialog box template in the lower portion
              of the <b>General</b> page. The default template contains controls similar to those of the
              <b>Print</b> dialog box. This member is ignored unless the PD_ENABLEPRINTTEMPLATE flag is set in the
              <b>Flags</b> member.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.lpCallback">
            <summary>
             <para>
              Type: <b>LPUNKNOWN</b> A pointer to an application-defined callback object. The object should contain the
              <a href="https://learn.microsoft.com/windows/desktop/api/commdlg/nn-commdlg-iprintdialogcallback">
              IPrintDialogCallback</a> class to receive messages for the child dialog box in the lower portion of the
              <b>General</b> page. The callback object should also contain the
              <a href="https://learn.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-iobjectwithsite">
              IObjectWithSite</a> class to receive a pointer to the
              <a href="https://learn.microsoft.com/windows/desktop/api/commdlg/nn-commdlg-iprintdialogservices">
              IPrintDialogServices</a> interface.
              The <a href="https://learn.microsoft.com/previous-versions/windows/desktop/legacy/ms646942(v=vs.85)">
              PrintDlgEx</a> function calls
              <a href="https://learn.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)">
              IUnknown::QueryInterface</a> on the callback object for both <b>IID_IPrintDialogCallback</b> and
              <b>IID_IObjectWithSite</b> to determine which interfaces are supported. If you do not want to retrieve any
              of the callback information, set <b>lpCallback</b> to <b>NULL</b>.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.nPropertyPages">
            <summary>
             <para>Type: <b>DWORD</b> The number of property page handles in the <b>lphPropertyPages</b> array.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.lphPropertyPages">
            <summary>
             <para>
              Type: <b>HPROPSHEETPAGE*</b> Contains an array of property page handles to add to the <b>Print</b>
              property sheet. The additional property pages follow the <b>General</b> page. Use the
              <a href="https://learn.microsoft.com/windows/desktop/api/prsht/nf-prsht-createpropertysheetpagea">
              CreatePropertySheetPage</a> function to create these additional pages. When the
              <a href="https://learn.microsoft.com/previous-versions/windows/desktop/legacy/ms646942(v=vs.85)">
              PrintDlgEx</a> function returns, all the <b>HPROPSHEETPAGE</b> handles in the <b>lphPropertyPages</b>
              array have been destroyed. If <b>nPropertyPages</b> is zero, <b>lphPropertyPages</b> should be <b>NULL</b>.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.nStartPage">
            <summary>
             <para>
              Type: <b>DWORD</b> The property page that is initially displayed. To display the <b>General</b> page, specify
              <b>START_PAGE_GENERAL</b>. Otherwise, specify the zero-based index of a property page in the array specified
              in the <b>lphPropertyPages</b> member. For consistency, it is recommended that the property sheet always be
              started on the <b>General</b> page.
             </para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printdlgexw#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW.dwResultAction">
            <summary>Type: <b>DWORD</b></summary>
        </member>
        <member name="T:Windows.Win32.UI.Controls.Dialogs.PRINTPAGERANGE">
             <summary>
              Represents a range of pages in a print job. A print job can have more than one page range. This information is
              supplied in the <see cref="T:Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW"/> structure when calling the <see cref="M:Windows.Win32.PInvokeCore.PrintDlgEx(Windows.Win32.UI.Controls.Dialogs.PRINTDLGEXW*)"/> function.
             </summary>
             <remarks>
              <para>
               <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printpagerange">
                Learn more about this API from https://learn.microsoft.com.
               </see>
              </para>
             </remarks>
             <devdoc>
              Manually copied from a 64 bit project CsWin32 generated wrapper. We can't directly use CsWin32 for this as it
              technically isn't compatible with AnyCPU. For our usages this works fine on both 32 bit and 64 bit.
            
              This is defined with single byte packing on 32 bit, but there are no gaps as everything naturally packs with no
              gaps on 32 bit. Issues would arise if this was contained in another native struct where it wouldn't start 32 bit
              aligned due to the single byte packing.
            
              https://github.com/microsoft/CsWin32/issues/882
             </devdoc>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTPAGERANGE.nFromPage">
            <summary>
             <para>Type: <b>DWORD</b> The first page of the range.</para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printpagerange#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.Dialogs.PRINTPAGERANGE.nToPage">
            <summary>
             <para>Type: <b>DWORD</b> The last page of the range.</para>
             <para>
              <see href="https://learn.microsoft.com/windows/win32/api/commdlg/ns-commdlg-printpagerange#members">
               Read more on https://learn.microsoft.com.
              </see>
             </para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.WindowsAndMessaging.ICONINFO">
            <summary>Contains information about an icon or a cursor.</summary>
            <remarks>
            <para>For monochrome icons, the <b>hbmMask</b> is twice the height of the icon (with the AND mask on top and the XOR mask on the bottom), and <b>hbmColor</b> is <b>NULL</b>. Also, in this case the height should be an even multiple of two. For color icons, the <b>hbmMask</b> and <b>hbmColor</b> bitmaps are the same size, each of which is the size of the icon. You can use a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getobject">GetObject</a> function to get contents of <b>hbmMask</b> and <b>hbmColor</b> in the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-bitmap">BITMAP</a> structure. The bitmap bits can be obtained with call to <a href="https://docs.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getdibits">GetDIBits</a> on the bitmaps in this structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-iconinfo#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.ICONINFO.fIcon">
            <summary>
            <para>Type: <b>BOOL</b> Specifies whether this structure defines an icon or a cursor. A value of <b>TRUE</b> specifies an icon; <b>FALSE</b> specifies a cursor.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-iconinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.ICONINFO.xHotspot">
            <summary>
            <para>Type: <b>DWORD</b> The x-coordinate of a cursor's hot spot. If this structure defines an icon, the hot spot is always in the center of the icon, and this member is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-iconinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.ICONINFO.yHotspot">
            <summary>
            <para>Type: <b>DWORD</b> The y-coordinate of the cursor's hot spot. If this structure defines an icon, the hot spot is always in the center of the icon, and this member is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-iconinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.ICONINFO.hbmMask">
            <summary>
            <para>Type: <b>HBITMAP</b> A handle to the icon monochrome mask <a href="https://docs.microsoft.com/windows/win32/gdi/bitmaps">bitmap</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-iconinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.ICONINFO.hbmColor">
            <summary>
            <para>Type: <b>HBITMAP</b> A handle to the icon color <a href="https://docs.microsoft.com/windows/win32/gdi/bitmaps">bitmap</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-iconinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.WindowsAndMessaging.MSG">
            <summary>Contains message information from a thread's message queue.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.hwnd">
            <summary>
            <para>Type: <b>HWND</b> A handle to the window whose window procedure receives the message. This member is <b>NULL</b> when the message is a thread message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.message">
            <summary>
            <para>Type: <b>UINT</b> The message identifier. Applications can only use the low word; the high word is reserved by the system.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.wParam">
            <summary>
            <para>Type: <b>WPARAM</b> Additional information about the message. The exact meaning depends on the value of the <b>message</b> member.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.lParam">
            <summary>
            <para>Type: <b>LPARAM</b> Additional information about the message. The exact meaning depends on the value of the <b>message</b> member.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.time">
            <summary>
            <para>Type: <b>DWORD</b> The time at which the message was posted.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.pt">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b> The cursor position, in screen coordinates, when the message was posted.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW">
            <summary>Contains the scalable metrics associated with the nonclient area of a nonminimized window. (Unicode)</summary>
            <remarks>
            <para>If the <b>iPaddedBorderWidth</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-nonclientmetricsa">NONCLIENTMETRICS</a> structure is present, this structure is 4 bytes larger than for an application that is compiled with <b>_WIN32_WINNT</b> less than or equal to 0x0502. For more information about conditional compilation, see <a href="https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>. <b>Windows Server 2003 and Windows XP/2000:  </b>If an application  that is compiled for Windows Server 2008 or Windows Vista must also run on Windows Server 2003 or Windows XP/2000, use the <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa">GetVersionEx</a> function to check the operating system version at run time and, if the application is running on Windows Server 2003 or Windows XP/2000, subtract the size of the <b>iPaddedBorderWidth</b> member from the <b>cbSize</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-nonclientmetricsa">NONCLIENTMETRICS</a> structure before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a> function.</para>
            <para>> [!NOTE] > The winuser.h header defines NONCLIENTMETRICS as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-nonclientmetricsw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.cbSize">
            <summary>The size of the structure, in bytes. The caller must set this to <c>sizeof(NONCLIENTMETRICS)</c>. For   information about application compatibility, see Remarks.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.iBorderWidth">
            <summary>The thickness of the sizing border, in pixels. The default is 1 pixel.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.iScrollWidth">
            <summary>The width of a standard vertical scroll bar, in pixels.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.iScrollHeight">
            <summary>The height of a standard horizontal scroll bar, in pixels.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.iCaptionWidth">
            <summary>The width of caption buttons, in pixels.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.iCaptionHeight">
            <summary>The height of caption buttons, in pixels.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.lfCaptionFont">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure that contains information about the caption font.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.iSmCaptionWidth">
            <summary>The width of small caption buttons, in pixels.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.iSmCaptionHeight">
            <summary>The height of small captions, in pixels.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.lfSmCaptionFont">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure that contains information about the small caption font.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.iMenuWidth">
            <summary>The width of menu-bar buttons, in pixels.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.iMenuHeight">
            <summary>The height of a menu bar, in pixels.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.lfMenuFont">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure that contains information about the font used in menu bars.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.lfStatusFont">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure that contains information about the font used in status bars and tooltips.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.lfMessageFont">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure that contains information about the font used in message boxes.</summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.NONCLIENTMETRICSW.iPaddedBorderWidth">
            <summary>
            <para>The thickness of the padded border, in pixels. The default value is 4 pixels. The <b>iPaddedBorderWidth</b> and <b>iBorderWidth</b> members are combined for both resizable and nonresizable windows in  the Windows Aero desktop experience. To compile an application that uses this member, define <b>_WIN32_WINNT</b> as 0x0600 or later. For more information, see Remarks. <b>Windows Server 2003 and Windows XP/2000:  </b>This member is not supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-nonclientmetricsw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.Shell.DROPDESCRIPTION">
            <summary>Describes the image and accompanying text for a drop object.</summary>
            <remarks>Some UI coloring is applied to the text in <b>szInsert</b> if used by specifying %1 in <b>szMessage</b>. The characters %% and %1 are the subset of <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> markers that are processed here.</remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPDESCRIPTION.type">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-dropimagetype">DROPIMAGETYPE</a></b> A <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-dropimagetype">DROPIMAGETYPE</a> indicating the stock image to use.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shlobj_core/ns-shlobj_core-dropdescription#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPDESCRIPTION.szMessage">
            <summary>
            <para>Type: <b>WCHAR[MAX_PATH]</b> Text such as "Move to %1".</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shlobj_core/ns-shlobj_core-dropdescription#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPDESCRIPTION.szInsert">
            <summary>
            <para>Type: <b>WCHAR[MAX_PATH]</b> Text such as "Documents", inserted as specified by <b>szMessage</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shlobj_core/ns-shlobj_core-dropdescription#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.Shell.DROPFILES">
            <summary>Defines the CF_HDROP clipboard format. The data that follows is a double null-terminated list of file names.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shlobj_core/ns-shlobj_core-dropfiles">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPFILES.pFiles">
            <summary>
            <para>Type: <b>DWORD</b> The offset of the file list from the beginning of this structure, in bytes.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shlobj_core/ns-shlobj_core-dropfiles#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPFILES.pt">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b> The drop point. The coordinates depend on <b>fNC</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shlobj_core/ns-shlobj_core-dropfiles#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPFILES.fNC">
            <summary>
            <para>Type: <b>BOOL</b> A nonclient area flag. If this member is <b>TRUE</b>, <b>pt</b> specifies the screen coordinates of a point in a window's nonclient area. If it is <b>FALSE</b>, <b>pt</b> specifies the client coordinates of a point in the client area.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shlobj_core/ns-shlobj_core-dropfiles#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPFILES.fWide">
            <summary>
            <para>Type: <b>BOOL</b> A value that indicates whether the file contains ANSI or Unicode characters. If the value is zero, the file contains ANSI characters. Otherwise, it contains Unicode characters.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shlobj_core/ns-shlobj_core-dropfiles#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.Shell.DROPIMAGETYPE">
            <summary>Values used with the DROPDESCRIPTION structure to specify the drop image.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shlobj_core/ne-shlobj_core-dropimagetype">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPIMAGETYPE.DROPIMAGE_INVALID">
            <summary>No drop image preference; use the default image.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPIMAGETYPE.DROPIMAGE_NONE">
            <summary>A red bisected circle such as that found on a "no smoking" sign.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPIMAGETYPE.DROPIMAGE_COPY">
            <summary>A plus sign (+) that indicates a copy operation.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPIMAGETYPE.DROPIMAGE_MOVE">
            <summary>An arrow that indicates a move operation.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPIMAGETYPE.DROPIMAGE_LINK">
            <summary>An arrow that indicates a link.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPIMAGETYPE.DROPIMAGE_LABEL">
            <summary>A tag icon that indicates that the metadata will be changed.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPIMAGETYPE.DROPIMAGE_WARNING">
            <summary>A yellow exclamation mark that indicates that a problem has been encountered in the operation.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.DROPIMAGETYPE.DROPIMAGE_NOIMAGE">
            <summary><b>Windows 7 and later</b>. Use no drop image.</summary>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.SetAsyncMode(Windows.Win32.Foundation.BOOL)">
            <summary>Called by a drop source to specify whether the data object supports asynchronous data extraction.</summary>
            <param name="fDoOpAsync">
            <para>Type: <b>BOOL</b> <b>VARIANT_TRUE</b> if an asynchronous operation is supported; otherwise, <b>VARIANT_FALSE</b>. The default value is <b>VARIANT_FALSE</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para>This method is called by the drop source to indicate that the data object supports asynchronous data extraction. Store the <i>fDoOpAsync</i> for later use by <a href="https://docs.microsoft.com/windows/desktop/api/shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode">IDataObjectAsyncCapability::GetAsyncMode</a>. The drop target determines whether asynchronous data extraction is supported by calling <b>IDataObjectAsyncCapability::GetAsyncMode</b> to retrieve the <i>fDoOpAsync</i> value. If <i>fDoOpAsync</i> is set to <b>VARIANT_TRUE</b>, <b>SetAsyncMode</b> must call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">IDataObjectAsyncCapability::AddRef</a>, and store the interface pointer for use by <a href="https://docs.microsoft.com/windows/desktop/api/shldisp/nf-shldisp-idataobjectasynccapability-endoperation">IDataObjectAsyncCapability::EndOperation</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.GetAsyncMode(Windows.Win32.Foundation.BOOL@)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.GetAsyncMode(Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.GetAsyncMode(Windows.Win32.Foundation.BOOL*)">
            <summary>Called by a drop target to determine whether the data object supports asynchronous data extraction.</summary>
            <param name="pfIsOpAsync">
            <para>Type: <b>BOOL*</b> <b>VARIANT_TRUE</b> if an asynchronous operation is supported; otherwise, <b>VARIANT_FALSE</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>The purpose of this method is to give the drop target the value of the <a href="https://docs.microsoft.com/windows/desktop/api/shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode">IDataObjectAsyncCapability::SetAsyncMode</a> method's <i>fDoOpAsync</i> parameter. This parameter is set to <b>VARIANT_FALSE</b> by default. If the data object supports asynchronous data extraction, it must call <b>IDataObjectAsyncCapability::SetAsyncMode</b> and set <i>fDoOpAsync</i> to <b>VARIANT_TRUE</b>.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.StartOperation(Windows.Win32.System.Com.IBindCtx*)">
            <summary>Called by a drop target to indicate that asynchronous data extraction is starting.</summary>
            <param name="pbcReserved">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b> Reserved. Set this value to <b>nullptr</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shldisp/nf-shldisp-idataobjectasynccapability-startoperation#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>The drop target calls this method to notify the data object that asynchronous data extraction is starting. The method should store this information so that it can be returned by <a href="https://docs.microsoft.com/windows/desktop/api/shldisp/nf-shldisp-idataobjectasynccapability-inoperation">IDataObjectAsyncCapability::InOperation</a>. Once <b>StartOperation</b> has been called, the drop target returns the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-drop">IDropTarget::Drop</a> call as it would for normal synchronous data extraction.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.InOperation(Windows.Win32.Foundation.BOOL@)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.InOperation(Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.InOperation(Windows.Win32.Foundation.BOOL*)">
            <summary>Called by the drop source to determine whether the target is extracting data asynchronously.</summary>
            <param name="pfInAsyncOp">
            <para>Type: <b>BOOL*</b> <b>VARIANT_TRUE</b> if data extraction is being handled asynchronously; otherwise, <b>VARIANT_FALSE</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shldisp/nf-shldisp-idataobjectasynccapability-inoperation#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>This method is called by the drop source after <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-dodragdrop">DoDragDrop</a> returns. The <i>pfInAsyncOp</i> parameter should be set to <b>VARIANT_TRUE</b> only if the drop target has called <a href="https://docs.microsoft.com/windows/desktop/api/shldisp/nf-shldisp-idataobjectasynccapability-startoperation">IDataObjectAsyncCapability::StartOperation</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.EndOperation(Windows.Win32.Foundation.HRESULT,Windows.Win32.System.Com.IBindCtx*,System.UInt32)">
            <summary>Notifies the data object that the asynchronous data extraction has ended.</summary>
            <param name="hResult">
            <para>Type: <b>HRESULT</b> Indicates the outcome of the data extraction. Set this value to S_OK if successful, or a COM error code otherwise.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shldisp/nf-shldisp-idataobjectasynccapability-endoperation#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pbcReserved">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b> Reserved. Set to <b>nullptr</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shldisp/nf-shldisp-idataobjectasynccapability-endoperation#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwEffects">
            <para>Type: <b>DWORD</b> A <a href="https://docs.microsoft.com/windows/desktop/com/dropeffect-constants">DROPEFFECT</a> value that indicates the result of an optimized move. This should be the same value that would be passed to the data object as a CFSTR_PERFORMEDDROPEFFECT format with a normal data extraction operation.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shldisp/nf-shldisp-idataobjectasynccapability-endoperation#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para><b>EndOperation</b> retrieves the <a href="https://docs.microsoft.com/windows/desktop/api/shldisp/nn-shldisp-idataobjectasynccapability">IDataObjectAsyncCapability</a> pointer stored by <a href="https://docs.microsoft.com/windows/desktop/api/shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode">IDataObjectAsyncCapability::SetAsyncMode</a> and passes its parameter values to that interface's <b>IDataObjectAsyncCapability::EndOperation</b> method. <b>EndOperation</b> then releases the <b>IDataObjectAsyncCapability</b> pointer. <b>EndOperation</b> is also responsible for any associated clean-up operations. When finished, <b>EndOperation</b> should notify the drop source through a private interface.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shldisp/nf-shldisp-idataobjectasynccapability-endoperation#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{3d8b0590-f691-11d2-8ea9-006097df5bd4}</value>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDragSourceHelper.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDragSourceHelper.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDragSourceHelper.InitializeFromBitmap(Windows.Win32.UI.Shell.SHDRAGIMAGE@,Windows.Win32.System.Com.IDataObject*)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDragSourceHelper.InitializeFromBitmap(Windows.Win32.UI.Shell.SHDRAGIMAGE*,Windows.Win32.System.Com.IDataObject*)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDragSourceHelper.InitializeFromBitmap(Windows.Win32.UI.Shell.SHDRAGIMAGE*,Windows.Win32.System.Com.IDataObject*)">
            <summary>Initializes the drag-image manager for a windowless control.</summary>
            <param name="pshdi">
            <para>Type: <b>LPSHDRAGIMAGE</b> The <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ns-shobjidl_core-shdragimage">SHDRAGIMAGE</a> structure that contains information about the bitmap.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefrombitmap#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pDataObject">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b> A pointer to the data object's <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefrombitmap#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>Because <b>InitializeFromBitmap</b> always performs the RGB multiplication step in calculating the alpha value, you should always pass a bitmap without premultiplied alpha blending. Note that no error will result from passing the method a bitmap with premultiplied alpha blending, but this method will multiply it again, doubling the resulting alpha value.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDragSourceHelper.InitializeFromWindow(Windows.Win32.Foundation.HWND,System.Nullable{System.Drawing.Point},Windows.Win32.System.Com.IDataObject*)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDragSourceHelper.InitializeFromWindow(Windows.Win32.Foundation.HWND,System.Drawing.Point*,Windows.Win32.System.Com.IDataObject*)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDragSourceHelper.InitializeFromWindow(Windows.Win32.Foundation.HWND,System.Drawing.Point*,Windows.Win32.System.Com.IDataObject*)">
            <summary>Initializes the drag-image manager for a control with a window.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> A handle to the window that receives the <b>DI_GETDRAGIMAGE</b> message. This value can be <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefromwindow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="ppt">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a>*</b> A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that specifies the location of the cursor within the drag image. The structure should contain the offset from the upper-left corner of the drag image to the location of the cursor. This value can be <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefromwindow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pDataObject">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b> A pointer to the data object's <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefromwindow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>The <b>DI_GETDRAGIMAGE</b> message allows you to source a drag image from a custom control. It is defined in Shlobj.h and must be registered with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a>. When the window specified by <i>hwnd</i> receives the <b>DI_GETDRAGIMAGE</b> message, the <i>lParam</i> value holds a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ns-shobjidl_core-shdragimage">SHDRAGIMAGE</a> structure. The handler should fill the structure with the drag image bitmap information.</remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.IDragSourceHelper.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{de5bf786-477a-11d2-839d-00c04fd918d0}</value>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDragSourceHelper2.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDragSourceHelper2.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDragSourceHelper2.InitializeFromBitmap(Windows.Win32.UI.Shell.SHDRAGIMAGE@,Windows.Win32.System.Com.IDataObject*)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDragSourceHelper2.InitializeFromBitmap(Windows.Win32.UI.Shell.SHDRAGIMAGE*,Windows.Win32.System.Com.IDataObject*)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDragSourceHelper2.InitializeFromWindow(Windows.Win32.Foundation.HWND,System.Nullable{System.Drawing.Point},Windows.Win32.System.Com.IDataObject*)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDragSourceHelper2.InitializeFromWindow(Windows.Win32.Foundation.HWND,System.Drawing.Point*,Windows.Win32.System.Com.IDataObject*)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDragSourceHelper2.SetFlags(System.UInt32)">
            <summary>Sets the characteristics of a drag-and-drop operation over an IDragSourceHelper object.</summary>
            <param name="dwFlags">
            <para>Type: <b>DWORD</b> The flags that determine the characteristics of a drag-and-drop operation over an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper">IDragSourceHelper</a> object.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl/nf-shobjidl-idragsourcehelper2-setflags#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl/nf-shobjidl-idragsourcehelper2-setflags">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.IDragSourceHelper2.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{83e07d0d-0c5f-4163-bf1a-60b274051e40}</value>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDropTargetHelper.QueryInterface(System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDropTargetHelper.QueryInterface(System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDropTargetHelper.DragEnter(Windows.Win32.Foundation.HWND,Windows.Win32.System.Com.IDataObject*,System.Drawing.Point@,Windows.Win32.System.Ole.DROPEFFECT)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDropTargetHelper.DragEnter(Windows.Win32.Foundation.HWND,Windows.Win32.System.Com.IDataObject*,System.Drawing.Point*,Windows.Win32.System.Ole.DROPEFFECT)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDropTargetHelper.DragEnter(Windows.Win32.Foundation.HWND,Windows.Win32.System.Com.IDataObject*,System.Drawing.Point*,Windows.Win32.System.Ole.DROPEFFECT)">
            <summary>Notifies the drag-image manager that the drop target's IDropTarget::DragEnter method has been called.</summary>
            <param name="hwndTarget">
            <para>Type: <b>HWND</b> The target's window handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pDataObject">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b> A pointer to the data object's <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="ppt">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a>*</b> The <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure pointer that was received in the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragenter">IDropTarget::DragEnter</a> method's <i>pt</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwEffect">
            <para>Type: <b>DWORD</b> The value pointed to by the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragenter">IDropTarget::DragEnter</a> method's <i>pdwEffect</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.</para>
            </returns>
            <remarks>This method is called by a drop target when its <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragenter">IDropTarget::DragEnter</a> method is called. It notifies the drag-image manager that the drop target has been entered, and provides it with the information needed to display the drag image.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDropTargetHelper.DragLeave">
            <summary>Notifies the drag-image manager that the drop target's IDropTarget::DragLeave method has been called.</summary>
            <returns>
            <para>Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.</para>
            </returns>
            <remarks>This method is called by a drop target when its <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragleave">IDropTarget::DragLeave</a> method is called. It notifies the drag-image manager that the cursor has left the drop target.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDropTargetHelper.DragOver(System.Drawing.Point@,Windows.Win32.System.Ole.DROPEFFECT)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDropTargetHelper.DragOver(System.Drawing.Point*,Windows.Win32.System.Ole.DROPEFFECT)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDropTargetHelper.DragOver(System.Drawing.Point*,Windows.Win32.System.Ole.DROPEFFECT)">
            <summary>Notifies the drag-image manager that the drop target's IDropTarget::DragOver method has been called.</summary>
            <param name="ppt">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a>*</b> The <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure pointer that was received in the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragover">IDropTarget::DragOver</a> method's <i>pt</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwEffect">
            <para>Type: <b>DWORD</b> The value pointed to by the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragover">IDropTarget::DragOver</a> method's <i>pdwEffect</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.</para>
            </returns>
            <remarks>This method is called by a drop target when its <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-dragover">IDropTarget::DragOver</a> method is called. It notifies the drag-image manager that the cursor position has changed and provides it with the information needed to display the drag image.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDropTargetHelper.Drop(Windows.Win32.System.Com.IDataObject*,System.Drawing.Point@,Windows.Win32.System.Ole.DROPEFFECT)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDropTargetHelper.Drop(Windows.Win32.System.Com.IDataObject*,System.Drawing.Point*,Windows.Win32.System.Ole.DROPEFFECT)"/>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDropTargetHelper.Drop(Windows.Win32.System.Com.IDataObject*,System.Drawing.Point*,Windows.Win32.System.Ole.DROPEFFECT)">
            <summary>Notifies the drag-image manager that the drop target's IDropTarget::Drop method has been called.</summary>
            <param name="pDataObject">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b> A pointer to the data object's <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="ppt">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a>*</b> A <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure pointer that was received in the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-drop">IDropTarget::Drop</a> method's <i>pt</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwEffect">
            <para>Type: <b>DWORD</b> The value pointed to by the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-drop">IDropTarget::Drop</a> method's <i>pdwEffect</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.</para>
            </returns>
            <remarks>This method is called by a drop target when its <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-idroptarget-drop">IDropTarget::Drop</a> method is called. It notifies the drag-image manager that the object has been dropped, and provides it with the information needed to display the drag image.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.IDropTargetHelper.Show(Windows.Win32.Foundation.BOOL)">
            <summary>Notifies the drag-image manager to show or hide the drag image.</summary>
            <param name="fShow">
            <para>Type: <b>BOOL</b> A boolean value that is set to <b>TRUE</b> to show the drag image, and <b>FALSE</b> to hide it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-show#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.</para>
            </returns>
            <remarks>This method is used when dragging over a target window in a low color-depth video mode. It allows the target to notify the drag-image manager to hide the drag image while it is painting the window. While you are painting a window that is currently being dragged over, hide the drag image by calling <b>Show</b> with <i>fShow</i> set to <b>FALSE</b>. Once the window has been painted, display the drag image again by calling <b>Show</b> with <i>fShow</i> set to <b>TRUE</b>.</remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.IDropTargetHelper.IID_Guid">
            <summary>The IID guid for this interface.</summary>
            <value>{4657278b-411b-11d2-839a-00c04fd918d0}</value>
        </member>
        <member name="T:Windows.Win32.UI.Shell.SHDRAGIMAGE">
            <summary>Contains the information needed to create a drag image.</summary>
            <remarks>
            <para>In Windows Vista this structure is defined in Shobjidl.idl. Prior to that, it was defined in Shlobj.h. Use the following procedure to create the drag image. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-shdragimage#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.SHDRAGIMAGE.sizeDragImage">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-size">SIZE</a></b> A <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-size">SIZE</a> structure with the length and width of the drag image.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-shdragimage#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.SHDRAGIMAGE.ptOffset">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b> A <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that specifies the location of the cursor within the drag image. The structure should contain the offset from the upper-left corner of the drag image to the location of the cursor.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-shdragimage#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.SHDRAGIMAGE.hbmpDragImage">
            <summary>
            <para>Type: <b>HBITMAP</b> The drag image's bitmap handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-shdragimage#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.SHDRAGIMAGE.crColorKey">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b> The color used by the control to fill the background of the drag image.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-shdragimage#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.Accessibility.HIGHCONTRASTW">
            <summary>Contains information about the high contrast accessibility feature. (Unicode)</summary>
            <remarks>
            <para>An application uses this structure when calling the[SystemParametersInfoW function](nf-winuser-systemparametersinfow.md) with the <b>SPI_GETHIGHCONTRAST</b> or <b>SPI_SETHIGHCONTRAST</b> value. When using <b>SPI_GETHIGHCONTRAST</b>, an application must specify the <b>cbSize</b> member of the <b>HIGHCONTRAST</b> structure; the <b>SystemParametersInfo</b> function fills the remaining members. An application must specify all structure members when using the <b>SPI_SETHIGHCONTRAST</b> value.</para>
            <para>> [!NOTE] > The winuser.h header defines HIGHCONTRAST as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-highcontrastw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Accessibility.HIGHCONTRASTW.cbSize">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b> Specifies the size, in bytes, of this structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-highcontrastw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Accessibility.HIGHCONTRASTW.dwFlags">
            <summary>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">DWORD</a></b></summary>
        </member>
        <member name="F:Windows.Win32.UI.Accessibility.HIGHCONTRASTW.lpszDefaultScheme">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LPTSTR</a></b> Points to a string that contains the name of the color scheme that will be set to the default scheme. The system allocates this buffer, free it with LocalFree.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-highcontrastw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="P:Windows.Win32.__byte_32.Length">
            <summary>The length of the inline array.</summary>
        </member>
        <member name="P:Windows.Win32.__byte_32.Item(System.Int32)">
            <summary>
            Gets a ref to an individual element of the inline array.
            ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
            </summary>
        </member>
        <member name="M:Windows.Win32.__byte_32.AsSpan">
            <summary>
            Gets this inline array as a span.
            </summary>
            <remarks>
            ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
            </remarks>
        </member>
        <member name="M:Windows.Win32.__byte_32.AsReadOnlySpan">
            <summary>
            Gets this inline array as a span.
            </summary>
            <remarks>
            ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
            </remarks>
        </member>
        <member name="P:Windows.Win32.__char_32.Length">
            <summary>The length of the inline array.</summary>
        </member>
        <member name="P:Windows.Win32.__char_32.Item(System.Int32)">
            <summary>
            Gets a ref to an individual element of the inline array.
            ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
            </summary>
        </member>
        <member name="M:Windows.Win32.__char_32.AsSpan">
            <summary>
            Gets this inline array as a span.
            </summary>
            <remarks>
            ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
            </remarks>
        </member>
        <member name="M:Windows.Win32.__char_32.AsReadOnlySpan">
            <summary>
            Gets this inline array as a span.
            </summary>
            <remarks>
            ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
            </remarks>
        </member>
        <member name="M:Windows.Win32.__char_32.ToString(System.Int32)">
            <summary>
            Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="P:Windows.Win32.__char_32.Length"/>.
            </exception>
        </member>
        <member name="M:Windows.Win32.__char_32.ToString">
            <summary>
            Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
            </summary>
        </member>
        <member name="P:Windows.Win32.__char_260.Length">
            <summary>The length of the inline array.</summary>
        </member>
        <member name="P:Windows.Win32.__char_260.Item(System.Int32)">
            <summary>
            Gets a ref to an individual element of the inline array.
            ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
            </summary>
        </member>
        <member name="M:Windows.Win32.__char_260.AsSpan">
            <summary>
            Gets this inline array as a span.
            </summary>
            <remarks>
            ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
            </remarks>
        </member>
        <member name="M:Windows.Win32.__char_260.AsReadOnlySpan">
            <summary>
            Gets this inline array as a span.
            </summary>
            <remarks>
            ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
            </remarks>
        </member>
        <member name="M:Windows.Win32.__char_260.ToString(System.Int32)">
            <summary>
            Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="P:Windows.Win32.__char_260.Length"/>.
            </exception>
        </member>
        <member name="M:Windows.Win32.__char_260.ToString">
            <summary>
            Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
            </summary>
        </member>
        <member name="P:Windows.Win32.IComIID.Guid">
            <summary>The IID guid for this interface.</summary>
            <remarks>The <see cref="P:Windows.Win32.IComIID.Guid" /> reference that is returned comes from a permanent memory address, and is therefore safe to convert to a pointer and pass around or hold long-term.</remarks>
        </member>
        <member name="T:Windows.Win32.IVTable">
            <summary>
            Non generic interface that allows constraining against a COM wrapper type directly. COM structs should
            implement <see cref="T:Windows.Win32.IVTable`2"/>.
            </summary>
        </member>
        <member name="M:Windows.Win32.System_Com_IAdviseSink_Extensions.OnDataChange(Windows.Win32.System.Com.IAdviseSink.Interface,Windows.Win32.System.Com.FORMATETC@,Windows.Win32.System.Com.STGMEDIUM@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IAdviseSink.Interface.OnDataChange(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IBindCtx_Extensions.SetBindOptions(Windows.Win32.System.Com.IBindCtx.Interface,Windows.Win32.System.Com.BIND_OPTS@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IBindCtx.Interface.SetBindOptions(Windows.Win32.System.Com.BIND_OPTS*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IBindCtx_Extensions.GetBindOptions(Windows.Win32.System.Com.IBindCtx.Interface,Windows.Win32.System.Com.BIND_OPTS@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IBindCtx.Interface.GetBindOptions(Windows.Win32.System.Com.BIND_OPTS*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IDataObject_Extensions.GetData(Windows.Win32.System.Com.IDataObject.Interface,Windows.Win32.System.Com.FORMATETC@,Windows.Win32.System.Com.STGMEDIUM@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.Interface.GetData(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IDataObject_Extensions.GetDataHere(Windows.Win32.System.Com.IDataObject.Interface,Windows.Win32.System.Com.FORMATETC@,Windows.Win32.System.Com.STGMEDIUM@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.Interface.GetDataHere(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IDataObject_Extensions.QueryGetData(Windows.Win32.System.Com.IDataObject.Interface,Windows.Win32.System.Com.FORMATETC@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.Interface.QueryGetData(Windows.Win32.System.Com.FORMATETC*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IDataObject_Extensions.GetCanonicalFormatEtc(Windows.Win32.System.Com.IDataObject.Interface,Windows.Win32.System.Com.FORMATETC@,Windows.Win32.System.Com.FORMATETC@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.Interface.GetCanonicalFormatEtc(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.FORMATETC*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IDataObject_Extensions.SetData(Windows.Win32.System.Com.IDataObject.Interface,Windows.Win32.System.Com.FORMATETC@,Windows.Win32.System.Com.STGMEDIUM@,Windows.Win32.Foundation.BOOL)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.Interface.SetData(Windows.Win32.System.Com.FORMATETC*,Windows.Win32.System.Com.STGMEDIUM*,Windows.Win32.Foundation.BOOL)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IDataObject_Extensions.DAdvise(Windows.Win32.System.Com.IDataObject.Interface,Windows.Win32.System.Com.FORMATETC@,System.UInt32,Windows.Win32.System.Com.IAdviseSink*,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IDataObject.Interface.DAdvise(Windows.Win32.System.Com.FORMATETC*,System.UInt32,Windows.Win32.System.Com.IAdviseSink*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IEnumFORMATETC_Extensions.Next(Windows.Win32.System.Com.IEnumFORMATETC.Interface,System.Span{Windows.Win32.System.Com.FORMATETC},System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumFORMATETC.Interface.Next(System.UInt32,Windows.Win32.System.Com.FORMATETC*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IEnumSTATDATA_Extensions.Next(Windows.Win32.System.Com.IEnumSTATDATA.Interface,System.Span{Windows.Win32.System.Com.STATDATA},System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumSTATDATA.Interface.Next(System.UInt32,Windows.Win32.System.Com.STATDATA*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IEnumString_Extensions.Next(Windows.Win32.System.Com.IEnumString.Interface,System.Span{Windows.Win32.Foundation.PWSTR},System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IEnumString.Interface.Next(System.UInt32,Windows.Win32.Foundation.PWSTR*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IGlobalInterfaceTable_Extensions.RegisterInterfaceInGlobal(Windows.Win32.System.Com.IGlobalInterfaceTable.Interface,Windows.Win32.System.Com.IUnknown*,System.Guid@,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IGlobalInterfaceTable.Interface.RegisterInterfaceInGlobal(Windows.Win32.System.Com.IUnknown*,System.Guid*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IGlobalInterfaceTable_Extensions.GetInterfaceFromGlobal(Windows.Win32.System.Com.IGlobalInterfaceTable.Interface,System.UInt32,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IGlobalInterfaceTable.Interface.GetInterfaceFromGlobal(System.UInt32,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IMoniker_Extensions.GetClassID(Windows.Win32.System.Com.IMoniker.Interface,System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.Interface.GetClassID(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IMoniker_Extensions.GetSizeMax(Windows.Win32.System.Com.IMoniker.Interface,System.UInt64@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.Interface.GetSizeMax(System.UInt64*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IMoniker_Extensions.BindToObject(Windows.Win32.System.Com.IMoniker.Interface,Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.Interface.BindToObject(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IMoniker_Extensions.BindToStorage(Windows.Win32.System.Com.IMoniker.Interface,Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.Interface.BindToStorage(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IMoniker_Extensions.Hash(Windows.Win32.System.Com.IMoniker.Interface,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.Interface.Hash(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IMoniker_Extensions.GetTimeOfLastChange(Windows.Win32.System.Com.IMoniker.Interface,Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.Interface.GetTimeOfLastChange(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IMoniker_Extensions.GetDisplayName(Windows.Win32.System.Com.IMoniker.Interface,Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.PWSTR@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.Interface.GetDisplayName(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.PWSTR*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IMoniker_Extensions.ParseDisplayName(Windows.Win32.System.Com.IMoniker.Interface,Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.PWSTR,System.UInt32@,Windows.Win32.System.Com.IMoniker**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.Interface.ParseDisplayName(Windows.Win32.System.Com.IBindCtx*,Windows.Win32.System.Com.IMoniker*,Windows.Win32.Foundation.PWSTR,System.UInt32*,Windows.Win32.System.Com.IMoniker**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IMoniker_Extensions.IsSystemMoniker(Windows.Win32.System.Com.IMoniker.Interface,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IMoniker.Interface.IsSystemMoniker(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IPersistStream_Extensions.GetClassID(Windows.Win32.System.Com.IPersistStream.Interface,System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IPersistStream.Interface.GetClassID(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IPersistStream_Extensions.GetSizeMax(Windows.Win32.System.Com.IPersistStream.Interface,System.UInt64@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IPersistStream.Interface.GetSizeMax(System.UInt64*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IPersist_Extensions.GetClassID(Windows.Win32.System.Com.IPersist.Interface,System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IPersist.Interface.GetClassID(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IRunningObjectTable_Extensions.Register(Windows.Win32.System.Com.IRunningObjectTable.Interface,Windows.Win32.System.Com.ROT_FLAGS,Windows.Win32.System.Com.IUnknown*,Windows.Win32.System.Com.IMoniker*,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IRunningObjectTable.Interface.Register(Windows.Win32.System.Com.ROT_FLAGS,Windows.Win32.System.Com.IUnknown*,Windows.Win32.System.Com.IMoniker*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IRunningObjectTable_Extensions.NoteChangeTime(Windows.Win32.System.Com.IRunningObjectTable.Interface,System.UInt32,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IRunningObjectTable.Interface.NoteChangeTime(System.UInt32,System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IRunningObjectTable_Extensions.GetTimeOfLastChange(Windows.Win32.System.Com.IRunningObjectTable.Interface,Windows.Win32.System.Com.IMoniker*,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IRunningObjectTable.Interface.GetTimeOfLastChange(Windows.Win32.System.Com.IMoniker*,System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IServiceProvider_Extensions.QueryService(Windows.Win32.System.Com.IServiceProvider.Interface,System.Guid@,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IServiceProvider.Interface.QueryService(System.Guid*,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_IStream_Extensions.Stat(Windows.Win32.System.Com.IStream.Interface,Windows.Win32.System.Com.STATSTG@,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.System.Com.IStream.Interface.Stat(Windows.Win32.System.Com.STATSTG*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeComp_Extensions.Bind(Windows.Win32.System.Com.ITypeComp.Interface,Windows.Win32.Foundation.PWSTR,System.UInt32,System.UInt16,Windows.Win32.System.Com.ITypeInfo**,Windows.Win32.System.Com.DESCKIND@,Windows.Win32.System.Com.BINDPTR@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeComp.Interface.Bind(Windows.Win32.Foundation.PWSTR,System.UInt32,System.UInt16,Windows.Win32.System.Com.ITypeInfo**,Windows.Win32.System.Com.DESCKIND*,Windows.Win32.System.Com.BINDPTR*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.GetTypeAttr(Windows.Win32.System.Com.ITypeInfo.Interface,Windows.Win32.System.Com.TYPEATTR*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.GetTypeAttr(Windows.Win32.System.Com.TYPEATTR**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.GetFuncDesc(Windows.Win32.System.Com.ITypeInfo.Interface,System.UInt32,Windows.Win32.System.Com.FUNCDESC*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.GetFuncDesc(System.UInt32,Windows.Win32.System.Com.FUNCDESC**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.GetVarDesc(Windows.Win32.System.Com.ITypeInfo.Interface,System.UInt32,Windows.Win32.System.Com.VARDESC*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.GetVarDesc(System.UInt32,Windows.Win32.System.Com.VARDESC**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.GetNames(Windows.Win32.System.Com.ITypeInfo.Interface,System.Int32,Windows.Win32.Foundation.BSTR*,System.UInt32,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.GetNames(System.Int32,Windows.Win32.Foundation.BSTR*,System.UInt32,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.GetRefTypeOfImplType(Windows.Win32.System.Com.ITypeInfo.Interface,System.UInt32,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.GetRefTypeOfImplType(System.UInt32,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.GetImplTypeFlags(Windows.Win32.System.Com.ITypeInfo.Interface,System.UInt32,Windows.Win32.System.Com.IMPLTYPEFLAGS@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.GetImplTypeFlags(System.UInt32,Windows.Win32.System.Com.IMPLTYPEFLAGS*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.GetIDsOfNames(Windows.Win32.System.Com.ITypeInfo.Interface,System.ReadOnlySpan{Windows.Win32.Foundation.PWSTR},System.Span{System.Int32})">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.GetIDsOfNames(Windows.Win32.Foundation.PWSTR*,System.UInt32,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.Invoke(Windows.Win32.System.Com.ITypeInfo.Interface,System.Void*,System.Int32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS@,Windows.Win32.System.Variant.VARIANT@,Windows.Win32.System.Com.EXCEPINFO@,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.Invoke(System.Void*,System.Int32,Windows.Win32.System.Com.DISPATCH_FLAGS,Windows.Win32.System.Com.DISPPARAMS*,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.GetDocumentation(Windows.Win32.System.Com.ITypeInfo.Interface,System.Int32,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt32@,Windows.Win32.Foundation.BSTR*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.GetDocumentation(System.Int32,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt32*,Windows.Win32.Foundation.BSTR*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.GetDllEntry(Windows.Win32.System.Com.ITypeInfo.Interface,System.Int32,Windows.Win32.System.Com.INVOKEKIND,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt16@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.GetDllEntry(System.Int32,Windows.Win32.System.Com.INVOKEKIND,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt16*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.AddressOfMember(Windows.Win32.System.Com.ITypeInfo.Interface,System.Int32,Windows.Win32.System.Com.INVOKEKIND,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.AddressOfMember(System.Int32,Windows.Win32.System.Com.INVOKEKIND,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.CreateInstance(Windows.Win32.System.Com.ITypeInfo.Interface,Windows.Win32.System.Com.IUnknown*,System.Guid@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.CreateInstance(Windows.Win32.System.Com.IUnknown*,System.Guid*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.GetContainingTypeLib(Windows.Win32.System.Com.ITypeInfo.Interface,Windows.Win32.System.Com.ITypeLib**,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.GetContainingTypeLib(Windows.Win32.System.Com.ITypeLib**,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.ReleaseTypeAttr(Windows.Win32.System.Com.ITypeInfo.Interface,Windows.Win32.System.Com.TYPEATTR@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.ReleaseTypeAttr(Windows.Win32.System.Com.TYPEATTR*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.ReleaseFuncDesc(Windows.Win32.System.Com.ITypeInfo.Interface,Windows.Win32.System.Com.FUNCDESC@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.ReleaseFuncDesc(Windows.Win32.System.Com.FUNCDESC*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeInfo_Extensions.ReleaseVarDesc(Windows.Win32.System.Com.ITypeInfo.Interface,Windows.Win32.System.Com.VARDESC@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeInfo.Interface.ReleaseVarDesc(Windows.Win32.System.Com.VARDESC*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeLib_Extensions.GetTypeInfoType(Windows.Win32.System.Com.ITypeLib.Interface,System.UInt32,Windows.Win32.System.Com.TYPEKIND@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.Interface.GetTypeInfoType(System.UInt32,Windows.Win32.System.Com.TYPEKIND*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeLib_Extensions.GetTypeInfoOfGuid(Windows.Win32.System.Com.ITypeLib.Interface,System.Guid@,Windows.Win32.System.Com.ITypeInfo**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.Interface.GetTypeInfoOfGuid(System.Guid*,Windows.Win32.System.Com.ITypeInfo**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeLib_Extensions.GetLibAttr(Windows.Win32.System.Com.ITypeLib.Interface,Windows.Win32.System.Com.TLIBATTR*@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.Interface.GetLibAttr(Windows.Win32.System.Com.TLIBATTR**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeLib_Extensions.GetDocumentation(Windows.Win32.System.Com.ITypeLib.Interface,System.Int32,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt32@,Windows.Win32.Foundation.BSTR*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.Interface.GetDocumentation(System.Int32,Windows.Win32.Foundation.BSTR*,Windows.Win32.Foundation.BSTR*,System.UInt32*,Windows.Win32.Foundation.BSTR*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeLib_Extensions.IsName(Windows.Win32.System.Com.ITypeLib.Interface,System.Span{System.Char}@,System.UInt32,Windows.Win32.Foundation.BOOL@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.Interface.IsName(Windows.Win32.Foundation.PWSTR,System.UInt32,Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeLib_Extensions.FindName(Windows.Win32.System.Com.ITypeLib.Interface,System.Span{System.Char}@,System.UInt32,Windows.Win32.System.Com.ITypeInfo**,System.Int32*,System.UInt16@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.Interface.FindName(Windows.Win32.Foundation.PWSTR,System.UInt32,Windows.Win32.System.Com.ITypeInfo**,System.Int32*,System.UInt16*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_ITypeLib_Extensions.ReleaseTLibAttr(Windows.Win32.System.Com.ITypeLib.Interface,Windows.Win32.System.Com.TLIBATTR@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.ITypeLib.Interface.ReleaseTLibAttr(Windows.Win32.System.Com.TLIBATTR*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IEnumSTATSTG_Extensions.Next(Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.Interface,System.Span{Windows.Win32.System.Com.STATSTG},System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG.Interface.Next(System.UInt32,Windows.Win32.System.Com.STATSTG*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.CreateStream(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,System.String,Windows.Win32.System.Com.STGM,System.UInt32,System.UInt32,Windows.Win32.System.Com.IStream**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.CreateStream(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.STGM,System.UInt32,System.UInt32,Windows.Win32.System.Com.IStream**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.OpenStream(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,System.String,Windows.Win32.System.Com.STGM,System.UInt32,Windows.Win32.System.Com.IStream**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.OpenStream(Windows.Win32.Foundation.PCWSTR,System.Void*,Windows.Win32.System.Com.STGM,System.UInt32,Windows.Win32.System.Com.IStream**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.CreateStorage(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,System.String,Windows.Win32.System.Com.STGM,System.UInt32,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IStorage**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.CreateStorage(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.STGM,System.UInt32,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IStorage**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.OpenStorage(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,System.String,Windows.Win32.System.Com.StructuredStorage.IStorage*,Windows.Win32.System.Com.STGM,System.UInt16*@,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IStorage**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.OpenStorage(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.StructuredStorage.IStorage*,Windows.Win32.System.Com.STGM,System.UInt16**,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IStorage**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.CopyTo(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,System.ReadOnlySpan{System.Guid},System.UInt16**,Windows.Win32.System.Com.StructuredStorage.IStorage*)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.CopyTo(System.UInt32,System.Guid*,System.UInt16**,Windows.Win32.System.Com.StructuredStorage.IStorage*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.MoveElementTo(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,System.String,Windows.Win32.System.Com.StructuredStorage.IStorage*,System.String,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.MoveElementTo(Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Com.StructuredStorage.IStorage*,Windows.Win32.Foundation.PCWSTR,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.EnumElements(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG**)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.EnumElements(System.UInt32,System.Void*,System.UInt32,Windows.Win32.System.Com.StructuredStorage.IEnumSTATSTG**)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.DestroyElement(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,System.String)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.DestroyElement(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.RenameElement(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,System.String,System.String)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.RenameElement(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.SetElementTimes(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,System.String,System.Runtime.InteropServices.ComTypes.FILETIME@,System.Runtime.InteropServices.ComTypes.FILETIME@,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.SetElementTimes(Windows.Win32.Foundation.PCWSTR,System.Runtime.InteropServices.ComTypes.FILETIME*,System.Runtime.InteropServices.ComTypes.FILETIME*,System.Runtime.InteropServices.ComTypes.FILETIME*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.SetClass(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.SetClass(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.System_Com_StructuredStorage_IStorage_Extensions.Stat(Windows.Win32.System.Com.StructuredStorage.IStorage.Interface,Windows.Win32.System.Com.STATSTG@,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.System.Com.StructuredStorage.IStorage.Interface.Stat(Windows.Win32.System.Com.STATSTG*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IDispatchEx_Extensions.GetDispID(Windows.Win32.System.Ole.IDispatchEx.Interface,Windows.Win32.Foundation.BSTR,System.UInt32,System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.Interface.GetDispID(Windows.Win32.Foundation.BSTR,System.UInt32,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IDispatchEx_Extensions.InvokeEx(Windows.Win32.System.Ole.IDispatchEx.Interface,System.Int32,System.UInt32,System.UInt16,Windows.Win32.System.Com.DISPPARAMS@,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,Windows.Win32.System.Com.IServiceProvider*)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.Interface.InvokeEx(System.Int32,System.UInt32,System.UInt16,Windows.Win32.System.Com.DISPPARAMS*,Windows.Win32.System.Variant.VARIANT*,Windows.Win32.System.Com.EXCEPINFO*,Windows.Win32.System.Com.IServiceProvider*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IDispatchEx_Extensions.GetMemberProperties(Windows.Win32.System.Ole.IDispatchEx.Interface,System.Int32,System.UInt32,Windows.Win32.System.Ole.FDEX_PROP_FLAGS@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.Interface.GetMemberProperties(System.Int32,System.UInt32,Windows.Win32.System.Ole.FDEX_PROP_FLAGS*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IDispatchEx_Extensions.GetNextDispID(Windows.Win32.System.Ole.IDispatchEx.Interface,System.UInt32,System.Int32,System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDispatchEx.Interface.GetNextDispID(System.UInt32,System.Int32,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IDropTarget_Extensions.DragEnter(Windows.Win32.System.Ole.IDropTarget.Interface,Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDropTarget.Interface.DragEnter(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IDropTarget_Extensions.DragOver(Windows.Win32.System.Ole.IDropTarget.Interface,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDropTarget.Interface.DragOver(Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IDropTarget_Extensions.Drop(Windows.Win32.System.Ole.IDropTarget.Interface,Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IDropTarget.Interface.Drop(Windows.Win32.System.Com.IDataObject*,Windows.Win32.System.SystemServices.MODIFIERKEYS_FLAGS,Windows.Win32.Foundation.POINTL,Windows.Win32.System.Ole.DROPEFFECT*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.get_Handle(Windows.Win32.System.Ole.IPicture.Interface,Windows.Win32.System.Ole.OLE_HANDLE@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.get_Handle(Windows.Win32.System.Ole.OLE_HANDLE*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.get_hPal(Windows.Win32.System.Ole.IPicture.Interface,Windows.Win32.System.Ole.OLE_HANDLE@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.get_hPal(Windows.Win32.System.Ole.OLE_HANDLE*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.get_Type(Windows.Win32.System.Ole.IPicture.Interface,Windows.Win32.System.Ole.PICTYPE@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.get_Type(Windows.Win32.System.Ole.PICTYPE*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.get_Width(Windows.Win32.System.Ole.IPicture.Interface,System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.get_Width(System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.get_Height(Windows.Win32.System.Ole.IPicture.Interface,System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.get_Height(System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.Render(Windows.Win32.System.Ole.IPicture.Interface,Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.RECT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.Render(Windows.Win32.Graphics.Gdi.HDC,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.RECT*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.get_CurDC(Windows.Win32.System.Ole.IPicture.Interface,Windows.Win32.Graphics.Gdi.HDC@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.get_CurDC(Windows.Win32.Graphics.Gdi.HDC*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.SelectPicture(Windows.Win32.System.Ole.IPicture.Interface,Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HDC@,Windows.Win32.System.Ole.OLE_HANDLE@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.SelectPicture(Windows.Win32.Graphics.Gdi.HDC,Windows.Win32.Graphics.Gdi.HDC*,Windows.Win32.System.Ole.OLE_HANDLE*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.get_KeepOriginalFormat(Windows.Win32.System.Ole.IPicture.Interface,Windows.Win32.Foundation.BOOL@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.get_KeepOriginalFormat(Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.SaveAsFile(Windows.Win32.System.Ole.IPicture.Interface,Windows.Win32.System.Com.IStream*,Windows.Win32.Foundation.BOOL,System.Int32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.SaveAsFile(Windows.Win32.System.Com.IStream*,Windows.Win32.Foundation.BOOL,System.Int32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IPicture_Extensions.get_Attributes(Windows.Win32.System.Ole.IPicture.Interface,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IPicture.Interface.get_Attributes(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IRecordInfo_Extensions.GetGuid(Windows.Win32.System.Ole.IRecordInfo.Interface,System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.Interface.GetGuid(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IRecordInfo_Extensions.GetSize(Windows.Win32.System.Ole.IRecordInfo.Interface,System.UInt32@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.Interface.GetSize(System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IRecordInfo_Extensions.GetField(Windows.Win32.System.Ole.IRecordInfo.Interface,System.Void*,System.String,Windows.Win32.System.Variant.VARIANT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.Interface.GetField(System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IRecordInfo_Extensions.GetFieldNoCopy(Windows.Win32.System.Ole.IRecordInfo.Interface,System.Void*,System.String,Windows.Win32.System.Variant.VARIANT@,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.Interface.GetFieldNoCopy(System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IRecordInfo_Extensions.PutField(Windows.Win32.System.Ole.IRecordInfo.Interface,System.UInt32,System.Void*,System.String,Windows.Win32.System.Variant.VARIANT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.Interface.PutField(System.UInt32,System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IRecordInfo_Extensions.PutFieldNoCopy(Windows.Win32.System.Ole.IRecordInfo.Interface,System.UInt32,System.Void*,System.String,Windows.Win32.System.Variant.VARIANT@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.Interface.PutFieldNoCopy(System.UInt32,System.Void*,Windows.Win32.Foundation.PCWSTR,Windows.Win32.System.Variant.VARIANT*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IRecordInfo_Extensions.GetFieldNames(Windows.Win32.System.Ole.IRecordInfo.Interface,System.UInt32@,Windows.Win32.Foundation.BSTR*)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.Interface.GetFieldNames(System.UInt32*,Windows.Win32.Foundation.BSTR*)"/>
        </member>
        <member name="M:Windows.Win32.System_Ole_IRecordInfo_Extensions.RecordCreateCopy(Windows.Win32.System.Ole.IRecordInfo.Interface,System.Void*,System.Void*@)">
            <inheritdoc cref="M:Windows.Win32.System.Ole.IRecordInfo.Interface.RecordCreateCopy(System.Void*,System.Void**)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_IDataObjectAsyncCapability_Extensions.GetAsyncMode(Windows.Win32.UI.Shell.IDataObjectAsyncCapability.Interface,Windows.Win32.Foundation.BOOL@)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.Interface.GetAsyncMode(Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_IDataObjectAsyncCapability_Extensions.InOperation(Windows.Win32.UI.Shell.IDataObjectAsyncCapability.Interface,Windows.Win32.Foundation.BOOL@)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDataObjectAsyncCapability.Interface.InOperation(Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_IDragSourceHelper2_Extensions.InitializeFromBitmap(Windows.Win32.UI.Shell.IDragSourceHelper2.Interface,Windows.Win32.UI.Shell.SHDRAGIMAGE@,Windows.Win32.System.Com.IDataObject*)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDragSourceHelper2.Interface.InitializeFromBitmap(Windows.Win32.UI.Shell.SHDRAGIMAGE*,Windows.Win32.System.Com.IDataObject*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_IDragSourceHelper2_Extensions.InitializeFromWindow(Windows.Win32.UI.Shell.IDragSourceHelper2.Interface,Windows.Win32.Foundation.HWND,System.Nullable{System.Drawing.Point},Windows.Win32.System.Com.IDataObject*)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDragSourceHelper2.Interface.InitializeFromWindow(Windows.Win32.Foundation.HWND,System.Drawing.Point*,Windows.Win32.System.Com.IDataObject*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_IDragSourceHelper_Extensions.InitializeFromBitmap(Windows.Win32.UI.Shell.IDragSourceHelper.Interface,Windows.Win32.UI.Shell.SHDRAGIMAGE@,Windows.Win32.System.Com.IDataObject*)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDragSourceHelper.Interface.InitializeFromBitmap(Windows.Win32.UI.Shell.SHDRAGIMAGE*,Windows.Win32.System.Com.IDataObject*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_IDragSourceHelper_Extensions.InitializeFromWindow(Windows.Win32.UI.Shell.IDragSourceHelper.Interface,Windows.Win32.Foundation.HWND,System.Nullable{System.Drawing.Point},Windows.Win32.System.Com.IDataObject*)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDragSourceHelper.Interface.InitializeFromWindow(Windows.Win32.Foundation.HWND,System.Drawing.Point*,Windows.Win32.System.Com.IDataObject*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_IDropTargetHelper_Extensions.DragEnter(Windows.Win32.UI.Shell.IDropTargetHelper.Interface,Windows.Win32.Foundation.HWND,Windows.Win32.System.Com.IDataObject*,System.Drawing.Point@,Windows.Win32.System.Ole.DROPEFFECT)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDropTargetHelper.Interface.DragEnter(Windows.Win32.Foundation.HWND,Windows.Win32.System.Com.IDataObject*,System.Drawing.Point*,Windows.Win32.System.Ole.DROPEFFECT)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_IDropTargetHelper_Extensions.DragOver(Windows.Win32.UI.Shell.IDropTargetHelper.Interface,System.Drawing.Point@,Windows.Win32.System.Ole.DROPEFFECT)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDropTargetHelper.Interface.DragOver(System.Drawing.Point*,Windows.Win32.System.Ole.DROPEFFECT)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_IDropTargetHelper_Extensions.Drop(Windows.Win32.UI.Shell.IDropTargetHelper.Interface,Windows.Win32.System.Com.IDataObject*,System.Drawing.Point@,Windows.Win32.System.Ole.DROPEFFECT)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.IDropTargetHelper.Interface.Drop(Windows.Win32.System.Com.IDataObject*,System.Drawing.Point*,Windows.Win32.System.Ole.DROPEFFECT)"/>
        </member>
        <member name="T:WinFormsComStrategy">
            <summary>
             Windows Forms <see cref="T:System.Runtime.InteropServices.Marshalling.StrategyBasedComWrappers"/> implementation.
            </summary>
            <remarks>
             <para>
              Deriving from <see cref="T:System.Runtime.InteropServices.Marshalling.StrategyBasedComWrappers"/> allows us to leverage the functionality the runtime
              has implemented for source generated "RCW"s, including support for <see cref="T:System.Runtime.InteropServices.ComImportAttribute"/> adaption
              when built-in COM support is available (EnableGeneratedComInterfaceComImportInterop).
             </para>
             <para>
              It isn't immediately clear how we could merge <see cref="T:WinFormsComWrappers"/> with this as there is no
              strategy for <see cref="M:System.Runtime.InteropServices.ComWrappers.ComputeVtables(System.Object,System.Runtime.InteropServices.CreateComInterfaceFlags,System.Int32@)"/>. We rely
              on <see cref="T:Windows.Win32.System.Com.IManagedWrapper"/> to apply the needed vtable functionality and it doesn't appear that we
              can apply <see cref="T:System.Runtime.InteropServices.Marshalling.IComExposedDetails"/> without manually implementing (or source generating)
              <see cref="M:System.Runtime.InteropServices.Marshalling.IComExposedDetails.GetComInterfaceEntries(System.Int32@)"/> on our exposed classes.
             </para>
            </remarks>
        </member>
        <member name="T:WinFormsComWrappers">
            <summary>
             The <see cref="T:System.Runtime.InteropServices.ComWrappers"/> implementation for WinForm's COM interop usages.
            </summary>
        </member>
        <member name="M:WinFormsComWrappers.UnwrapAndInvoke``2(``0*,System.Func{``1,Windows.Win32.Foundation.HRESULT})">
            <summary>
             For the given <paramref name="this"/> pointer unwrap the associated managed object and use it to
             invoke <paramref name="func"/>.
            </summary>
            <remarks>
             <para>
              Handles exceptions and converts to <see cref="T:Windows.Win32.Foundation.HRESULT"/>.
             </para>
            </remarks>
        </member>
        <member name="M:WinFormsComWrappers.UnwrapAndInvoke``2(``0*,System.Action{``1})">
            <summary>
             For the given <paramref name="this"/> pointer unwrap the associated managed object and use it to
             invoke <paramref name="action"/>.
            </summary>
            <inheritdoc cref="M:WinFormsComWrappers.UnwrapAndInvoke``2(``0*,System.Func{``1,Windows.Win32.Foundation.HRESULT})"/>
        </member>
    </members>
</doc>
